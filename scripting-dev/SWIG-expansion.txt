[build]   Swig compile obspython.i for python
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\swig.swg" %beginfile
[build]   /* -----------------------------------------------------------------------------
[build]    * swig.swg
[build]    *
[build]    * Common macro definitions for various SWIG directives.  This file is always 
[build]    * included at the top of each input file.
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * User Directives 
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   /* Deprecated SWIG-1.1 directives */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* Code insertion directives such as %wrapper %{ ... %} */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* Class extension */
[build]   
[build]   
[build]   
[build]   /* %ignore directive */
[build]   
[build]   
[build]   
[build]   
[build]   /* Access control directives */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* Generation of default constructors/destructors (old form, don't use) */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* Disable the generation of implicit default constructor */
[build]   
[build]   
[build]   
[build]   
[build]   /* Disable the generation of implicit default destructor (dangerous) */
[build]   
[build]   
[build]   
[build]   
[build]   /* Enable the generation of copy constructor */
[build]   
[build]   
[build]   
[build]   
[build]   /* Force the old nodefault behavior, ie disable both constructor and destructor */
[build]   
[build]   
[build]   
[build]   
[build]   /* the %exception directive */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* the %allowexception directive allows the %exception feature to
[build]      be applied to set/get variable methods */
[build]   
[build]   
[build]   
[build]   
[build]   /* the %exceptionvar directive, as %exception but it is only applied
[build]      to set/get variable methods. You don't need to use the
[build]      %allowexception directive when using %exceptionvar.
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* the %catches directive */
[build]   
[build]   
[build]   
[build]   /* the %exceptionclass directive */
[build]   
[build]   
[build]   
[build]   
[build]   /* the %newobject directive */
[build]   
[build]   
[build]   
[build]   
[build]   /* the %delobject directive */
[build]   
[build]   
[build]   
[build]   
[build]   /* the %refobject/%unrefobject directives */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* Directives for callback functions (experimental) */
[build]   
[build]   
[build]   
[build]   
[build]   /* the %nestedworkaround directive (deprecated) */
[build]   
[build]   
[build]   
[build]   
[build]   /* the %flatnested directive */
[build]   
[build]   
[build]   
[build]   
[build]   /* the %fastdispatch directive */
[build]   
[build]   
[build]   
[build]   
[build]   /* directors directives */
[build]   
[build]   
[build]   
[build]   
[build]   /* naturalvar directives */
[build]   
[build]   
[build]   
[build]   
[build]   /* nspace directives */
[build]   
[build]   
[build]   
[build]   
[build]   /* valuewrapper directives */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* Contract support - Experimental and undocumented */
[build]   
[build]   
[build]   
[build]   
[build]   /* Macro for setting a dynamic cast function */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* aggregation support */
[build]   /*
[build]     This macro performs constant aggregation.  Basically the idea of
[build]     constant aggregation is that you can group a collection of constants
[build]     together.  For example, suppose you have some code like this:
[build]   
[build]          #define UP  1
[build]          #define DOWN 2
[build]          #define LEFT 3
[build]          #define RIGHT 4
[build]   
[build]     Now, suppose you had a function like this:
[build]   
[build]          int move(int direction)
[build]   
[build]     In this case, you might want to restrict the direction argument to
[build]     one of the supplied constant names. To do this, you could write some
[build]     typemap code by hand.  Alternatively, you can use the
[build]     %aggregate_check macro defined here to create a simple check
[build]     function for you.  Here is an example:
[build]   
[build]       %aggregate_check(int, check_direction, UP, DOWN, LEFT, RIGHT);
[build]   
[build]     Now, using a typemap
[build]   
[build]       %typemap(check) int direction {
[build]         if (!check_direction($1)) SWIG_exception(SWIG_ValueError,"Bad direction.");
[build]       }
[build]   
[build]     or a contract (better)
[build]   
[build]       %contract move(int x) {
[build]       require:
[build]           check_direction(x);
[build]       }
[build]   
[build]   */
[build]      
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * %rename predicates
[build]    * ----------------------------------------------------------------------------- */
[build]   /* 
[build]      Predicates to be used with %rename, for example:
[build]   
[build]      - to rename all the functions:
[build]   
[build]        %rename("%(utitle)s", %$isfunction) "";
[build]   
[build]      - to rename only the member methods:
[build]   
[build]        %rename("m_%(utitle)s", %$isfunction, %$ismember) "";
[build]   
[build]      - to rename only the global functions:
[build]   
[build]         %rename("m_%(utitle)s", %$isfunction, %$not %$ismember) "";
[build]   
[build]        or
[build]   
[build]         %rename("g_%(utitle)s", %$isfunction, %$isglobal) "";
[build]   
[build]      - to ignore the enumitems in a given class:
[build]   
[build]        %rename("$ignore", %$isenumitem, %$classname="MyClass") "";
[build]   
[build]      we use the prefix '%$' to avoid clashes with other swig
[build]      macros/directives.
[build]   
[build]   */
[build]   
[build]    
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]     /* %constant definition */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * Include all the warnings labels and macros 
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\swigwarnings.swg" %beginfile
[build]   /*
[build]     Include the internal swig macro codes. These macros correspond to
[build]     the one found in Source/Include/swigwarn.h plus the 'SWIG' prefix.
[build]     
[build]     For example, in the include file 'swigwarn.h' you will find
[build]   
[build]       #define WARN_TYPEMAP_CHARLEAK ...
[build]   
[build]     and in the 'swigwarn.swg' interface, you will see
[build]   
[build]       %define SWIGWARN_TYPEMAP_CHARLEAK ...
[build]   
[build]     This code can be used in warning filters as follows:
[build]   
[build]       %warnfilter(SWIGWARN_TYPEMAP_CHARLEAK);
[build]   
[build]     Warnings messages used in typemaps. Message names will be the same
[build]     as those in Lib/swigwarn.swg but with the suffix _MSG.
[build]      
[build]     For example, for the code SWIGWARN_TYPEMAP_CHARLEAK, once you use
[build]   
[build]       %typemapmsg(CHARLEAK,<msg>);
[build]   
[build]     you use the message in your typemap as
[build]   
[build]       %typemap(varin,warning=SWIGWARN_TYPEMAP_CHARLEAK_MSG) char * 
[build]   
[build]     while you suppress the warning using
[build]   
[build]       %warnfilter(SWIGWARN_TYPEMAP_CHARLEAK);
[build]   
[build]     as described above.
[build]   */
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * SWIG warning codes
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\swigwarn.swg" %beginfile
[build]   /* SWIG warning codes */
[build]   
[build]   
[build]   
[build]   
[build]   /* -- Deprecated features -- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* -- Preprocessor -- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* -- C/C++ Parser -- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]     /* redundant now */
[build]     /* redundant now */
[build]   
[build]   
[build]   	/* new */
[build]   	/* delete */
[build]   	/* + */
[build]   	/* - */
[build]   	/* * */
[build]   	/* / */
[build]   	/* % */
[build]   	/* ^ */
[build]   	/* & */
[build]   	/* | */
[build]   	/* ~ */
[build]   	/* ! */
[build]   	/* = */
[build]   	/* < */
[build]   	/* > */
[build]   	/* += */
[build]   	/* -= */
[build]   	/* *= */
[build]   	/* /= */
[build]   	/* %= */
[build]   	/* ^= */
[build]   	/* &= */
[build]   	/* |= */
[build]   	/* << */
[build]   	/* >> */
[build]   	/* <<= */
[build]   	/* >>= */
[build]   	/* == */
[build]   	/* != */
[build]   	/* <= */
[build]   	/* >= */
[build]   	/* && */
[build]   	/* || */
[build]   	/* ++ */
[build]   	/* -- */
[build]   	/* , */
[build]   	/* ->* */
[build]   	/* -> */
[build]   	/* () */
[build]   	/* [] */
[build]   	/* + */
[build]   	/* - */
[build]   	/* * */
[build]   	/* & */
[build]   	/* new [] */
[build]   	/* delete [] */
[build]   	/* operator *() */
[build]   
[build]   /* 394-399 are reserved */
[build]   
[build]   /* -- Type system and typemaps -- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   	/* mostly used in directorout typemaps */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* -- Fragments -- */
[build]   
[build]   
[build]   /* -- General code generation -- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* -- Reserved (600-799) -- */
[build]   
[build]   /* -- Language module specific warnings (700 - 899) -- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* please leave 700-719 free for D */
[build]   
[build]   
[build]   
[build]   /* please leave 720-739 free for Scilab */
[build]   
[build]   
[build]   
[build]   /* please leave 740-759 free for Python */
[build]   
[build]   
[build]   
[build]   
[build]   /* please leave 800-809 free for Ruby */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* please leave 810-829 free for Java */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* please leave 830-849 free for C# */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* please leave 850-869 free for Modula 3 */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* please leave 870-889 free for PHP */
[build]   
[build]   
[build]   
[build]   /* please leave 890-899 free for Go */
[build]   
[build]   /* -- User defined warnings (900 - 999) -- */
[build]   
[build]   %endoffile
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * Auxiliary macros
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   /* Macro to define warning messages */
[build]   
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    *  Typemap related warning messages
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * Operator related warning messages 
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * Macros for keyword and built-in names 
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * Warning filter feature
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * Overloading support
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   /*
[build]    * Function/method overloading support.   This is done through typemaps,
[build]    * but also involves a precedence level.
[build]    */
[build]   
[build]   /* Macro for overload resolution */
[build]   
[build]   
[build]   
[build]   /* Macros for precedence levels */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * Default handling of certain overloaded operators 
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * Default char * and C array typemaps
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   /* Set up the typemap for handling new return strings */
[build]   
[build]   
[build]   
[build]   
[build]   %typemap(newfree) char * "free($1);";
[build]   
[build]   
[build]   /* Default typemap for handling char * members */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %typemap(memberin) char * {
[build]     free($1);
[build]     if ($input) {
[build]        $1 = ($1_type) malloc(strlen((const char *)$input)+1);
[build]        strcpy((char *)$1, (const char *)$input);
[build]     } else {
[build]        $1 = 0;
[build]     }
[build]   }
[build]   %typemap(memberin,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
[build]     if ($input) {
[build]        $1 = ($1_type) malloc(strlen((const char *)$input)+1);
[build]        strcpy((char *)$1, (const char *)$input);
[build]     } else {
[build]        $1 = 0;
[build]     }
[build]   }
[build]   %typemap(globalin) char * {
[build]     free($1);
[build]     if ($input) {
[build]        $1 = ($1_type) malloc(strlen((const char *)$input)+1);
[build]        strcpy((char *)$1, (const char *)$input);
[build]     } else {
[build]        $1 = 0;
[build]     }
[build]   }
[build]   %typemap(globalin,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
[build]     if ($input) {
[build]        $1 = ($1_type) malloc(strlen((const char *)$input)+1);
[build]        strcpy((char *)$1, (const char *)$input);
[build]     } else {
[build]        $1 = 0;
[build]     }
[build]   }
[build]   
[build]   
[build]   
[build]   /* Character array handling */
[build]   
[build]   %typemap(memberin) char [ANY] {
[build]     if($input) {
[build]       strncpy((char*)$1, (const char *)$input, $1_dim0-1);
[build]       $1[$1_dim0-1] = 0;
[build]     } else {
[build]       $1[0] = 0;
[build]     }
[build]   }
[build]   
[build]   %typemap(globalin) char [ANY] {
[build]     if($input) {
[build]       strncpy((char*)$1, (const char *)$input, $1_dim0-1);
[build]       $1[$1_dim0-1] = 0;
[build]     } else {
[build]       $1[0] = 0;
[build]     }
[build]   }
[build]   
[build]   %typemap(memberin) char [] {
[build]     if ($input) strcpy((char *)$1, (const char *)$input);
[build]     else $1[0] = 0;
[build]   }
[build]   
[build]   %typemap(globalin) char [] {
[build]     if ($input) strcpy((char *)$1, (const char *)$input);
[build]     else $1[0] = 0;
[build]   }
[build]   
[build]   /* memberin/globalin typemap for arrays. */
[build]   
[build]   %typemap(memberin) SWIGTYPE [ANY] {
[build]     size_t ii;
[build]     $1_basetype *b = ($1_basetype *) $1;
[build]     for (ii = 0; ii < (size_t)$1_size; ii++) b[ii] = *(($1_basetype *) $input + ii);
[build]   }
[build]   
[build]   %typemap(globalin) SWIGTYPE [ANY] {
[build]     size_t ii;
[build]     $1_basetype *b = ($1_basetype *) $1;
[build]     for (ii = 0; ii < (size_t)$1_size; ii++) b[ii] = *(($1_basetype *) $input + ii);
[build]   }
[build]   
[build]   /* memberin/globalin typemap for double arrays. */
[build]   
[build]   %typemap(memberin) SWIGTYPE [ANY][ANY] {
[build]     $basetype (*inp)[$1_dim1] = ($basetype (*)[$1_dim1])($input);
[build]     $basetype (*dest)[$1_dim1] = ($basetype (*)[$1_dim1])($1);
[build]     size_t ii = 0;
[build]     for (; ii < $1_dim0; ++ii) {
[build]       $basetype *ip = inp[ii];
[build]       $basetype *dp = dest[ii];
[build]       size_t jj = 0;
[build]       for (; jj < $1_dim1; ++jj) dp[jj] = ip[jj];
[build]     }
[build]   }
[build]   
[build]   %typemap(globalin) SWIGTYPE [ANY][ANY] {
[build]     $basetype (*inp)[$1_dim1] = ($basetype (*)[$1_dim1])($input);
[build]     $basetype (*dest)[$1_dim1] = ($basetype (*)[$1_dim1])($1);
[build]     size_t ii = 0;
[build]     for (; ii < $1_dim0; ++ii) {
[build]       $basetype *ip = inp[ii];
[build]       $basetype *dp = dest[ii];
[build]       size_t jj = 0;
[build]       for (; jj < $1_dim1; ++jj) dp[jj] = ip[jj];
[build]     }
[build]   }
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    *  Runtime code
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   /*  The SwigValueWrapper class  */
[build]   
[build]   /*  
[build]    * This template wrapper is used to handle C++ objects that are passed or 
[build]    * returned by value.   This is necessary to handle objects that define
[build]    * no default-constructor (making it difficult for SWIG to properly declare
[build]    * local variables).
[build]    *
[build]    * The wrapper is used as follows.  First consider a function like this:
[build]    *
[build]    *      Vector cross_product(Vector a, Vector b)
[build]    *
[build]    * Now, if Vector is defined as a C++ class with no default constructor, 
[build]    * code is generated as follows:
[build]    *
[build]    *     Vector *wrap_cross_product(Vector *inarg1, Vector *inarg2) {
[build]    *          SwigValueWrapper<Vector>  arg1;
[build]    *          SwigValueWrapper<Vector>  arg2;
[build]    *          SwigValueWrapper<Vector> result;
[build]    *
[build]    *          arg1 = *inarg1;
[build]    *          arg2 = *inarg2;
[build]    *          ...            
[build]    *          result = cross_product(arg1,arg2);
[build]    *          ...
[build]    *          return new Vector(result);
[build]    *    }
[build]    *         
[build]    * In the wrappers, the template SwigValueWrapper simply provides a thin
[build]    * layer around a Vector *.  However, it does this in a way that allows
[build]    * the object to be bound after the variable declaration (which is not possible
[build]    * with the bare object when it lacks a default constructor).  
[build]    *
[build]    * An observant reader will notice that the code after the variable declarations
[build]    * is *identical* to the code used for classes that do define default constructors.
[build]    * Thus, this neat trick allows us to fix this special case without having to
[build]    * make massive changes to typemaps and other parts of the SWIG code generator.
[build]    *
[build]    * Note: this code is not included when SWIG runs in C-mode, when classes
[build]    * define default constructors, or when pointers and references are used.
[build]    * SWIG tries to avoid doing this except in very special circumstances.
[build]    *
[build]    * Note: This solution suffers from making a large number of copies
[build]    * of the underlying object.  However, this is needed in the interest of
[build]    * safety and in order to cover all of the possible ways in which a value
[build]    * might be assigned.  For example:
[build]    *
[build]    *       arg1 = *inarg1;       // Assignment from a pointer
[build]    *       arg1 = Vector(1,2,3); // Assignment from a value  
[build]    *
[build]    * The class offers a strong guarantee of exception safety.
[build]    * With regards to the implementation, the private SwigMovePointer nested class is 
[build]    * a simple smart pointer with move semantics, much like std::auto_ptr.
[build]    *
[build]    * This wrapping technique was suggested by William Fulton and is henceforth
[build]    * known as the "Fulton Transform" :-).
[build]    */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*  The swiglabels  */
[build]   
[build]   %insert("runtime") "swiglabels.swg"
[build]   
[build]   
[build]   %endoffile
[build]   
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\python\\python.swg" %beginfile
[build]   /* ------------------------------------------------------------
[build]    * python.swg
[build]    *
[build]    * Python configuration module.
[build]    * ------------------------------------------------------------ */
[build]   
[build]   /* ------------------------------------------------------------
[build]    *  Inner macros
[build]    * ------------------------------------------------------------ */
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\python\\pymacros.swg" %beginfile
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\typemaps\\swigmacros.swg" %beginfile
[build]   /* -----------------------------------------------------------------------------
[build]    * SWIG API. Portion only visible from SWIG
[build]    * ----------------------------------------------------------------------------- */
[build]   /*
[build]     This file implements the internal macros of the 'SWIG API', which
[build]     are useful to implement all the SWIG target languages.
[build]   
[build]     Basic preprocessor macros:
[build]     --------------------------
[build]   
[build]       %arg(Arg)               Safe argument wrap
[build]       %str(Arg)               Stringify the argument
[build]       %begin_block            Begin an execution block
[build]       %end_block              End an execution block
[build]       %block(Block)           Execute Block as an execution block
[build]       %define_as(Def, Val)    Define 'Def' as 'Val', expanding Def and Val first
[build]       %ifcplusplus(V1, V2)    if C++ Mode; then V1; else V2; fi
[build]   
[build]   
[build]     Casting Operations:
[build]     -------------------
[build]   
[build]     SWIG provides the following casting macros, which implement the
[build]     corresponding C++ casting operations:
[build]   
[build]       %const_cast(a, Type)         const_cast<Type >(a)
[build]       %static_cast(a, Type)      	 static_cast<Type >(a)
[build]       %reinterpret_cast(a, Type) 	 reinterpret_cast<Type >(a)
[build]       %numeric_cast(a, Type)     	 static_cast<Type >(a)
[build]       %as_voidptr(a)            	 const_cast<void *>(static_cast<const void *>(a))
[build]       %as_voidptrptr(a)        	 reinterpret_cast<void **>(a)
[build]   
[build]     or their C unsafe versions. In C++ we use the safe version unless
[build]     SWIG_NO_CPLUSPLUS_CAST is defined (usually via the -nocppcast swig flag).
[build]   
[build]   
[build]     Memory allocation:
[build]     ------------------
[build]   
[build]     These allocation/freeing macros are safe to use in C or C++ and
[build]     dispatch the proper new/delete/delete[] or free/malloc calls as
[build]     needed.
[build]   
[build]       %new_instance(Type)             Allocate a new instance of given Type
[build]       %new_copy(value,Type)           Allocate and initialize a new instance with 'value'
[build]       %new_array(size,Type)           Allocate a new array with given size and Type and zero initialize
[build]       %new_copy_array(cptr,size,Type) Allocate and initialize a new array from 'cptr'
[build]       %delete(cptr)                   Delete an instance
[build]       %delete_array(cptr)             Delete an array
[build]   
[build]   
[build]     Auxiliary loop macros:
[build]     ----------------------
[build]   
[build]       %formacro(Macro, Args...) or %formacro_1(Macro, Args...)
[build]          for i in Args
[build]          do
[build]             Macro($i)
[build]          done
[build]   
[build]       %formacro_2(Macro2, Args...)
[build]          for i,j in Args
[build]          do
[build]             Macro2($i, $j)
[build]          done
[build]   
[build]   
[build]     Flags and conditional macros:
[build]     -----------------------------
[build]   
[build]        %mark_flag(flag)
[build]          flag := True
[build]   
[build]        %evalif(flag,expr)
[build]          if flag; then
[build]            expr
[build]          fi
[build]   
[build]        %evalif_2(flag1 flag2,expr)
[build]          if flag1 and flag2; then
[build]            expr
[build]          fi
[build]   
[build]   
[build]   */
[build]   /* -----------------------------------------------------------------------------
[build]    * Basic preprocessor macros
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* define a new macro */
[build]   
[build]   
[build]   /* include C++ or else value */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* insert the SWIGVERSION in the interface and the wrapper code */
[build]   
[build]   %insert("header") {
[build]   #define SWIGVERSION 0x030012 
[build]   #define SWIG_VERSION SWIGVERSION
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * Casting operators
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %insert("header") {
[build]   #define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
[build]   #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
[build]   }
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * Allocating/freeing elements
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * SWIG names and mangling
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * Auxiliary loop macros
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   /* for loop for macro with one argument */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* for loop for macro with one argument */
[build]   
[build]   
[build]   
[build]   /* for loop for macro with two arguments */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* for loop for macro with two arguments */
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * SWIG flags
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   /*
[build]     mark a flag, ie, define a macro name but ignore it in
[build]     the interface.
[build]   
[build]     the flag can be later used with %evalif
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   /*
[build]     %evalif and %evalif_2 are use to evaluate or process
[build]     an expression if the given predicate is 'true' (1).
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   
[build]   
[build]   /* ------------------------------------------------------------
[build]    *  The runtime part
[build]    * ------------------------------------------------------------ */
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\python\\pyruntime.swg" %beginfile
[build]   %insert(runtime) %{
[build]   #if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
[build]   /* Use debug wrappers with the Python release dll */
[build]   # undef _DEBUG
[build]   # include <Python.h>
[build]   # define _DEBUG
[build]   #else
[build]   # include <Python.h>
[build]   #endif
[build]   %}
[build]   
[build]   %insert(runtime) "swigrun.swg";         /* SWIG API */
[build]   %insert(runtime) "swigerrors.swg";      /* SWIG errors */   
[build]   %insert(runtime) "pyhead.swg";          /* Python includes and fixes */
[build]   %insert(runtime) "pyerrors.swg";        /* Python errors */
[build]   %insert(runtime) "pythreads.swg";       /* Python thread code */
[build]   %insert(runtime) "pyapi.swg";           /* Python API */
[build]   %insert(runtime) "pyrun.swg";           /* Python run-time code */
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   
[build]   /* ------------------------------------------------------------
[build]    *  Special user directives
[build]    * ------------------------------------------------------------ */
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\python\\pyuserdir.swg" %beginfile
[build]   /* -------------------------------------------------------------------------
[build]    *  Special user directives
[build]    * ------------------------------------------------------------------------- */
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   
[build]   /* shadow code */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* 
[build]   Use the "nondynamic" feature to make a wrapped class behave as a "nondynamic"
[build]   one, ie, a python class that doesn't dynamically add new attributes.
[build]   
[build]   For example, for the class
[build]   
[build]   %pythonnondynamic A;
[build]   struct A
[build]   {
[build]     int a;
[build]     int b;
[build]   };
[build]   
[build]   you will get:
[build]   
[build]    aa = A()
[build]    aa.a = 1  # Ok
[build]    aa.b = 1  # Ok
[build]    aa.c = 3  # error
[build]   
[build]   Since nondynamic is a feature, if you use it like
[build]   
[build]    %pythonnondynamic;
[build]   
[build]   it will make all the wrapped classes nondynamic ones.
[build]   
[build]   The implementation is based on this recipe:
[build]   
[build]      http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/252158
[build]   
[build]   and works for modern (-modern) and plain python. We do not use __slots__, 
[build]   so, it works with old python versions.
[build]   
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /*
[build]   
[build]   Use %pythonmaybecall to flag a method like __add__ or __radd__.  These
[build]   don't produce an error when called, they just return NotImplemented.
[build]   
[build]   These methods "may be called" if needed.
[build]   
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /*
[build]     The %pythoncallback feature produce a more natural callback wrapper
[build]     than the %callback mechanism, ie, it uses the original name for
[build]     the callback and callable objects. 
[build]   
[build]     Just use it as
[build]   
[build]       %pythoncallback(1) foo;
[build]       int foo(int a);
[build]   
[build]       %pythoncallback(1) A::foo;
[build]       struct A {
[build]        static int foo(int a);
[build]       };
[build]   
[build]       int bar(int, int (*pf)(int));
[build]   
[build]     then, you can use it as:
[build]   
[build]      a = foo(1)
[build]      b = bar(2, foo)
[build]   
[build]      c = A.foo(3)
[build]      d = bar(4, A.foo)
[build]   
[build]   
[build]      If you use it with a member method
[build]      %pythoncallback(1) A::foom;
[build]      struct A {
[build]         int foom(int a);
[build]      };
[build]   
[build]      then you can use it as
[build]   
[build]        r = a.foom(3)             # eval the method
[build]        mptr = A.foom_cb_ptr      # returns the callback pointer
[build]   
[build]      where the '_cb_ptr' suffix is added for the callback pointer.
[build]   
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /*
[build]     Support for the old %callback directive name
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /*
[build]     Thread support - Advance control
[build]     
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /*
[build]     Implicit Conversion using the C++ constructor mechanism
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /*
[build]     Enable keywords paramaters
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /*
[build]     Add python code to the proxy/shadow code 
[build]     
[build]      %pythonprepend   - Add code before the C++ function is called
[build]      %pythonappend    - Add code after the C++ function is called
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* 
[build]      %extend_smart_pointer extend the smart pointer support.
[build]   
[build]      For example, if you have a smart pointer as:
[build]   	    
[build]        template <class Type> class RCPtr {
[build]        public:
[build]          ...
[build]          RCPtr(Type *p);
[build]      	Type * operator->() const;
[build]      	...
[build]        };
[build]        
[build]      you use the %extend_smart_pointer directive as:
[build]      
[build]        %extend_smart_pointer(RCPtr<A>);
[build]        %template(RCPtr_A)  RCPtr<A>;
[build]      
[build]      then, if you have something like:
[build]   
[build]        RCPtr<A> make_ptr();
[build]        int foo(A *);
[build]   
[build]      you can do the following:
[build]   
[build]        a = make_ptr();
[build]        b = foo(a);
[build]   
[build]      ie, swig will accept a RCPtr<A> object where a 'A *' is
[build]      expected.
[build]   
[build]      Also, when using vectors
[build]      
[build]        %extend_smart_pointer(RCPtr<A>);
[build]        %template(RCPtr_A) RCPtr<A>;
[build]        %template(vector_A) std::vector<RCPtr<A> >;
[build]      	
[build]      you can type
[build]   
[build]        a = A();
[build]        v = vector_A(2)
[build]        v[0] = a
[build]   
[build]      ie, an 'A *' object is accepted, via implicit conversion, 
[build]      where a RCPtr<A> object is expected. Additionally
[build]   
[build]        x = v[0]
[build]   
[build]      returns (and sets 'x' as) a copy of v[0], making reference
[build]      counting possible and consistent.
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   
[build]   /* ------------------------------------------------------------
[build]    *  Typemap specializations
[build]    * ------------------------------------------------------------ */
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\python\\pytypemaps.swg" %beginfile
[build]   /* ------------------------------------------------------------
[build]    *  Typemap specializations for Python
[build]    * ------------------------------------------------------------ */
[build]   
[build]   /* ------------------------------------------------------------
[build]    *  Fragment section
[build]    * ------------------------------------------------------------ */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* Include fundamental fragment definitions */
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\typemaps\\fragments.swg" %beginfile
[build]   /*
[build]     Fragments
[build]     =========
[build]     See the "Typemap fragments" section in the documentation for understanding
[build]     fragments. Below is some info on how fragments and automatic type
[build]     specialization is used.
[build]   
[build]     Macros that make the automatic generation of typemaps easier are provided.
[build]   
[build]     Consider the following code:
[build]   
[build]         %fragment(SWIG_From_frag(bool), "header") {     
[build]         static PyObject*		      
[build]         SWIG_From_dec(bool)(bool value)	       
[build]         {					       
[build]           PyObject *obj = value ? Py_True : Py_False;  
[build]           Py_INCREF(obj);			       
[build]           return obj;				       
[build]         }					       
[build]         }					       
[build]         					 
[build]         %typemap(out, fragment=SWIG_From_frag(bool)) bool {
[build]           $result = SWIG_From(bool)($1));
[build]         }
[build]   
[build]     Here the macros
[build]   
[build]         SWIG_From_frag  => fragment 
[build]         SWIG_From_dec   => declaration 
[build]         SWIG_From       => call 
[build]         
[build]     allow you to define/include a fragment, and declare and call the
[build]     'from-bool' method as needed. In the simpler case, these macros 
[build]     just return something like
[build]   
[build]         SWIG_From_frag(bool)  => "SWIG_From_bool"
[build]         SWIG_From_dec(bool)   =>  SWIG_From_bool
[build]         SWIG_From(bool)       =>  SWIG_From_bool
[build]   
[build]     But they are specialized for the different languages requirements,
[build]     such as perl or tcl that requires passing the interpreter pointer,
[build]     and also they can manage C++ ugly types, for example:
[build]     
[build]         SWIG_From_frag(std::complex<double>)  => "SWIG_From_std_complex_Sl_double_Sg_"
[build]         SWIG_From_dec(std::complex<double>)   =>  SWIG_From_std_complex_Sl_double_Sg_
[build]         SWIG_From(std::complex<double>)       =>  SWIG_From_std_complex_Sl_double_Sg_
[build]   
[build]   
[build]     Hence, to declare methods to use with typemaps, always use the
[build]     SWIG_From* macros. In the same way, the SWIG_AsVal* and SWIG_AsPtr*
[build]     set of macros are provided.
[build]       
[build]   */
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * Define the basic macros to 'normalize' the type fragments
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------
[build]    * common fragments 
[build]    * ------------------------------------------------------------ */
[build]   
[build]   /* Default compiler options for gcc allow long_long but not LLONG_MAX. 
[build]    * Define SWIG_NO_LLONG_MAX if this added limits support is not wanted. */
[build]   %fragment("<limits.h>","header") %{
[build]   #include <limits.h>
[build]   #if !defined(SWIG_NO_LLONG_MAX)
[build]   # if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
[build]   #   define LLONG_MAX __LONG_LONG_MAX__
[build]   #   define LLONG_MIN (-LLONG_MAX - 1LL)
[build]   #   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
[build]   # endif
[build]   #endif
[build]   %}
[build]   
[build]   %fragment("<math.h>","header") %{
[build]   #include <math.h>
[build]   %}
[build]   
[build]   %fragment("<wchar.h>","header") %{
[build]   #include <wchar.h>
[build]   #include <limits.h>
[build]   #ifndef WCHAR_MIN
[build]   #  define WCHAR_MIN 0
[build]   #endif
[build]   #ifndef WCHAR_MAX
[build]   #  define WCHAR_MAX 65535
[build]   #endif
[build]   %}
[build]   
[build]   %fragment("<float.h>","header") %{
[build]   #include <float.h>
[build]   %}
[build]   
[build]   %fragment("<stdio.h>","header") %{
[build]   #include <stdio.h>
[build]   #if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
[build]   # ifndef snprintf
[build]   #  define snprintf _snprintf
[build]   # endif
[build]   #endif
[build]   %}
[build]   
[build]   %fragment("<stdlib.h>","header") %{
[build]   #include <stdlib.h>
[build]   #ifdef _MSC_VER
[build]   # ifndef strtoull
[build]   #  define strtoull _strtoui64
[build]   # endif
[build]   # ifndef strtoll
[build]   #  define strtoll _strtoi64
[build]   # endif
[build]   #endif
[build]   %}
[build]   
[build]   %fragment("<stddef.h>", "header") %{
[build]   #include <stddef.h>
[build]   %}
[build]   
[build]   %fragment("<string>", "header") %{
[build]   #include <string>
[build]   %}
[build]   
[build]   %fragment("<stdexcept>", "header") %{
[build]   #include <stdexcept>
[build]   %}
[build]   
[build]   %fragment("<algorithm>", "header") %{
[build]   #include <algorithm>
[build]   %}
[build]   
[build]   %fragment("SWIG_isfinite","header",fragment="<math.h>,<float.h>") %{
[build]   /* Getting isfinite working pre C99 across multiple platforms is non-trivial. Users can provide SWIG_isfinite on older platforms. */
[build]   #ifndef SWIG_isfinite
[build]   /* isfinite() is a macro for C99 */
[build]   # if defined(isfinite)
[build]   #  define SWIG_isfinite(X) (isfinite(X))
[build]   # elif defined __cplusplus && __cplusplus >= 201103L
[build]   /* Use a template so that this works whether isfinite() is std::isfinite() or
[build]    * in the global namespace.  The reality seems to vary between compiler
[build]    * versions.
[build]    *
[build]    * Make sure namespace std exists to avoid compiler warnings.
[build]    *
[build]    * extern "C++" is required as this fragment can end up inside an extern "C" { } block
[build]    */
[build]   namespace std { }
[build]   extern "C++" template<typename T>
[build]   inline int SWIG_isfinite_func(T x) {
[build]     using namespace std;
[build]     return isfinite(x);
[build]   }
[build]   #  define SWIG_isfinite(X) (SWIG_isfinite_func(X))
[build]   # elif defined(_MSC_VER)
[build]   #  define SWIG_isfinite(X) (_finite(X))
[build]   # elif defined(__sun) && defined(__SVR4)
[build]   #  include <ieeefp.h>
[build]   #  define SWIG_isfinite(X) (finite(X))
[build]   # endif
[build]   #endif
[build]   %}
[build]   
[build]   %fragment("SWIG_Float_Overflow_Check","header",fragment="<float.h>,SWIG_isfinite") %{
[build]   /* Accept infinite as a valid float value unless we are unable to check if a value is finite */
[build]   #ifdef SWIG_isfinite
[build]   # define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX) && SWIG_isfinite(X))
[build]   #else
[build]   # define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX))
[build]   #endif
[build]   %}
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * special macros for fragments
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   /* Macros to derive numeric types */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* Macro for 'signed long' derived types */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* Macro for 'unsigned long' derived types */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* Macro for floating point derived types (original macro) */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* Macro for floating point derived types */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* Macros for missing fragments */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   
[build]   /* Look for user fragments file. */
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\python\\pyfragments.swg" %beginfile
[build]   /*
[build]   
[build]     Create a file with this name, 'pyfragments.swg', in your working
[build]     directory and add all the %fragments you want to take precedence
[build]     over the default ones defined by swig.
[build]   
[build]     For example, if you add:
[build]     
[build]     %fragment(SWIG_AsVal_frag(int),"header") {
[build]      SWIGINTERNINLINE int
[build]      SWIG_AsVal(int)(PyObject *obj, int *val)
[build]      { 
[build]        <your code here>;
[build]      }
[build]     }
[build]     
[build]     this will replace the code used to retrieve an integer value for all
[build]     the typemaps that need it, including:
[build]     
[build]       int, std::vector<int>, std::list<std::pair<int,int> >, etc.
[build]   
[build]       
[build]   */
[build]   %endoffile
[build]   
[build]   /* Python fragments for fundamental types */
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\python\\pyprimtypes.swg" %beginfile
[build]   /* ------------------------------------------------------------
[build]    * Primitive Types
[build]    * ------------------------------------------------------------ */
[build]   
[build]   /* boolean */
[build]   
[build]   %fragment("SWIG_" "From" "_" {bool},"header") {
[build]   SWIGINTERNINLINE PyObject*
[build]     SWIG_From_bool  (bool value)
[build]   {
[build]     return PyBool_FromLong(value ? 1 : 0);
[build]   }
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %fragment("SWIG_" "AsVal" "_" {bool},"header",
[build]   	  fragment="SWIG_" "AsVal" "_" {long}) {
[build]   SWIGINTERN int
[build]   SWIG_AsVal_bool (PyObject *obj, bool *val)
[build]   {
[build]     int r;
[build]     if (!PyBool_Check(obj))
[build]       return SWIG_ERROR;
[build]     r = PyObject_IsTrue(obj);
[build]     if (r == -1)
[build]       return SWIG_ERROR;
[build]     if (val) *val = r ? true : false;
[build]     return SWIG_OK;
[build]   }
[build]   }
[build]   
[build]   
[build]   /* int */
[build]   
[build]   %fragment("SWIG_" "From" "_" {int},"header") {
[build]   SWIGINTERNINLINE PyObject*
[build]     SWIG_From_int  (int value)
[build]   {
[build]     return PyInt_FromLong((long) value);
[build]   }
[build]   }
[build]   
[build]   /* unsigned int */
[build]   
[build]   %fragment("SWIG_" "From" "_" {unsigned int},"header") {
[build]   SWIGINTERNINLINE PyObject*
[build]     SWIG_From_unsigned_SS_int  (unsigned int value)
[build]   {
[build]     return PyInt_FromSize_t((size_t) value);
[build]   }
[build]   }
[build]   
[build]   /* long */
[build]   
[build]   %fragment("SWIG_" "From" "_" {long},"header") {
[build]     #define SWIG_From_long   PyInt_FromLong 
[build]   }
[build]   
[build]   %fragment("SWIG_" "AsVal" "_" {long},"header",
[build]   	  fragment="SWIG_CanCastAsInteger") {
[build]   SWIGINTERN int
[build]   SWIG_AsVal_long (PyObject *obj, long* val)
[build]   {
[build]   #if PY_VERSION_HEX < 0x03000000
[build]     if (PyInt_Check(obj)) {
[build]       if (val) *val = PyInt_AsLong(obj);
[build]       return SWIG_OK;
[build]     } else
[build]   #endif
[build]     if (PyLong_Check(obj)) {
[build]       long v = PyLong_AsLong(obj);
[build]       if (!PyErr_Occurred()) {
[build]         if (val) *val = v;
[build]         return SWIG_OK;
[build]       } else {
[build]         PyErr_Clear();
[build]         return SWIG_OverflowError;
[build]       }
[build]     }
[build]   #ifdef SWIG_PYTHON_CAST_MODE
[build]     {
[build]       int dispatch = 0;
[build]       long v = PyInt_AsLong(obj);
[build]       if (!PyErr_Occurred()) {
[build]         if (val) *val = v;
[build]         return SWIG_AddCast(SWIG_OK);
[build]       } else {
[build]         PyErr_Clear();
[build]       }
[build]       if (!dispatch) {
[build]         double d;
[build]         int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
[build]         if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
[build]   	if (val) *val = (long)(d);
[build]   	return res;
[build]         }
[build]       }
[build]     }
[build]   #endif
[build]     return SWIG_TypeError;
[build]   }
[build]   }
[build]   
[build]   /* unsigned long */
[build]   
[build]   %fragment("SWIG_" "From" "_" {unsigned long},"header",
[build]   	  fragment="SWIG_" "From" "_" {long}) {
[build]   SWIGINTERNINLINE PyObject* 
[build]   SWIG_From_unsigned_SS_long  (unsigned long value)
[build]   {
[build]     return (value > LONG_MAX) ?
[build]       PyLong_FromUnsignedLong(value) : PyInt_FromLong((long)(value));
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "AsVal" "_" {unsigned long},"header",
[build]   	  fragment="SWIG_CanCastAsInteger") {
[build]   SWIGINTERN int
[build]   SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
[build]   {
[build]   #if PY_VERSION_HEX < 0x03000000
[build]     if (PyInt_Check(obj)) {
[build]       long v = PyInt_AsLong(obj);
[build]       if (v >= 0) {
[build]         if (val) *val = v;
[build]         return SWIG_OK;
[build]       } else {
[build]         return SWIG_OverflowError;
[build]       }
[build]     } else
[build]   #endif
[build]     if (PyLong_Check(obj)) {
[build]       unsigned long v = PyLong_AsUnsignedLong(obj);
[build]       if (!PyErr_Occurred()) {
[build]         if (val) *val = v;
[build]         return SWIG_OK;
[build]       } else {
[build]         PyErr_Clear();
[build]         return SWIG_OverflowError;
[build]       }
[build]     }
[build]   #ifdef SWIG_PYTHON_CAST_MODE
[build]     {
[build]       int dispatch = 0;
[build]       unsigned long v = PyLong_AsUnsignedLong(obj);
[build]       if (!PyErr_Occurred()) {
[build]         if (val) *val = v;
[build]         return SWIG_AddCast(SWIG_OK);
[build]       } else {
[build]         PyErr_Clear();
[build]       }
[build]       if (!dispatch) {
[build]         double d;
[build]         int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
[build]         if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
[build]   	if (val) *val = (unsigned long)(d);
[build]   	return res;
[build]         }
[build]       }
[build]     }
[build]   #endif
[build]     return SWIG_TypeError;
[build]   }
[build]   }
[build]   
[build]   /* long long */
[build]   
[build]   %fragment("SWIG_" "From" "_" {long long},"header",
[build]   	  fragment="SWIG_LongLongAvailable") {
[build]   #ifdef SWIG_LONG_LONG_AVAILABLE
[build]   SWIGINTERNINLINE PyObject* 
[build]   SWIG_From_long_SS_long  (long long value)
[build]   {
[build]     return ((value < LONG_MIN) || (value > LONG_MAX)) ?
[build]       PyLong_FromLongLong(value) : PyInt_FromLong((long)(value));
[build]   }
[build]   #endif
[build]   }
[build]   
[build]   %fragment("SWIG_" "AsVal" "_" {long long},"header",
[build]   	  fragment="SWIG_" "AsVal" "_" {long},
[build]   	  fragment="SWIG_CanCastAsInteger",
[build]   	  fragment="SWIG_LongLongAvailable") {
[build]   #ifdef SWIG_LONG_LONG_AVAILABLE
[build]   SWIGINTERN int
[build]   SWIG_AsVal_long_SS_long (PyObject *obj, long long *val)
[build]   {
[build]     int res = SWIG_TypeError;
[build]     if (PyLong_Check(obj)) {
[build]       long long v = PyLong_AsLongLong(obj);
[build]       if (!PyErr_Occurred()) {
[build]         if (val) *val = v;
[build]         return SWIG_OK;
[build]       } else {
[build]         PyErr_Clear();
[build]         res = SWIG_OverflowError;
[build]       }
[build]     } else {
[build]       long v;
[build]       res = SWIG_AsVal_long (obj,&v);
[build]       if (SWIG_IsOK(res)) {
[build]         if (val) *val = v;
[build]         return res;
[build]       }
[build]     }
[build]   #ifdef SWIG_PYTHON_CAST_MODE
[build]     {
[build]       const double mant_max = 1LL << DBL_MANT_DIG;
[build]       const double mant_min = -mant_max;
[build]       double d;
[build]       res = SWIG_AsVal_double (obj,&d);
[build]       if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, mant_min, mant_max))
[build]         return SWIG_OverflowError;
[build]       if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, mant_min, mant_max)) {
[build]         if (val) *val = (long long)(d);
[build]         return SWIG_AddCast(res);
[build]       }
[build]       res = SWIG_TypeError;
[build]     }
[build]   #endif
[build]     return res;
[build]   }
[build]   #endif
[build]   }
[build]   
[build]   /* unsigned long long */
[build]   
[build]   %fragment("SWIG_" "From" "_" {unsigned long long},"header",
[build]   	  fragment="SWIG_LongLongAvailable") {
[build]   #ifdef SWIG_LONG_LONG_AVAILABLE
[build]   SWIGINTERNINLINE PyObject* 
[build]   SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
[build]   {
[build]     return (value > LONG_MAX) ?
[build]       PyLong_FromUnsignedLongLong(value) : PyInt_FromLong((long)(value));
[build]   }
[build]   #endif
[build]   }
[build]   
[build]   %fragment("SWIG_" "AsVal" "_" {unsigned long long},"header",
[build]   	  fragment="SWIG_" "AsVal" "_" {unsigned long},
[build]   	  fragment="SWIG_CanCastAsInteger",
[build]   	  fragment="SWIG_LongLongAvailable") {
[build]   #ifdef SWIG_LONG_LONG_AVAILABLE
[build]   SWIGINTERN int
[build]   SWIG_AsVal_unsigned_SS_long_SS_long (PyObject *obj, unsigned long long *val)
[build]   {
[build]     int res = SWIG_TypeError;
[build]     if (PyLong_Check(obj)) {
[build]       unsigned long long v = PyLong_AsUnsignedLongLong(obj);
[build]       if (!PyErr_Occurred()) {
[build]         if (val) *val = v;
[build]         return SWIG_OK;
[build]       } else {
[build]         PyErr_Clear();
[build]         res = SWIG_OverflowError;
[build]       }
[build]     } else {
[build]       unsigned long v;
[build]       res = SWIG_AsVal_unsigned_SS_long (obj,&v);
[build]       if (SWIG_IsOK(res)) {
[build]         if (val) *val = v;
[build]         return res;
[build]       }
[build]     }
[build]   #ifdef SWIG_PYTHON_CAST_MODE
[build]     {
[build]       const double mant_max = 1LL << DBL_MANT_DIG;
[build]       double d;
[build]       res = SWIG_AsVal_double (obj,&d);
[build]       if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, 0, mant_max))
[build]         return SWIG_OverflowError;
[build]       if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, mant_max)) {
[build]         if (val) *val = (unsigned long long)(d);
[build]         return SWIG_AddCast(res);
[build]       }
[build]       res = SWIG_TypeError;
[build]     }
[build]   #endif
[build]     return res;
[build]   }
[build]   #endif
[build]   }
[build]   
[build]   /* double */
[build]   
[build]   %fragment("SWIG_" "From" "_" {double},"header") {
[build]     #define SWIG_From_double   PyFloat_FromDouble 
[build]   }
[build]   
[build]   %fragment("SWIG_" "AsVal" "_" {double},"header") {
[build]   SWIGINTERN int
[build]   SWIG_AsVal_double (PyObject *obj, double *val)
[build]   {
[build]     int res = SWIG_TypeError;
[build]     if (PyFloat_Check(obj)) {
[build]       if (val) *val = PyFloat_AsDouble(obj);
[build]       return SWIG_OK;
[build]   #if PY_VERSION_HEX < 0x03000000
[build]     } else if (PyInt_Check(obj)) {
[build]       if (val) *val = (double) PyInt_AsLong(obj);
[build]       return SWIG_OK;
[build]   #endif
[build]     } else if (PyLong_Check(obj)) {
[build]       double v = PyLong_AsDouble(obj);
[build]       if (!PyErr_Occurred()) {
[build]         if (val) *val = v;
[build]         return SWIG_OK;
[build]       } else {
[build]         PyErr_Clear();
[build]       }
[build]     }
[build]   #ifdef SWIG_PYTHON_CAST_MODE
[build]     {
[build]       int dispatch = 0;
[build]       double d = PyFloat_AsDouble(obj);
[build]       if (!PyErr_Occurred()) {
[build]         if (val) *val = d;
[build]         return SWIG_AddCast(SWIG_OK);
[build]       } else {
[build]         PyErr_Clear();
[build]       }
[build]       if (!dispatch) {
[build]         long v = PyLong_AsLong(obj);
[build]         if (!PyErr_Occurred()) {
[build]   	if (val) *val = v;
[build]   	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
[build]         } else {
[build]   	PyErr_Clear();
[build]         }
[build]       }
[build]     }
[build]   #endif
[build]     return res;
[build]   }
[build]   }
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   
[build]   /* Python fragments for char* strings */
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\python\\pystrings.swg" %beginfile
[build]   /* ------------------------------------------------------------
[build]    *  utility methods for char strings 
[build]    * ------------------------------------------------------------ */
[build]   %fragment("SWIG_AsCharPtrAndSize","header",fragment="SWIG_pchar_descriptor") {
[build]   SWIGINTERN int
[build]   SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
[build]   {
[build]   #if PY_VERSION_HEX>=0x03000000
[build]   #if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
[build]     if (PyBytes_Check(obj))
[build]   #else
[build]     if (PyUnicode_Check(obj))
[build]   #endif
[build]   #else  
[build]     if (PyString_Check(obj))
[build]   #endif
[build]     {
[build]       char *cstr; Py_ssize_t len;
[build]   #if PY_VERSION_HEX>=0x03000000
[build]   #if !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
[build]       if (!alloc && cptr) {
[build]           /* We can't allow converting without allocation, since the internal
[build]              representation of string in Python 3 is UCS-2/UCS-4 but we require
[build]              a UTF-8 representation.
[build]              TODO(bhy) More detailed explanation */
[build]           return SWIG_RuntimeError;
[build]       }
[build]       obj = PyUnicode_AsUTF8String(obj);
[build]       if(alloc) *alloc = SWIG_NEWOBJ;
[build]   #endif
[build]       PyBytes_AsStringAndSize(obj, &cstr, &len);
[build]   #else
[build]       PyString_AsStringAndSize(obj, &cstr, &len);
[build]   #endif
[build]       if (cptr) {
[build]         if (alloc) {
[build]   	/* 
[build]   	   In python the user should not be able to modify the inner
[build]   	   string representation. To warranty that, if you define
[build]   	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
[build]   	   buffer is always returned.
[build]   
[build]   	   The default behavior is just to return the pointer value,
[build]   	   so, be careful.
[build]   	*/ 
[build]   #if defined(SWIG_PYTHON_SAFE_CSTRINGS)
[build]   	if (*alloc != SWIG_OLDOBJ) 
[build]   #else
[build]   	if (*alloc == SWIG_NEWOBJ) 
[build]   #endif
[build]   	{
[build]   	  *cptr = (char *)memcpy(malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
[build]   	  *alloc = SWIG_NEWOBJ;
[build]   	} else {
[build]   	  *cptr = cstr;
[build]   	  *alloc = SWIG_OLDOBJ;
[build]   	}
[build]         } else {
[build]   #if PY_VERSION_HEX>=0x03000000
[build]   #if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
[build]   	*cptr = PyBytes_AsString(obj);
[build]   #else
[build]   	assert(0); /* Should never reach here with Unicode strings in Python 3 */
[build]   #endif
[build]   #else
[build]   	*cptr = SWIG_Python_str_AsChar(obj);
[build]   #endif
[build]         }
[build]       }
[build]       if (psize) *psize = len + 1;
[build]   #if PY_VERSION_HEX>=0x03000000 && !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
[build]       Py_XDECREF(obj);
[build]   #endif
[build]       return SWIG_OK;
[build]     } else {
[build]   #if defined(SWIG_PYTHON_2_UNICODE)
[build]   #if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
[build]   #error "Cannot use both SWIG_PYTHON_2_UNICODE and SWIG_PYTHON_STRICT_BYTE_CHAR at once"
[build]   #endif
[build]   #if PY_VERSION_HEX<0x03000000
[build]       if (PyUnicode_Check(obj)) {
[build]         char *cstr; Py_ssize_t len;
[build]         if (!alloc && cptr) {
[build]           return SWIG_RuntimeError;
[build]         }
[build]         obj = PyUnicode_AsUTF8String(obj);
[build]         if (PyString_AsStringAndSize(obj, &cstr, &len) != -1) {
[build]           if (cptr) {
[build]             if (alloc) *alloc = SWIG_NEWOBJ;
[build]             *cptr = (char *)memcpy(malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
[build]           }
[build]           if (psize) *psize = len + 1;
[build]   
[build]           Py_XDECREF(obj);
[build]           return SWIG_OK;
[build]         } else {
[build]           Py_XDECREF(obj);
[build]         }
[build]       }
[build]   #endif
[build]   #endif
[build]   
[build]       swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
[build]       if (pchar_descriptor) {
[build]         void* vptr = 0;
[build]         if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
[build]   	if (cptr) *cptr = (char *) vptr;
[build]   	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
[build]   	if (alloc) *alloc = SWIG_OLDOBJ;
[build]   	return SWIG_OK;
[build]         }
[build]       }
[build]     }
[build]     return SWIG_TypeError;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_FromCharPtrAndSize","header",fragment="SWIG_pchar_descriptor") {
[build]   SWIGINTERNINLINE PyObject *
[build]   SWIG_FromCharPtrAndSize(const char* carray, size_t size)
[build]   {
[build]     if (carray) {
[build]       if (size > INT_MAX) {
[build]         swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
[build]         return pchar_descriptor ? 
[build]   	SWIG_InternalNewPointerObj((char *)(carray), pchar_descriptor, 0) : SWIG_Py_Void();
[build]       } else {
[build]   #if PY_VERSION_HEX >= 0x03000000
[build]   #if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
[build]         return PyBytes_FromStringAndSize(carray, (Py_ssize_t)(size));
[build]   #else
[build]   #if PY_VERSION_HEX >= 0x03010000
[build]         return PyUnicode_DecodeUTF8(carray, (Py_ssize_t)(size), "surrogateescape");
[build]   #else
[build]         return PyUnicode_FromStringAndSize(carray, (Py_ssize_t)(size));
[build]   #endif
[build]   #endif
[build]   #else
[build]         return PyString_FromStringAndSize(carray, (Py_ssize_t)(size));
[build]   #endif
[build]       }
[build]     } else {
[build]       return SWIG_Py_Void();
[build]     }
[build]   }
[build]   }
[build]   
[build]   %endoffile
[build]   
[build]   /* Backward compatibility output helper */
[build]   %fragment("t_output_helper","header") %{
[build]   #define t_output_helper SWIG_Python_AppendOutput
[build]   %}
[build]   
[build]   
[build]   /* ------------------------------------------------------------
[build]    *  Unified typemap section
[build]    * ------------------------------------------------------------ */
[build]   
[build]   /* directors are supported in Python */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* Python types */
[build]   
[build]   
[build]   
[build]   /* Python allows implicit conversion */
[build]   
[build]   
[build]   
[build]   /* Overload of the output/constant/exception/dirout handling */
[build]   
[build]   /* append output */
[build]   
[build]   
[build]   /* set constant */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* raise */
[build]   
[build]   
[build]   /* Include the unified typemap library */
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\typemaps\\swigtypemaps.swg" %beginfile
[build]   /* -----------------------------------------------------------------------------
[build]    * swigtypemaps.swg
[build]    *
[build]    * Unified Typemap Library frontend
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   /*
[build]     This file provides the frontend to the Unified Typemap Library.
[build]   
[build]     When using this library in a SWIG target language, you need to
[build]     define a minimum set of fragments, specialize a couple of macros,
[build]     and then include this file.
[build]   
[build]     Typically you will create a 'mytypemaps.swg' file in each target
[build]     language, where you will have the following sections:
[build]   
[build]       === mytypemaps.swg ===
[build]   
[build]       //  Fragment section 
[build]       %include <typemaps/fragments.swg>
[build]       <include target language fragments>
[build]   
[build]       // Unified typemap section 
[build]       <specialized the typemap library macros>
[build]       %include <typemaps/swigtypemaps.swg>
[build]   
[build]       // Local typemap section 
[build]       <add/replace extra target language typemaps>
[build]   
[build]       === mytypemaps.swg ===
[build]   
[build]     While we add more docs, please take a look at the following cases
[build]     to see how you specialized the unified typemap library for a new
[build]     target language:
[build]   
[build]         Lib/python/pytypemaps.swg
[build]         Lib/tcl/tcltypemaps.swg
[build]         Lib/ruby/rubytypemaps.swg
[build]         Lib/perl5/perltypemaps.swg
[build]       
[build]   */
[build]   
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    *   Language specialization section. 
[build]    *
[build]    *   Tune these macros for each language as needed.
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   /*
[build]     The SWIG target language object must be provided.
[build]     For example in python you define:
[build]   
[build]       #define SWIG_Object PyObject *
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*==== flags for new/convert methods ====*/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*==== set output ====*/
[build]   
[build]   
[build]   /* simple set output operation */
[build]   
[build]   
[build]   
[build]   /*==== set variable output  ====*/
[build]   
[build]   
[build]   /* simple set varoutput operation */
[build]   
[build]   
[build]   
[build]   /*==== append output ====*/
[build]   
[build]   
[build]   
[build]   /* simple append operation */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*==== set constant ====*/
[build]   
[build]   
[build]   
[build]   /* simple set constant operation */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*==== raise an exception ====*/
[build]   
[build]   
[build]   
[build]   /* simple raise operation */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*==== director output exception ====*/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    *  Language independent definitions
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    *  All the typemaps
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\typemaps\\exception.swg" %beginfile
[build]   /* -----------------------------------------------------------------------------
[build]    * exceptions.swg
[build]    *
[build]    * This SWIG library file provides language independent exception handling
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   
[build]   /* macros for error manipulation */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* setting an error */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %insert("runtime") {
[build]   
[build]   #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
[build]   
[build]   #define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
[build]   
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\typemaps\\swigtype.swg" %beginfile
[build]   /* -----------------------------------------------------------------------------
[build]    * --- Input arguments --- 
[build]    * ----------------------------------------------------------------------------- */
[build]   /* Pointers and arrays */
[build]   %typemap(in, noblock=1) SWIGTYPE *(void  *argp = 0, int res = 0) {
[build]     res = SWIG_ConvertPtr($input, &argp,$descriptor, $disown |  0 );
[build]     if (!SWIG_IsOK(res)) { 
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
[build]     }
[build]     $1 = ($ltype)(argp);
[build]   }
[build]   %typemap(freearg) SWIGTYPE * "";
[build]   
[build]   %typemap(in, noblock=1) SWIGTYPE [] (void *argp = 0, int res = 0) {
[build]     res = SWIG_ConvertPtr($input, &argp,$descriptor, $disown |  0 );
[build]     if (!SWIG_IsOK(res)) { 
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
[build]     } 
[build]     $1 = ($ltype)(argp);
[build]   }
[build]   %typemap(freearg) SWIGTYPE [] "";
[build]   
[build]   
[build]   %typemap(in, noblock=1) SWIGTYPE *const&  (void *argp = 0, int res = 0, $*1_ltype temp) {
[build]     res = SWIG_ConvertPtr($input, &argp, $*descriptor, $disown |  0 );
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'"); 
[build]     }
[build]     temp = ($*ltype)(argp);
[build]     $1 = ($1_ltype)(&temp);
[build]   }
[build]   %typemap(freearg) SWIGTYPE *const& "";
[build]   
[build]   
[build]   /* Reference */
[build]   %typemap(in, noblock=1) SWIGTYPE & (void *argp = 0, int res = 0) {
[build]     res = SWIG_ConvertPtr($input, &argp, $descriptor,  0 );
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
[build]     }
[build]     if (!argp) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
[build]     $1 = ($ltype)(argp);
[build]   }
[build]   %typemap(freearg) SWIGTYPE & "";
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %typemap(in,noblock=1) const SWIGTYPE & (void *argp, int res = 0) {
[build]     res = SWIG_ConvertPtr($input, &argp, $descriptor,  0 );
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
[build]     }
[build]     if (!argp) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
[build]     $1 = ($ltype)(argp);
[build]   }
[build]   
[build]   
[build]   /* Rvalue reference */
[build]   %typemap(in, noblock=1) SWIGTYPE && (void *argp = 0, int res = 0) {
[build]     res = SWIG_ConvertPtr($input, &argp, $descriptor,  0 );
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
[build]     }
[build]     if (!argp) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
[build]     $1 = ($ltype)(argp);
[build]   }
[build]   %typemap(freearg) SWIGTYPE && "";
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %typemap(in,noblock=1) const SWIGTYPE && (void *argp, int res = 0) {
[build]     res = SWIG_ConvertPtr($input, &argp, $descriptor,  0 );
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
[build]     }
[build]     if (!argp) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
[build]     $1 = ($ltype)(argp);
[build]   }
[build]   
[build]   
[build]   /* By value */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %typemap(in) SWIGTYPE (void *argp, int res = 0) {
[build]     res = SWIG_ConvertPtr($input, &argp, $&descriptor,  0 );
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
[build]     }  
[build]     if (!argp) { 
[build]       SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
[build]     } else {
[build]       $1 = *(($&ltype)(argp));
[build]     }
[build]   }
[build]   
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * --- Output arguments --- 
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   /* Pointers, references */
[build]   %typemap(out,noblock=1) SWIGTYPE *, SWIGTYPE &, SWIGTYPE &&, SWIGTYPE[] {
[build]     $result = SWIG_NewPointerObj(SWIG_as_voidptr($1), $descriptor, $owner |  0 );
[build]   }
[build]   
[build]   %typemap(out, noblock=1) SWIGTYPE *const& {
[build]     $result = SWIG_NewPointerObj(SWIG_as_voidptr(*$1), $*descriptor, $owner |  0 );
[build]   }
[build]   
[build]   /* Return by value */
[build]   %typemap(out, noblock=1) SWIGTYPE {
[build]     $result = SWIG_NewPointerObj(($ltype *)memcpy(($ltype *)calloc(1,sizeof($ltype)),&$1,sizeof($ltype)), $&descriptor, SWIG_POINTER_OWN |  0 );
[build]   }
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * --- Variable input --- 
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   /* memberin/globalin/varin, for fix arrays. */
[build]   
[build]   %typemap(memberin) SWIGTYPE [ANY] {
[build]     if ($input) {
[build]       size_t ii = 0;
[build]       for (; ii < (size_t)$1_dim0; ++ii) *($1_basetype *)&$1[ii] = *(($1_basetype *)$input + ii);
[build]     } else {
[build]       SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
[build]     }
[build]   }
[build]   
[build]   %typemap(globalin) SWIGTYPE [ANY] {
[build]     if ($input) {
[build]       size_t ii = 0;
[build]       for (; ii < (size_t)$1_dim0; ++ii) *($1_basetype *)&$1[ii] = *(($1_basetype *)$input + ii);
[build]     } else {
[build]       SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
[build]     }
[build]   }
[build]   
[build]   %typemap(varin) SWIGTYPE [ANY] {
[build]     $basetype *inp = 0;
[build]     int res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&inp), $descriptor,  0 );
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]     } else if (inp) {
[build]       size_t ii = 0;
[build]       for (; ii < (size_t)$1_dim0; ++ii) *($1_basetype *)&$1[ii] = *(($1_basetype *)inp + ii);
[build]     } else {
[build]       SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
[build]     }
[build]   }
[build]   
[build]   
[build]   /* memberin/globalin/varin, for fix double arrays. */
[build]   
[build]   %typemap(memberin) SWIGTYPE [ANY][ANY] {
[build]     if ($input) {
[build]       size_t ii = 0;
[build]       for (; ii < (size_t)$1_dim0; ++ii) {
[build]         if ($input[ii]) {
[build]   	size_t jj = 0;
[build]   	for (; jj < (size_t)$1_dim1; ++jj) $1[ii][jj] = $input[ii][jj];
[build]         } else {
[build]   	SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
[build]         }
[build]       }
[build]     } else {
[build]       SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
[build]     }
[build]   }
[build]   
[build]   %typemap(globalin) SWIGTYPE [ANY][ANY] {
[build]     if ($input) {
[build]       size_t ii = 0;
[build]       for (; ii < (size_t)$1_dim0; ++ii) {
[build]         if ($input[ii]) {
[build]   	size_t jj = 0;
[build]   	for (; jj < (size_t)$1_dim1; ++jj) $1[ii][jj] = $input[ii][jj];
[build]         } else {
[build]   	SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
[build]         }
[build]       }
[build]     } else {
[build]       SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
[build]     }
[build]   }
[build]   
[build]   %typemap(varin) SWIGTYPE [ANY][ANY] {
[build]     $basetype (*inp)[$1_dim1] = 0;
[build]     int res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&inp), $descriptor,  0 );
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]     } else if (inp) {
[build]       size_t ii = 0;
[build]       for (; ii < (size_t)$1_dim0; ++ii) {
[build]         if (inp[ii]) {
[build]   	size_t jj = 0;
[build]   	for (; jj < (size_t)$1_dim1; ++jj) $1[ii][jj] = inp[ii][jj];
[build]         } else {
[build]   	SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
[build]         }
[build]       }
[build]     } else {
[build]       SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
[build]     }
[build]   }
[build]   
[build]   /* Pointers, references, and variable size arrays */
[build]   
[build]   %typemap(varin,warning=    "454:Setting a pointer/reference variable may leak memory." ) SWIGTYPE * {
[build]     void *argp = 0;
[build]     int res = SWIG_ConvertPtr($input, &argp, $descriptor,  0 );  
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]     }
[build]     $1 = ($ltype)(argp);
[build]   }
[build]   
[build]   %typemap(varin,noblock=1,warning="462:Unable to set dimensionless array variable") SWIGTYPE []
[build]   {
[build]     SWIG_exception_fail(SWIG_ArgError(SWIG_AttributeError), "in variable '""read-only $name""' of type '""$type""'");
[build]   }
[build]   
[build]   %typemap(varin,warning=    "454:Setting a pointer/reference variable may leak memory." ) SWIGTYPE & {
[build]     void *argp = 0;
[build]     int res = SWIG_ConvertPtr($input, &argp, $descriptor,  0 );
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]     }
[build]     if (!argp) {
[build]       SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
[build]     }
[build]     $1 = *(($ltype)(argp));
[build]   }
[build]   
[build]   %typemap(varin,warning=    "454:Setting a pointer/reference variable may leak memory." ) SWIGTYPE && {
[build]     void *argp = 0;
[build]     int res = SWIG_ConvertPtr($input, &argp, $descriptor,  0 );
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]     }
[build]     if (!argp) {
[build]       SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
[build]     }
[build]     $1 = *(($ltype)(argp));
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %typemap(varin) SWIGTYPE {
[build]     void *argp = 0;
[build]     int res = SWIG_ConvertPtr($input, &argp, $&descriptor,  0 );
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]     }
[build]     if (!argp) {
[build]       SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
[build]     } else {
[build]       $1 = *(($&type)(argp));
[build]     }
[build]   }
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * --- Variable output --- 
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   /* Pointers and arrays */
[build]   %typemap(varout, noblock=1) SWIGTYPE * {
[build]     $result = SWIG_NewPointerObj(SWIG_as_voidptr($1), $descriptor,  0 );
[build]   }
[build]   
[build]   %typemap(varout, noblock=1) SWIGTYPE [] {
[build]     $result = SWIG_NewPointerObj(SWIG_as_voidptr($1), $descriptor,  0 );
[build]   }
[build]   
[build]   /* References */
[build]   %typemap(varout, noblock=1) SWIGTYPE & {
[build]     $result = SWIG_NewPointerObj(SWIG_as_voidptr(&$1), $descriptor,  0 );
[build]   }
[build]   
[build]   %typemap(varout, noblock=1) SWIGTYPE && {
[build]     $result = SWIG_NewPointerObj(SWIG_as_voidptr(&$1), $descriptor,  0 );
[build]   }
[build]   
[build]   /* Value */
[build]   %typemap(varout, noblock=1) SWIGTYPE {
[build]     $result = SWIG_NewPointerObj(SWIG_as_voidptr(&$1), $&descriptor,  0 );
[build]   }
[build]   
[build]   /* ------------------------------------------------------------
[build]    * --- Typechecking rules ---
[build]    * ------------------------------------------------------------ */
[build]   
[build]   %typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE * {
[build]     void *vptr = 0;
[build]     int res = SWIG_ConvertPtr($input, &vptr, $descriptor, 0);
[build]     $1 = SWIG_CheckState(res);
[build]   }
[build]   
[build]   %typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE *const& {
[build]     void *vptr = 0;
[build]     int res = SWIG_ConvertPtr($input, &vptr, $*descriptor, 0);
[build]     $1 = SWIG_CheckState(res);
[build]   }
[build]   
[build]   %typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE & {
[build]     void *vptr = 0;
[build]     int res = SWIG_ConvertPtr($input, &vptr, $descriptor, 0);
[build]     $1 = SWIG_CheckState(res);
[build]   }
[build]   
[build]   %typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE && {
[build]     void *vptr = 0;
[build]     int res = SWIG_ConvertPtr($input, &vptr, $descriptor, 0);
[build]     $1 = SWIG_CheckState(res);
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %typemap(typecheck,precedence=      0     ,noblock=1) const SWIGTYPE & {
[build]     void *vptr = 0;
[build]     int res = SWIG_ConvertPtr($input, &vptr, $descriptor, 0);
[build]     $1 = SWIG_CheckState(res);
[build]   }
[build]   %typemap(typecheck,precedence=      0     ,noblock=1) const SWIGTYPE && {
[build]     void *vptr = 0;
[build]     int res = SWIG_ConvertPtr($input, &vptr, $descriptor, 0);
[build]     $1 = SWIG_CheckState(res);
[build]   }
[build]   
[build]   %typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE {
[build]     void *vptr = 0;
[build]     int res = SWIG_ConvertPtr($input, &vptr, $&descriptor, 0);
[build]     $1 = SWIG_CheckState(res);
[build]   }
[build]   
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * --- Director typemaps --- *  
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   /* directorin */
[build]   
[build]   %typemap(directorin,noblock=1) SWIGTYPE *, SWIGTYPE *const& {
[build]     $input = SWIG_NewPointerObj(SWIG_as_voidptr($1), $descriptor,  0 );
[build]   }
[build]   
[build]   %typemap(directorin,noblock=1) SWIGTYPE {
[build]     $input = SWIG_NewPointerObj(SWIG_as_voidptr(new $1_ltype((const $1_ltype &)$1)), $&descriptor, SWIG_POINTER_OWN |  0 );
[build]   }
[build]   
[build]   %typemap(directorin,noblock=1) SWIGTYPE & {
[build]     $input = SWIG_NewPointerObj(SWIG_as_voidptr(&$1), $descriptor,  0 );
[build]   }
[build]   
[build]   %typemap(directorin,noblock=1) SWIGTYPE && {
[build]     $input = SWIG_NewPointerObj(SWIG_as_voidptr(&$1_name), $descriptor,  0 );
[build]   }
[build]   
[build]   /* directorout */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %typemap(directorout,noblock=1) SWIGTYPE (void * swig_argp, int swig_res = 0) {
[build]     swig_res = SWIG_ConvertPtr($input,&swig_argp,$&descriptor,  0 );
[build]     if (!SWIG_IsOK(swig_res)) {
[build]       Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]     }
[build]     $result = *(($&ltype)(swig_argp));
[build]   }
[build]   
[build]   
[build]   %typemap(directorout,noblock=1,warning= "473:Returning a pointer or reference in a director method is not recommended." ) 
[build]     SWIGTYPE *(void *swig_argp, int swig_res, swig_owntype own) {
[build]     swig_res = SWIG_ConvertPtrAndOwn($input, &swig_argp, $descriptor,  0  | SWIG_POINTER_DISOWN, &own);
[build]     if (!SWIG_IsOK(swig_res)) {
[build]       Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]     }
[build]     $result = ($ltype)(swig_argp);
[build]     swig_acquire_ownership_obj(SWIG_as_voidptr($result), own /* & TODO: SWIG_POINTER_OWN */);
[build]   }
[build]   %typemap(directorfree,noblock=1,match="directorout") SWIGTYPE * {
[build]     if (director) {
[build]       SWIG_AcquirePtr($result, director->swig_release_ownership(SWIG_as_voidptr($input)));
[build]     }
[build]   }
[build]   
[build]   %typemap(directorout,noblock=1,warning= "473:Returning a pointer or reference in a director method is not recommended." ) 
[build]     SWIGTYPE &(void *swig_argp, int swig_res, swig_owntype own) {
[build]     swig_res = SWIG_ConvertPtrAndOwn($input, &swig_argp, $descriptor,  0  | SWIG_POINTER_DISOWN, &own);
[build]     if (!SWIG_IsOK(swig_res)) {
[build]       Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]     }
[build]     if (!swig_argp) { Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ValueError), "invalid null reference " "in output value of type '""$type""'"); }
[build]     $result = ($ltype)(swig_argp);
[build]     swig_acquire_ownership_obj(SWIG_as_voidptr($result), own /* & TODO: SWIG_POINTER_OWN */);
[build]   }
[build]   %typemap(directorfree,noblock=1,match="directorout") SWIGTYPE & {
[build]     if (director) {
[build]       SWIG_AcquirePtr($result, director->swig_release_ownership(SWIG_as_voidptr($input)));
[build]     }
[build]   }
[build]   
[build]   %typemap(directorout,noblock=1,warning= "473:Returning a pointer or reference in a director method is not recommended." ) 
[build]     SWIGTYPE &&(void *swig_argp, int swig_res, swig_owntype own) {
[build]     swig_res = SWIG_ConvertPtrAndOwn($input, &swig_argp, $descriptor,  0  | SWIG_POINTER_DISOWN, &own);
[build]     if (!SWIG_IsOK(swig_res)) {
[build]       Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]     }
[build]     if (!swig_argp) { Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ValueError), "invalid null reference " "in output value of type '""$type""'"); }
[build]     $result = ($ltype)(swig_argp);
[build]     swig_acquire_ownership_obj(SWIG_as_voidptr($result), own /* & TODO: SWIG_POINTER_OWN */);
[build]   }
[build]   %typemap(directorfree,noblock=1,match="directorout") SWIGTYPE && {
[build]     if (director) {
[build]       SWIG_AcquirePtr($result, director->swig_release_ownership(SWIG_as_voidptr($input)));
[build]     }
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------
[build]    * --- Constants ---
[build]    * ------------------------------------------------------------ */
[build]   
[build]   %typemap(constcode,noblock=1) SWIGTYPE *, SWIGTYPE &, SWIGTYPE &&, SWIGTYPE [] {
[build]     SWIG_Python_SetConstant(d, "$symname",SWIG_NewPointerObj(SWIG_as_voidptr($value),$descriptor, 0 ));
[build]   }
[build]   
[build]   %typemap(constcode,noblock=1) SWIGTYPE {
[build]     SWIG_Python_SetConstant(d, "$symname",SWIG_NewPointerObj(SWIG_as_voidptr(&$value),$&descriptor, 0 ));
[build]   }
[build]   
[build]   /* ------------------------------------------------------------
[build]    * --- Exception handling ---
[build]    * ------------------------------------------------------------ */
[build]   
[build]   %typemap(throws,noblock=1) SWIGTYPE {
[build]     SWIG_Python_Raise(SWIG_NewPointerObj(($ltype *)memcpy(($ltype *)calloc(1,sizeof($ltype)),&$1,sizeof($ltype)),$&descriptor,SWIG_POINTER_OWN), "$type", $&descriptor); SWIG_fail;
[build]   }
[build]   
[build]   %typemap(throws,noblock=1) SWIGTYPE * {
[build]     SWIG_Python_Raise(SWIG_NewPointerObj(SWIG_as_voidptr($1),$descriptor,0), "$type", $descriptor); SWIG_fail;
[build]   }
[build]   
[build]   %typemap(throws,noblock=1) SWIGTYPE [ANY] {
[build]     SWIG_Python_Raise(SWIG_NewPointerObj(SWIG_as_voidptr($1),$descriptor,0), "$type", $descriptor); SWIG_fail;
[build]   }
[build]   
[build]   %typemap(throws,noblock=1) SWIGTYPE & {
[build]     SWIG_Python_Raise(SWIG_NewPointerObj(SWIG_as_voidptr(&$1),$descriptor,0), "$type", $descriptor); SWIG_fail;
[build]   }
[build]   
[build]   %typemap(throws,noblock=1) SWIGTYPE && {
[build]     SWIG_Python_Raise(SWIG_NewPointerObj(SWIG_as_voidptr(&$1),$descriptor,0), "$type", $descriptor); SWIG_fail;
[build]   }
[build]   
[build]   %typemap(throws,noblock=1) (...) {
[build]     SWIG_exception_fail(SWIG_RuntimeError,"unknown exception");
[build]   }
[build]   
[build]   /* ------------------------------------------------------------
[build]    * --- CLASS::* typemaps --- 
[build]    * ------------------------------------------------------------ */
[build]   
[build]   %typemap(in) SWIGTYPE (CLASS::*) {  
[build]     int res = SWIG_ConvertMember($input, SWIG_as_voidptr(&$1), sizeof($type),$descriptor);
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
[build]     }
[build]   }
[build]   
[build]   %typemap(out,noblock=1) SWIGTYPE (CLASS::*) {
[build]     $result = SWIG_NewMemberObj(SWIG_as_voidptr(&$1), sizeof($type), $descriptor);
[build]   }
[build]   
[build]   %typemap(varin) SWIGTYPE (CLASS::*) {
[build]     int res = SWIG_ConvertMember($input,SWIG_as_voidptr(&$1), sizeof($type), $descriptor);
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'"); 
[build]     }
[build]   }
[build]   
[build]   %typemap(varout,noblock=1) SWIGTYPE (CLASS::*) {
[build]     $result = SWIG_NewMemberObj(SWIG_as_voidptr(&$1), sizeof($type), $descriptor);
[build]   }
[build]   
[build]   %typemap(constcode,noblock=1) SWIGTYPE (CLASS::*) {
[build]     SWIG_Python_SetConstant(d, "$symname",SWIG_NewMemberObj(SWIG_as_voidptr(&$value), sizeof($type), $descriptor));
[build]   }
[build]   
[build]   
[build]   
[build]   /* directorin */
[build]   
[build]   %typemap(directorin,noblock=1) SWIGTYPE (CLASS::*) {
[build]     $input = SWIG_NewMemberObj(SWIG_as_voidptr(&$1), sizeof($type), $descriptor);
[build]   }
[build]   
[build]   /* directorout */
[build]   
[build]   %typemap(directorout) SWIGTYPE (CLASS::*) {
[build]     int swig_res = SWIG_ConvertMember($input,SWIG_as_voidptr(&$result), sizeof($type), $descriptor);
[build]     if (!SWIG_IsOK(swig_res)) {
[build]       Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]     }
[build]   }
[build]   
[build]   
[build]   /* ------------------------------------------------------------
[build]    * --- function ptr typemaps --- 
[build]    * ------------------------------------------------------------ */
[build]   
[build]   /*
[build]     ISO C++ doesn't allow direct casting of a function ptr to a object
[build]     ptr. So, maybe the ptr sizes are not the same, and we need to take
[build]     some providences.
[build]    */
[build]   %typemap(in) SWIGTYPE ((*)(ANY)) {
[build]     int res = SWIG_ConvertFunctionPtr($input, (void**)(&$1), $descriptor);
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
[build]     }
[build]   }
[build]   
[build]    %typemap(typecheck, precedence=      0     ,noblock=1)  SWIGTYPE ((*)(ANY)) {
[build]     void *ptr = 0;
[build]     int res = SWIG_ConvertFunctionPtr($input, &ptr, $descriptor);
[build]     $1 = SWIG_CheckState(res);
[build]   }
[build]   
[build]   
[build]   %typemap(out, noblock=1) SWIGTYPE ((*)(ANY)) {
[build]     $result = SWIG_NewFunctionPtrObj((void *)($1), $descriptor);
[build]   }
[build]   
[build]   %typemap(varin) SWIGTYPE ((*)(ANY)) {
[build]     int res = SWIG_ConvertFunctionPtr($input, (void**)(&$1), $descriptor);
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'"); 
[build]     }
[build]   }
[build]   
[build]   %typemap(varout,noblock=1) SWIGTYPE ((*)(ANY)) {  
[build]     $result = SWIG_NewFunctionPtrObj((void *)($1), $descriptor);
[build]   }
[build]   
[build]   %typemap(constcode, noblock=1) SWIGTYPE ((*)(ANY)){
[build]     SWIG_Python_SetConstant(d, "$symname",SWIG_NewFunctionPtrObj((void *)$value, $descriptor));
[build]   }
[build]   %typemap(constcode) SWIGTYPE ((* const)(ANY)) = SWIGTYPE ((*)(ANY));
[build]   
[build]   
[build]   
[build]   /* directorin */
[build]   
[build]   %typemap(directorin,noblock=1) SWIGTYPE ((*)(ANY)) {
[build]     $input = SWIG_NewFunctionPtrObj((void*)($1), $descriptor);
[build]   }
[build]   
[build]   /* directorout */
[build]   
[build]   %typemap(directorout) SWIGTYPE ((*)(ANY)) {
[build]     int swig_res = SWIG_ConvertFunctionPtr($input,(void**)(&$result),$descriptor);
[build]     if (!SWIG_IsOK(swig_res)) {
[build]       Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]     }
[build]   }
[build]   
[build]   
[build]   %apply SWIGTYPE * { SWIGTYPE *const }
[build]   
[build]   /* ------------------------------------------------------------
[build]    * --- Special typemaps ---
[build]    * ------------------------------------------------------------ */
[build]   
[build]   /* DISOWN typemap */
[build]   
[build]   %typemap(in, noblock=1) SWIGTYPE *DISOWN (int res = 0) {
[build]     res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&$1), $descriptor, SWIG_POINTER_DISOWN |  0 );
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
[build]     }
[build]   }
[build]   
[build]   %typemap(varin) SWIGTYPE *DISOWN {
[build]     void *temp = 0;
[build]     int res = SWIG_ConvertPtr($input, &temp, $descriptor, SWIG_POINTER_DISOWN |  0 );
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]     }
[build]     $1 = ($ltype) temp;
[build]   }
[build]   
[build]   /* DYNAMIC typemap */
[build]   
[build]   %typemap(out,noblock=1) SWIGTYPE *DYNAMIC, SWIGTYPE &DYNAMIC {
[build]     $result = SWIG_NewPointerObj(SWIG_as_voidptr($1), SWIG_TypeDynamicCast($descriptor, SWIG_as_voidptrptr(&$1)), $owner |  0 );
[build]   }
[build]   
[build]   /* INSTANCE typemap */
[build]   
[build]   %typemap(out,noblock=1) SWIGTYPE INSTANCE {
[build]     $result = SWIG_NewInstanceObj(($1_ltype *)memcpy(($1_ltype *)calloc(1,sizeof($1_ltype)),&$1,sizeof($1_ltype)), $&1_descriptor, SWIG_POINTER_OWN | 0 );
[build]   }
[build]   
[build]   %typemap(out,noblock=1) SWIGTYPE *INSTANCE, SWIGTYPE &INSTANCE, SWIGTYPE INSTANCE[] {
[build]     $result = SWIG_NewInstanceObj(SWIG_as_voidptr($1), $1_descriptor, $owner | 0 );
[build]   }
[build]   
[build]   %typemap(varout,noblock=1) SWIGTYPE *INSTANCE, SWIGTYPE INSTANCE[] {
[build]     $result = SWIG_NewInstanceObj(SWIG_as_voidptr($1), $1_descriptor, 0 );
[build]   }
[build]   
[build]   %typemap(varout,noblock=1) SWIGTYPE &INSTANCE {
[build]     $result = SWIG_NewInstanceObj(SWIG_as_voidptr($1), $1_descriptor, 0 );
[build]   }
[build]   
[build]   %typemap(varout,noblock=1) SWIGTYPE INSTANCE {
[build]     $result = SWIG_NewInstanceObj(SWIG_as_voidptr(&$1), $&1_descriptor, 0 );
[build]   }
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\typemaps\\void.swg" %beginfile
[build]   /* ------------------------------------------------------------
[build]    * Void * -  Accepts any kind of pointer
[build]    * ------------------------------------------------------------ */
[build]   
[build]   /* in */
[build]   
[build]   %typemap(in,noblock=1) void * (int res) {
[build]     res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1), 0, $disown);
[build]     if (!SWIG_IsOK(res)) { 
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
[build]     }
[build]   }
[build]   %typemap(freearg) void * "";
[build]   
[build]   %typemap(in,noblock=1) void * const& ($*ltype temp = 0, int res) {
[build]     res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&temp), 0, $disown);
[build]     if (!SWIG_IsOK(res)) { 
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "Stype""'"); 
[build]     }
[build]     $1 =  &temp;
[build]   }
[build]   %typemap(freearg) void * const& "";
[build]   
[build]   
[build]   /* out */
[build]   
[build]   
[build]   %typemap(out,noblock=1) void { $result = SWIG_Py_Void(); }
[build]   
[build]   
[build]   
[build]   
[build]   /* varin */
[build]   
[build]   %typemap(varin) void * {
[build]     void *temp = 0;
[build]     int res = SWIG_ConvertPtr($input, &temp, 0, SWIG_POINTER_DISOWN);
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]     }
[build]     $1 = ($1_ltype) temp;
[build]   }
[build]   
[build]   /* typecheck */
[build]   
[build]    %typemap(typecheck, precedence=      10    ,noblock=1)  void *
[build]   {
[build]     void *ptr = 0;
[build]     int res = SWIG_ConvertPtr($input, &ptr, 0, 0);
[build]     $1 = SWIG_CheckState(res);
[build]   }
[build]   
[build]   
[build]   
[build]   /* directorin */
[build]   
[build]   %typemap(directorin,noblock=1) void *, void const*, void *const, void const *const, 
[build]     void const *&, void *const &, void const *const & {
[build]     $input = SWIG_NewPointerObj(SWIG_as_voidptr($1), $descriptor,  0 );
[build]   }
[build]   
[build]   /* directorout */
[build]   
[build]   %typemap(directorout,noblock=1) void * (void *argp, int res) {
[build]     res = SWIG_ConvertPtr($input, &argp, 0, 0);
[build]     if (!SWIG_IsOK(res)) {
[build]       Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(res)), "in output value of type '""$type""'");
[build]     }
[build]     $result = ($ltype)(argp);
[build]   }
[build]   
[build]   %typemap(directorout,noblock=1,warning= "473:Returning a pointer or reference in a director method is not recommended." ) void * const& (void *argp, int res) {
[build]     res = SWIG_ConvertPtr($input, &argp, 0, $disown);
[build]     if (!SWIG_IsOK(res)) { 
[build]       Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(res)), "in output value of type '""$type""'");
[build]     }
[build]     static $*ltype temp = ($*ltype)(argp);
[build]     $result =  &temp;
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\typemaps\\swigobject.swg" %beginfile
[build]   /* ------------------------------------------------------------
[build]    * Language Object *  - Just pass straight through unmodified
[build]    * ------------------------------------------------------------ */
[build]   
[build]   %typemap(in)   PyObject * "$1 = $input;";
[build]   
[build]   %typemap(in,noblock=1)   PyObject * const & ($*ltype temp)
[build]   {
[build]     temp = ($*ltype)($input);
[build]     $1 = &temp;
[build]   }
[build]   
[build]   %typemap(out,noblock=1) PyObject * {
[build]     $result = $1;
[build]   }
[build]   
[build]   %typemap(out,noblock=1)  PyObject * const & {
[build]     $result = *$1;
[build]   }
[build]   
[build]    %typemap(typecheck, precedence=       5000    )  PyObject * "$1 = ($input != 0);";
[build]   
[build]   %typemap(throws,noblock=1) PyObject * {
[build]     SWIG_Python_Raise($1, "$type", 0); SWIG_fail;
[build]   }
[build]   
[build]   %typemap(constcode,noblock=1) PyObject * {
[build]     SWIG_Python_SetConstant(d, "$symname",$value);
[build]   }
[build]   
[build]   
[build]   
[build]   %typemap(directorin) PyObject * "$input = $1;";
[build]   %typemap(directorout) PyObject * "$result = $input;";
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\typemaps\\valtypes.swg" %beginfile
[build]   /*---------------------------------------------------------------------
[build]    * Value typemaps (Type, const Type&) for value types, such as
[build]    * fundamental types (int, double), that define the AsVal/From
[build]    * methods.
[build]    *
[build]    * To apply them, just use one of the following macros:
[build]    *
[build]    *   %typemaps_from(FromMeth, FromFrag, Type)
[build]    *   %typemaps_asval(CheckCode, AsValMeth, AsValFrag, Type)
[build]    *   %typemaps_asvalfrom(CheckCode, AsValMeth, FromMeth, AsValFrag, FromFrag, Type)
[build]    *
[build]    * or the simpler and normalize form:
[build]    *
[build]    *   %typemaps_asvalfromn(CheckCode, Type)
[build]    *
[build]    * Also, you can use the individual typemap definitions:
[build]    *
[build]    *    %value_in_typemap(asval_meth,frag,Type)
[build]    *    %value_varin_typemap(asval_meth,frag,Type)
[build]    *    %value_typecheck_typemap(checkcode,asval_meth,frag,Type)
[build]    *    %value_directorout_typemap(asval_meth,frag,Type)
[build]    *
[build]    *    %value_out_typemap(from_meth,frag,Type)
[build]    *    %value_varout_typemap(from_meth,frag,Type)
[build]    *    %value_constcode_typemap(from_meth,frag,Type)
[build]    *    %value_directorin_typemap(from_meth,frag,Type)
[build]    *    %value_throws_typemap(from_meth,frag,Type)
[build]    *
[build]    *---------------------------------------------------------------------*/
[build]   
[build]   /* in */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* out */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* varin */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* varout */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* constant installation code */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* directorin */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* directorout */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* throws */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* typecheck */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*---------------------------------------------------------------------
[build]    * typemap definition for types with AsVal methods
[build]    *---------------------------------------------------------------------*/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*---------------------------------------------------------------------
[build]    * typemap definition for types with from method
[build]    *---------------------------------------------------------------------*/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*---------------------------------------------------------------------
[build]    * typemap definition for types with alval/from method
[build]    *---------------------------------------------------------------------*/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*---------------------------------------------------------------------
[build]    * typemap definition for types  with for 'normalized' asval/from methods
[build]    *---------------------------------------------------------------------*/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\typemaps\\ptrtypes.swg" %beginfile
[build]   /* -----------------------------------------------------------------------------
[build]    * ptrtypes.swg
[build]    *
[build]    * Value typemaps (Type, const Type&) for "Ptr" types, such as swig
[build]    * wrapped classes, that define the AsPtr/From methods
[build]    *
[build]    * To apply them, just use one of the following macros:
[build]    *
[build]    *    %typemaps_asptr(CheckCode, AsPtrMeth, AsPtrFrag, Type)
[build]    *    %typemaps_asptrfrom(CheckCode, AsPtrMeth, FromMeth, AsPtrFrag, FromFrag, Type)
[build]    *
[build]    * or the simpler and normalize form:
[build]    *
[build]    *    %typemaps_asptrfromn(CheckCode, Type)
[build]    *
[build]    * Also, you can use the individual typemap definitions:
[build]    *
[build]    *    %ptr_in_typemap(asptr_meth,frag,Type)
[build]    *    %ptr_varin_typemap(asptr_meth,frag,Type)
[build]    *    %ptr_typecheck_typemap(check,asptr_meth,frag,Type)
[build]    *    %ptr_directorout_typemap(asptr_meth,frag,Type)
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   /* in */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* varin */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* directorout */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* typecheck */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*---------------------------------------------------------------------
[build]    * typemap definition for types with asptr method
[build]    *---------------------------------------------------------------------*/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*---------------------------------------------------------------------
[build]    * typemap definition for types with asptr/from methods
[build]    *---------------------------------------------------------------------*/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*---------------------------------------------------------------------
[build]    * typemap definition for types  with for 'normalized' asptr/from methods
[build]    *---------------------------------------------------------------------*/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\typemaps\\inoutlist.swg" %beginfile
[build]   /*  ------------------------------------------------------------
[build]    *
[build]    * Define the IN/OUTPUT typemaps assuming the output parameters are
[build]    * returned in a list, i.e., they are not directly modified.
[build]    *
[build]    * The user should provide the %append_output(result, obj) method,
[build]    * via a macro, which append a particular object to the result.
[build]    *
[build]    *
[build]    * In Tcl, for example, the file is used as:
[build]    *
[build]    *   #define %append_output(obj) Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),obj);
[build]    *   %include <typemaps/inoutlist.swg>
[build]    *
[build]    * while in Python it is used as:
[build]    *
[build]    *   #define %append_output(obj) $result = SWIG_Python_AppendResult($result, obj)
[build]    *   %include <typemaps/inoutlist.swg>
[build]    *
[build]    * where the method SWIG_Python_AppendResult is defined inside the
[build]    * %append_output fragment.
[build]    *
[build]    * If you forget to define %append_output, this file will generate
[build]    * an error.
[build]    *
[build]    * ------------------------------------------------------------ */
[build]   
[build]   
[build]   //
[build]   // Uncomment the following definition if you don't want the in/out
[build]   // typemaps by default, ie, you prefer to use typemaps.i.
[build]   //
[build]   //#define SWIG_INOUT_NODEF
[build]   
[build]   //
[build]   // Use the following definition to enable the INPUT parameters to
[build]   // accept both 'by value' and 'pointer' objects.
[build]   //
[build]   
[build]   
[build]   // ------------------------------------------------------------------------
[build]   // Pointer handling
[build]   //
[build]   // These mappings provide support for input/output arguments and common
[build]   // uses for C/C++ pointers.
[build]   // ------------------------------------------------------------------------
[build]   
[build]   // INPUT typemaps.
[build]   // These remap a C pointer to be an "INPUT" value which is passed by value
[build]   // instead of reference.
[build]   
[build]   /* 
[build]   The following methods can be applied to turn a pointer into a simple
[build]   "input" value.  That is, instead of passing a pointer to an object,
[build]   you would use a real value instead.
[build]            
[build]   To use these, suppose you had a C function like this :
[build]   
[build]           double fadd(double *a, double *b) {
[build]                  return *a+*b;
[build]           }
[build]   
[build]   You could wrap it with SWIG as follows :
[build]   
[build]           double fadd(double *INPUT, double *INPUT);
[build]   
[build]   or you can use the %apply directive :
[build]   
[build]           %apply double *INPUT { double *a, double *b };
[build]           double fadd(double *a, double *b);
[build]   
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   // OUTPUT typemaps.   These typemaps are used for parameters that
[build]   // are output only.   The output value is appended to the result as
[build]   // a list element.
[build]   
[build]   /* 
[build]   The following methods can be applied to turn a pointer into an "output"
[build]   value.  When calling a function, no input value would be given for
[build]   a parameter, but an output value would be returned.  In the case of
[build]   multiple output values, they are returned in the form of a list.
[build]   
[build]            
[build]   For example, suppose you were trying to wrap the modf() function in the
[build]   C math library which splits x into integral and fractional parts (and
[build]   returns the integer part in one of its parameters):
[build]   
[build]           double modf(double x, double *ip);
[build]   
[build]   You could wrap it with SWIG as follows :
[build]   
[build]           double modf(double x, double *OUTPUT);
[build]   
[build]   or you can use the %apply directive :
[build]   
[build]           %apply double *OUTPUT { double *ip };
[build]           double modf(double x, double *ip);
[build]   
[build]   The output of the function would be a list containing both output
[build]   values.
[build]   
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   // INOUT
[build]   // Mappings for an argument that is both an input and output
[build]   // parameter
[build]   
[build]   /*
[build]   The following methods can be applied to make a function parameter both
[build]   an input and output value.  This combines the behavior of both the
[build]   "INPUT" and "OUTPUT" methods described earlier.  Output values are
[build]   returned in the form of a list.  
[build]            
[build]   For example, suppose you were trying to wrap the following function :
[build]   
[build]           void neg(double *x) {
[build]                *x = -(*x);
[build]           }
[build]   
[build]   You could wrap it with SWIG as follows :
[build]   
[build]           void neg(double *INOUT);
[build]   
[build]   or you can use the %apply directive :
[build]   
[build]           %apply double *INOUT { double *x };
[build]           void neg(double *x);
[build]   
[build]   Unlike C, this mapping does not directly modify the input value.
[build]   Rather, the modified input value shows up as the return value of the
[build]   function.  Thus, to apply this function to a variable you might do
[build]   this :
[build]   
[build]          x = neg(x)
[build]   
[build]   Note : previous versions of SWIG used the symbol 'BOTH' to mark
[build]   input/output arguments.   This is still supported, but will be slowly
[build]   phased out in future releases.
[build]   
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*----------------------------------------------------------------------
[build]     Front ends.
[build]     
[build]     use the following macros to define your own IN/OUTPUT/INOUT typemaps
[build]     
[build]     ------------------------------------------------------------------------*/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\typemaps\\primtypes.swg" %beginfile
[build]   /* ------------------------------------------------------------
[build]    * Primitive type fragments and macros 
[build]    * ------------------------------------------------------------ */
[build]   
[build]   /*
[build]     This file provide fragments and macros for the C/C++ primitive types. 
[build]   
[build]     The file defines default fragments for the following types:
[build]   
[build]       bool
[build]       signed char
[build]       unsigned char
[build]       signed wchar_t     // in C++
[build]       unsigned wchar_t   // in C++
[build]       short
[build]       unsigned short
[build]       int
[build]       unsigned int
[build]       float
[build]       size_t
[build]       ptrdiff_t
[build]   
[build]     which can always be redefined in the swig target language if needed.
[build]     
[build]     The fragments for the following types, however, always need to be
[build]     defined in the target language:
[build]   
[build]       long
[build]       unsigned long
[build]       long long
[build]       unsigned long long
[build]       double
[build]    
[build]     If they are not provided, an #error directive will appear in the
[build]     wrapped code.
[build]   
[build]     --------------------------------------------------------------------
[build]     
[build]     This file provides the macro
[build]   
[build]       %typemaps_primitive(CheckCode, Type)
[build]   
[build]     which generates the typemaps for a primitive type with a given
[build]     checkcode. It is assumed that the primitive type is 'normalized' and
[build]     the corresponding SWIG_AsVal(Type) and SWIG_From(Type) methods are
[build]     provided via fragments.
[build]     
[build]      
[build]     The following auxiliary macros (explained with bash pseudo code) are
[build]     also defined:
[build]   
[build]       %apply_ctypes(Macro)
[build]         for i in C Type
[build]         do
[build]           Macro($i)
[build]         done
[build]   
[build]       %apply_cpptypes(Macro)
[build]         for i in C++ Type
[build]         do
[build]           Macro($i)
[build]         done
[build]   
[build]       %apply_ctypes_2(Macro2)
[build]          for i in C Type
[build]          do
[build]            for j in C Type
[build]            do
[build]               Macro_2($i, $j)
[build]            done
[build]          done
[build]   
[build]       %apply_cpptypes_2(Macro2)
[build]          for i in C++ Type
[build]          do
[build]            for j in C++ Type
[build]            do
[build]               Macro_2($i, $j)
[build]            done
[build]          done
[build]   
[build]       %apply_checkctypes(Macro2)
[build]          for i in Check Type
[build]          do
[build]            Macro2(%checkcode($i), $i)
[build]          done
[build]   
[build]   */
[build]   
[build]   
[build]   /* ------------------------------------------------------------
[build]    * Primitive type fragments 
[build]    * ------------------------------------------------------------ */
[build]   /* boolean */
[build]   
[build]   %fragment("SWIG_" "From" "_" {bool},"header",fragment="SWIG_" "From" "_" {long}) {
[build]   SWIGINTERN PyObject *
[build]   SWIG_From_bool  (bool value)
[build]   {    
[build]     return SWIG_From_long  (value ? 1 : 0);
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "AsVal" "_" {bool},"header",fragment="SWIG_" "AsVal" "_" {long}) {
[build]   SWIGINTERN int
[build]   SWIG_AsVal_bool (PyObject * obj, bool *val)
[build]   {
[build]     long v;
[build]     int res = SWIG_AsVal_long (obj, val ? &v : 0);
[build]     if (SWIG_IsOK(res)) {    
[build]       if (val) *val = v ? true : false;
[build]       return res;
[build]     }  
[build]     return SWIG_TypeError;
[build]   }
[build]   }
[build]   
[build]   /* signed/unsigned char */
[build]   
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,255,%numeric_slong@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,214,%numeric_type_from@*/
[build]   %fragment("SWIG_" "From" "_" {signed char},"header",
[build]   	  fragment="SWIG_" "From" "_" {long}) {
[build]   SWIGINTERNINLINE PyObject *
[build]   SWIG_From_signed_SS_char  (signed char value)
[build]   {    
[build]     return SWIG_From_long  (value);
[build]   }
[build]   }
[build]   /*@SWIG@*/
[build]    /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,225,%numeric_type_asval@*/
[build]   %fragment("SWIG_" "AsVal" "_" {signed char},"header",
[build]   	  fragment="<limits.h>",
[build]   	  fragment="SWIG_" "AsVal" "_" {long}) {
[build]   SWIGINTERN int
[build]   SWIG_AsVal_signed_SS_char (PyObject * obj, signed char *val)
[build]   {
[build]     long v;
[build]     int res = SWIG_AsVal_long (obj, &v);
[build]     if (SWIG_IsOK(res)) {
[build]       if ((v < SCHAR_MIN || v > SCHAR_MAX)) {
[build]         return SWIG_OverflowError;
[build]       } else {
[build]         if (val) *val = (signed char)(v);
[build]       }
[build]     }  
[build]     return res;
[build]   }
[build]   }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,262,%numeric_ulong@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,214,%numeric_type_from@*/
[build]   %fragment("SWIG_" "From" "_" {unsigned char},"header",
[build]   	  fragment="SWIG_" "From" "_" {unsigned long}) {
[build]   SWIGINTERNINLINE PyObject *
[build]   SWIG_From_unsigned_SS_char  (unsigned char value)
[build]   {    
[build]     return SWIG_From_unsigned_SS_long  (value);
[build]   }
[build]   }
[build]   /*@SWIG@*/
[build]    /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,225,%numeric_type_asval@*/
[build]   %fragment("SWIG_" "AsVal" "_" {unsigned char},"header",
[build]   	  fragment="<limits.h>",
[build]   	  fragment="SWIG_" "AsVal" "_" {unsigned long}) {
[build]   SWIGINTERN int
[build]   SWIG_AsVal_unsigned_SS_char (PyObject * obj, unsigned char *val)
[build]   {
[build]     unsigned long v;
[build]     int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
[build]     if (SWIG_IsOK(res)) {
[build]       if ((v > UCHAR_MAX)) {
[build]         return SWIG_OverflowError;
[build]       } else {
[build]         if (val) *val = (unsigned char)(v);
[build]       }
[build]     }  
[build]     return res;
[build]   }
[build]   }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/
[build]   
[build]   /* short/unsigned short */
[build]   
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,255,%numeric_slong@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,214,%numeric_type_from@*/
[build]   %fragment("SWIG_" "From" "_" {short},"header",
[build]   	  fragment="SWIG_" "From" "_" {long}) {
[build]   SWIGINTERNINLINE PyObject *
[build]   SWIG_From_short  (short value)
[build]   {    
[build]     return SWIG_From_long  (value);
[build]   }
[build]   }
[build]   /*@SWIG@*/
[build]    /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,225,%numeric_type_asval@*/
[build]   %fragment("SWIG_" "AsVal" "_" {short},"header",
[build]   	  fragment="<limits.h>",
[build]   	  fragment="SWIG_" "AsVal" "_" {long}) {
[build]   SWIGINTERN int
[build]   SWIG_AsVal_short (PyObject * obj, short *val)
[build]   {
[build]     long v;
[build]     int res = SWIG_AsVal_long (obj, &v);
[build]     if (SWIG_IsOK(res)) {
[build]       if ((v < SHRT_MIN || v > SHRT_MAX)) {
[build]         return SWIG_OverflowError;
[build]       } else {
[build]         if (val) *val = (short)(v);
[build]       }
[build]     }  
[build]     return res;
[build]   }
[build]   }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,262,%numeric_ulong@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,214,%numeric_type_from@*/
[build]   %fragment("SWIG_" "From" "_" {unsigned short},"header",
[build]   	  fragment="SWIG_" "From" "_" {unsigned long}) {
[build]   SWIGINTERNINLINE PyObject *
[build]   SWIG_From_unsigned_SS_short  (unsigned short value)
[build]   {    
[build]     return SWIG_From_unsigned_SS_long  (value);
[build]   }
[build]   }
[build]   /*@SWIG@*/
[build]    /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,225,%numeric_type_asval@*/
[build]   %fragment("SWIG_" "AsVal" "_" {unsigned short},"header",
[build]   	  fragment="<limits.h>",
[build]   	  fragment="SWIG_" "AsVal" "_" {unsigned long}) {
[build]   SWIGINTERN int
[build]   SWIG_AsVal_unsigned_SS_short (PyObject * obj, unsigned short *val)
[build]   {
[build]     unsigned long v;
[build]     int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
[build]     if (SWIG_IsOK(res)) {
[build]       if ((v > USHRT_MAX)) {
[build]         return SWIG_OverflowError;
[build]       } else {
[build]         if (val) *val = (unsigned short)(v);
[build]       }
[build]     }  
[build]     return res;
[build]   }
[build]   }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/
[build]   
[build]   /* int/unsigned int */
[build]   
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,255,%numeric_slong@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,214,%numeric_type_from@*/
[build]   %fragment("SWIG_" "From" "_" {int},"header",
[build]   	  fragment="SWIG_" "From" "_" {long}) {
[build]   SWIGINTERNINLINE PyObject *
[build]   SWIG_From_int  (int value)
[build]   {    
[build]     return SWIG_From_long  (value);
[build]   }
[build]   }
[build]   /*@SWIG@*/
[build]    /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,225,%numeric_type_asval@*/
[build]   %fragment("SWIG_" "AsVal" "_" {int},"header",
[build]   	  fragment="<limits.h>",
[build]   	  fragment="SWIG_" "AsVal" "_" {long}) {
[build]   SWIGINTERN int
[build]   SWIG_AsVal_int (PyObject * obj, int *val)
[build]   {
[build]     long v;
[build]     int res = SWIG_AsVal_long (obj, &v);
[build]     if (SWIG_IsOK(res)) {
[build]       if ((v < INT_MIN || v > INT_MAX)) {
[build]         return SWIG_OverflowError;
[build]       } else {
[build]         if (val) *val = (int)(v);
[build]       }
[build]     }  
[build]     return res;
[build]   }
[build]   }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,262,%numeric_ulong@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,214,%numeric_type_from@*/
[build]   %fragment("SWIG_" "From" "_" {unsigned int},"header",
[build]   	  fragment="SWIG_" "From" "_" {unsigned long}) {
[build]   SWIGINTERNINLINE PyObject *
[build]   SWIG_From_unsigned_SS_int  (unsigned int value)
[build]   {    
[build]     return SWIG_From_unsigned_SS_long  (value);
[build]   }
[build]   }
[build]   /*@SWIG@*/
[build]    /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,225,%numeric_type_asval@*/
[build]   %fragment("SWIG_" "AsVal" "_" {unsigned int},"header",
[build]   	  fragment="<limits.h>",
[build]   	  fragment="SWIG_" "AsVal" "_" {unsigned long}) {
[build]   SWIGINTERN int
[build]   SWIG_AsVal_unsigned_SS_int (PyObject * obj, unsigned int *val)
[build]   {
[build]     unsigned long v;
[build]     int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
[build]     if (SWIG_IsOK(res)) {
[build]       if ((v > UINT_MAX)) {
[build]         return SWIG_OverflowError;
[build]       } else {
[build]         if (val) *val = (unsigned int)(v);
[build]       }
[build]     }  
[build]     return res;
[build]   }
[build]   }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/
[build]   
[build]   /* signed/unsigned wchar_t */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* float */
[build]   
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,277,%numeric_float@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,214,%numeric_type_from@*/
[build]   %fragment("SWIG_" "From" "_" {float},"header",
[build]   	  fragment="SWIG_" "From" "_" {double}) {
[build]   SWIGINTERNINLINE PyObject *
[build]   SWIG_From_float  (float value)
[build]   {    
[build]     return SWIG_From_double  (value);
[build]   }
[build]   }
[build]   /*@SWIG@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,225,%numeric_type_asval@*/
[build]   %fragment("SWIG_" "AsVal" "_" {float},"header",
[build]   	  fragment="SWIG_Float_Overflow_Check",
[build]   	  fragment="SWIG_" "AsVal" "_" {double}) {
[build]   SWIGINTERN int
[build]   SWIG_AsVal_float (PyObject * obj, float *val)
[build]   {
[build]     double v;
[build]     int res = SWIG_AsVal_double (obj, &v);
[build]     if (SWIG_IsOK(res)) {
[build]       if (SWIG_Float_Overflow_Check(v)) {
[build]         return SWIG_OverflowError;
[build]       } else {
[build]         if (val) *val = (float)(v);
[build]       }
[build]     }  
[build]     return res;
[build]   }
[build]   }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/
[build]   
[build]   /* long/unsigned long */
[build]   
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,291,%ensure_type_fragments@*/
[build]   %fragment("SWIG_" "From" "_" {long},"header") {
[build]   #error "SWIG language implementation must provide a SWIG_From_frag(long) fragment"
[build]   }
[build]   %fragment("SWIG_" "AsVal" "_" {long},"header") {
[build]   #error "SWIG language implementation must provide a SWIG_AsVal_frag(long) fragment"
[build]   }
[build]   /*@SWIG@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,291,%ensure_type_fragments@*/
[build]   %fragment("SWIG_" "From" "_" {unsigned long},"header") {
[build]   #error "SWIG language implementation must provide a SWIG_From_frag(unsigned long) fragment"
[build]   }
[build]   %fragment("SWIG_" "AsVal" "_" {unsigned long},"header") {
[build]   #error "SWIG language implementation must provide a SWIG_AsVal_frag(unsigned long) fragment"
[build]   }
[build]   /*@SWIG@*/
[build]   
[build]   /* long long/unsigned long long */
[build]   
[build]   %fragment("SWIG_LongLongAvailable","header", fragment="<limits.h>") %{
[build]   #if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
[build]   #  define SWIG_LONG_LONG_AVAILABLE
[build]   #endif
[build]   %}
[build]   
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,291,%ensure_type_fragments@*/
[build]   %fragment("SWIG_" "From" "_" {long long},"header") {
[build]   #error "SWIG language implementation must provide a SWIG_From_frag(long long) fragment"
[build]   }
[build]   %fragment("SWIG_" "AsVal" "_" {long long},"header") {
[build]   #error "SWIG language implementation must provide a SWIG_AsVal_frag(long long) fragment"
[build]   }
[build]   /*@SWIG@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,291,%ensure_type_fragments@*/
[build]   %fragment("SWIG_" "From" "_" {unsigned long long},"header") {
[build]   #error "SWIG language implementation must provide a SWIG_From_frag(unsigned long long) fragment"
[build]   }
[build]   %fragment("SWIG_" "AsVal" "_" {unsigned long long},"header") {
[build]   #error "SWIG language implementation must provide a SWIG_AsVal_frag(unsigned long long) fragment"
[build]   }
[build]   /*@SWIG@*/
[build]   
[build]   /* double */
[build]   
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,291,%ensure_type_fragments@*/
[build]   %fragment("SWIG_" "From" "_" {double},"header") {
[build]   #error "SWIG language implementation must provide a SWIG_From_frag(double) fragment"
[build]   }
[build]   %fragment("SWIG_" "AsVal" "_" {double},"header") {
[build]   #error "SWIG language implementation must provide a SWIG_AsVal_frag(double) fragment"
[build]   }
[build]   /*@SWIG@*/
[build]   
[build]   /* size_t */
[build]   
[build]   %fragment("SWIG_" "From" "_" {size_t},"header",fragment="SWIG_" "From" "_" {unsigned long},fragment="SWIG_" "From" "_" {unsigned long long}) {
[build]   SWIGINTERNINLINE PyObject *
[build]   SWIG_From_size_t  (size_t value)
[build]   {    
[build]   #ifdef SWIG_LONG_LONG_AVAILABLE
[build]     if (sizeof(size_t) <= sizeof(unsigned long)) {
[build]   #endif
[build]       return SWIG_From_unsigned_SS_long  ((unsigned long)(value));
[build]   #ifdef SWIG_LONG_LONG_AVAILABLE
[build]     } else {
[build]       /* assume sizeof(size_t) <= sizeof(unsigned long long) */
[build]       return SWIG_From_unsigned_SS_long_SS_long  ((unsigned long long)(value));
[build]     }
[build]   #endif
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "AsVal" "_" {size_t},"header",fragment="SWIG_" "AsVal" "_" {unsigned long},fragment="SWIG_" "AsVal" "_" {unsigned long long}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_AsVal_size_t (PyObject * obj, size_t *val)
[build]   {
[build]     int res = SWIG_TypeError;
[build]   #ifdef SWIG_LONG_LONG_AVAILABLE
[build]     if (sizeof(size_t) <= sizeof(unsigned long)) {
[build]   #endif
[build]       unsigned long v;
[build]       res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
[build]       if (SWIG_IsOK(res) && val) *val = (size_t)(v);
[build]   #ifdef SWIG_LONG_LONG_AVAILABLE
[build]     } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
[build]       unsigned long long v;
[build]       res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, val ? &v : 0);
[build]       if (SWIG_IsOK(res) && val) *val = (size_t)(v);
[build]     }
[build]   #endif
[build]     return res;
[build]   }
[build]   }
[build]   
[build]   /* ptrdiff_t */
[build]   
[build]   %fragment("SWIG_" "From" "_" {ptrdiff_t},"header",fragment="SWIG_" "From" "_" {long},fragment="SWIG_" "From" "_" {long long}) {
[build]   SWIGINTERNINLINE PyObject *
[build]   SWIG_From_ptrdiff_t  (ptrdiff_t value)
[build]   {    
[build]   #ifdef SWIG_LONG_LONG_AVAILABLE
[build]     if (sizeof(ptrdiff_t) <= sizeof(long)) {
[build]   #endif
[build]       return SWIG_From_long  ((long)(value));
[build]   #ifdef SWIG_LONG_LONG_AVAILABLE
[build]     } else {
[build]       /* assume sizeof(ptrdiff_t) <= sizeof(long long) */
[build]       return SWIG_From_long_SS_long  ((long long)(value));
[build]     }
[build]   #endif
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "AsVal" "_" {ptrdiff_t},"header",fragment="SWIG_" "AsVal" "_" {long},fragment="SWIG_" "AsVal" "_" {long long}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_AsVal_ptrdiff_t (PyObject * obj, ptrdiff_t *val)
[build]   {
[build]     int res = SWIG_TypeError;
[build]   #ifdef SWIG_LONG_LONG_AVAILABLE
[build]     if (sizeof(ptrdiff_t) <= sizeof(long)) {
[build]   #endif
[build]       long v;
[build]       res = SWIG_AsVal_long (obj, val ? &v : 0);
[build]       if (SWIG_IsOK(res) && val) *val = (ptrdiff_t)(v);
[build]   #ifdef SWIG_LONG_LONG_AVAILABLE
[build]     } else if (sizeof(ptrdiff_t) <= sizeof(long long)) {
[build]       long long v;
[build]       res = SWIG_AsVal_long_SS_long (obj, val ? &v : 0);
[build]       if (SWIG_IsOK(res) && val) *val = (ptrdiff_t)(v);
[build]     }
[build]   #endif
[build]     return res;
[build]   }
[build]   }
[build]   
[build]   
[build]   %fragment("SWIG_CanCastAsInteger","header",
[build]   	  fragment="SWIG_" "AsVal" "_" {double},
[build]   	  fragment="<float.h>",
[build]   	  fragment="<math.h>") {
[build]   SWIGINTERNINLINE int
[build]   SWIG_CanCastAsInteger(double *d, double min, double max) {
[build]     double x = *d;
[build]     if ((min <= x && x <= max)) {
[build]      double fx = floor(x);
[build]      double cx = ceil(x);
[build]      double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
[build]      if ((errno == EDOM) || (errno == ERANGE)) {
[build]        errno = 0;
[build]      } else {
[build]        double summ, reps, diff;
[build]        if (rd < x) {
[build]          diff = x - rd;
[build]        } else if (rd > x) {
[build]          diff = rd - x;
[build]        } else {
[build]          return 1;
[build]        }
[build]        summ = rd + x;
[build]        reps = diff/summ;
[build]        if (reps < 8*DBL_EPSILON) {
[build]          *d = rd;
[build]          return 1;
[build]        }
[build]      }
[build]     }
[build]     return 0;
[build]   }
[build]   }
[build]   
[build]   /* ------------------------------------------------------------
[build]    * Generate the typemaps for primitive type 
[build]    * ------------------------------------------------------------ */
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------
[build]    * Primitive Type Macros
[build]    * ------------------------------------------------------------ */
[build]   
[build]   /* useful macros to derive typemap declarations from primitive types */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* Apply macro to the C-types */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* apply the Macro2(Type1, Type2) to all  C types  */
[build]   
[build]   
[build]   
[build]   /* apply the Macro(Type) to all  C++ types  */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* apply the Macro2(Type1, Type2) to all  C++ types  */
[build]   
[build]   
[build]   /* apply the Macro2(CheckCode,Type) to all  Checked Types */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------
[build]    * Generate the typemaps for all the primitive types with checkcode
[build]    * ------------------------------------------------------------ */
[build]   
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\primtypes.swg,341,%apply_checkctypes@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool (bool val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_bool($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) bool "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) const bool & ($*ltype temp, bool val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_bool($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const bool& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {bool}) bool {
[build]       bool val;
[build]       int res = SWIG_AsVal_bool($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool *DIRECTOROUT(bool swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_bool($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool {
[build]       bool swig_val;
[build]       int swig_res = SWIG_AsVal_bool($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {bool},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const bool& {  
[build]       bool swig_val;
[build]       int swig_res = SWIG_AsVal_bool($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const bool & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {bool}) bool &DIRECTOROUT = bool
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=15,fragment="SWIG_" "AsVal" "_" {bool}) bool, const bool& {
[build]       int res = SWIG_AsVal_bool($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         bool val; 
[build]         int ecode = SWIG_AsVal_bool($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         bool val;
[build]         int ecode = SWIG_AsVal_bool($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") bool *INPUT, bool &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=15,fragment="SWIG_" "AsVal" "_" {bool}) bool *INPUT, bool &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_bool($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool, const bool {
[build]       $result = SWIG_From_bool((bool)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {bool}) const bool& {
[build]       $result = SWIG_From_bool((bool)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool, const bool&  {
[build]       $result = SWIG_From_bool((bool)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_bool((bool)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool *DIRECTORIN {
[build]       $input = SWIG_From_bool((bool)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool, const bool& {
[build]       $input = SWIG_From_bool((bool)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool {
[build]       SWIG_Python_Raise(SWIG_From_bool((bool)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      bool *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      bool &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool *OUTPUT, bool &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_bool((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) bool *INOUT = bool *INPUT;
[build]    %typemap(in) bool &INOUT = bool &INPUT;
[build]    %typemap(typecheck) bool *INOUT = bool *INPUT;
[build]    %typemap(typecheck) bool &INOUT = bool &INPUT;
[build]    %typemap(argout) bool *INOUT = bool *OUTPUT;
[build]    %typemap(argout) bool &INOUT = bool &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char (signed char val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_signed_SS_char($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) signed char "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) const signed char & ($*ltype temp, signed char val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_signed_SS_char($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const signed char& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {signed char}) signed char {
[build]       signed char val;
[build]       int res = SWIG_AsVal_signed_SS_char($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char *DIRECTOROUT(signed char swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_signed_SS_char($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char {
[build]       signed char swig_val;
[build]       int swig_res = SWIG_AsVal_signed_SS_char($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const signed char& {  
[build]       signed char swig_val;
[build]       int swig_res = SWIG_AsVal_signed_SS_char($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const signed char & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {signed char}) signed char &DIRECTOROUT = signed char
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=25,fragment="SWIG_" "AsVal" "_" {signed char}) signed char, const signed char& {
[build]       int res = SWIG_AsVal_signed_SS_char($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         signed char val; 
[build]         int ecode = SWIG_AsVal_signed_SS_char($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         signed char val;
[build]         int ecode = SWIG_AsVal_signed_SS_char($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") signed char *INPUT, signed char &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=25,fragment="SWIG_" "AsVal" "_" {signed char}) signed char *INPUT, signed char &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_signed_SS_char($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char, const signed char {
[build]       $result = SWIG_From_signed_SS_char((signed char)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {signed char}) const signed char& {
[build]       $result = SWIG_From_signed_SS_char((signed char)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char, const signed char&  {
[build]       $result = SWIG_From_signed_SS_char((signed char)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_signed_SS_char((signed char)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char *DIRECTORIN {
[build]       $input = SWIG_From_signed_SS_char((signed char)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char, const signed char& {
[build]       $input = SWIG_From_signed_SS_char((signed char)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char {
[build]       SWIG_Python_Raise(SWIG_From_signed_SS_char((signed char)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      signed char *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      signed char &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char *OUTPUT, signed char &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_signed_SS_char((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) signed char *INOUT = signed char *INPUT;
[build]    %typemap(in) signed char &INOUT = signed char &INPUT;
[build]    %typemap(typecheck) signed char *INOUT = signed char *INPUT;
[build]    %typemap(typecheck) signed char &INOUT = signed char &INPUT;
[build]    %typemap(argout) signed char *INOUT = signed char *OUTPUT;
[build]    %typemap(argout) signed char &INOUT = signed char &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char (unsigned char val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_unsigned_SS_char($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) unsigned char "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) const unsigned char & ($*ltype temp, unsigned char val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_unsigned_SS_char($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const unsigned char& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char {
[build]       unsigned char val;
[build]       int res = SWIG_AsVal_unsigned_SS_char($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char *DIRECTOROUT(unsigned char swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_unsigned_SS_char($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char {
[build]       unsigned char swig_val;
[build]       int swig_res = SWIG_AsVal_unsigned_SS_char($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const unsigned char& {  
[build]       unsigned char swig_val;
[build]       int swig_res = SWIG_AsVal_unsigned_SS_char($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const unsigned char & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char &DIRECTOROUT = unsigned char
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=20,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char, const unsigned char& {
[build]       int res = SWIG_AsVal_unsigned_SS_char($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         unsigned char val; 
[build]         int ecode = SWIG_AsVal_unsigned_SS_char($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         unsigned char val;
[build]         int ecode = SWIG_AsVal_unsigned_SS_char($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") unsigned char *INPUT, unsigned char &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=20,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char *INPUT, unsigned char &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_unsigned_SS_char($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char, const unsigned char {
[build]       $result = SWIG_From_unsigned_SS_char((unsigned char)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) const unsigned char& {
[build]       $result = SWIG_From_unsigned_SS_char((unsigned char)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char, const unsigned char&  {
[build]       $result = SWIG_From_unsigned_SS_char((unsigned char)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_unsigned_SS_char((unsigned char)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char *DIRECTORIN {
[build]       $input = SWIG_From_unsigned_SS_char((unsigned char)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char, const unsigned char& {
[build]       $input = SWIG_From_unsigned_SS_char((unsigned char)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char {
[build]       SWIG_Python_Raise(SWIG_From_unsigned_SS_char((unsigned char)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      unsigned char *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      unsigned char &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char *OUTPUT, unsigned char &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_char((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) unsigned char *INOUT = unsigned char *INPUT;
[build]    %typemap(in) unsigned char &INOUT = unsigned char &INPUT;
[build]    %typemap(typecheck) unsigned char *INOUT = unsigned char *INPUT;
[build]    %typemap(typecheck) unsigned char &INOUT = unsigned char &INPUT;
[build]    %typemap(argout) unsigned char *INOUT = unsigned char *OUTPUT;
[build]    %typemap(argout) unsigned char &INOUT = unsigned char &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short (short val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_short($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) short "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) const short & ($*ltype temp, short val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_short($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const short& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {short}) short {
[build]       short val;
[build]       int res = SWIG_AsVal_short($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short *DIRECTOROUT(short swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_short($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short {
[build]       short swig_val;
[build]       int swig_res = SWIG_AsVal_short($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {short},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const short& {  
[build]       short swig_val;
[build]       int swig_res = SWIG_AsVal_short($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const short & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {short}) short &DIRECTOROUT = short
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=35,fragment="SWIG_" "AsVal" "_" {short}) short, const short& {
[build]       int res = SWIG_AsVal_short($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         short val; 
[build]         int ecode = SWIG_AsVal_short($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         short val;
[build]         int ecode = SWIG_AsVal_short($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") short *INPUT, short &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=35,fragment="SWIG_" "AsVal" "_" {short}) short *INPUT, short &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_short($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {short}) short, const short {
[build]       $result = SWIG_From_short((short)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {short}) const short& {
[build]       $result = SWIG_From_short((short)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {short}) short, const short&  {
[build]       $result = SWIG_From_short((short)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {short}) short {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_short((short)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {short}) short *DIRECTORIN {
[build]       $input = SWIG_From_short((short)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {short}) short, const short& {
[build]       $input = SWIG_From_short((short)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {short}) short {
[build]       SWIG_Python_Raise(SWIG_From_short((short)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      short *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      short &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {short}) short *OUTPUT, short &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_short((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) short *INOUT = short *INPUT;
[build]    %typemap(in) short &INOUT = short &INPUT;
[build]    %typemap(typecheck) short *INOUT = short *INPUT;
[build]    %typemap(typecheck) short &INOUT = short &INPUT;
[build]    %typemap(argout) short *INOUT = short *OUTPUT;
[build]    %typemap(argout) short &INOUT = short &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short (unsigned short val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) unsigned short "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) const unsigned short & ($*ltype temp, unsigned short val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const unsigned short& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short {
[build]       unsigned short val;
[build]       int res = SWIG_AsVal_unsigned_SS_short($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short *DIRECTOROUT(unsigned short swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_unsigned_SS_short($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short {
[build]       unsigned short swig_val;
[build]       int swig_res = SWIG_AsVal_unsigned_SS_short($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const unsigned short& {  
[build]       unsigned short swig_val;
[build]       int swig_res = SWIG_AsVal_unsigned_SS_short($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const unsigned short & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short &DIRECTOROUT = unsigned short
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=30,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short, const unsigned short& {
[build]       int res = SWIG_AsVal_unsigned_SS_short($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         unsigned short val; 
[build]         int ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         unsigned short val;
[build]         int ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") unsigned short *INPUT, unsigned short &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=30,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short *INPUT, unsigned short &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_unsigned_SS_short($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short, const unsigned short {
[build]       $result = SWIG_From_unsigned_SS_short((unsigned short)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) const unsigned short& {
[build]       $result = SWIG_From_unsigned_SS_short((unsigned short)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short, const unsigned short&  {
[build]       $result = SWIG_From_unsigned_SS_short((unsigned short)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_unsigned_SS_short((unsigned short)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short *DIRECTORIN {
[build]       $input = SWIG_From_unsigned_SS_short((unsigned short)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short, const unsigned short& {
[build]       $input = SWIG_From_unsigned_SS_short((unsigned short)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short {
[build]       SWIG_Python_Raise(SWIG_From_unsigned_SS_short((unsigned short)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      unsigned short *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      unsigned short &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short *OUTPUT, unsigned short &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_short((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) unsigned short *INOUT = unsigned short *INPUT;
[build]    %typemap(in) unsigned short &INOUT = unsigned short &INPUT;
[build]    %typemap(typecheck) unsigned short *INOUT = unsigned short *INPUT;
[build]    %typemap(typecheck) unsigned short &INOUT = unsigned short &INPUT;
[build]    %typemap(argout) unsigned short *INOUT = unsigned short *OUTPUT;
[build]    %typemap(argout) unsigned short &INOUT = unsigned short &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int (int val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_int($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) int "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) const int & ($*ltype temp, int val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_int($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const int& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {int}) int {
[build]       int val;
[build]       int res = SWIG_AsVal_int($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int *DIRECTOROUT(int swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_int($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int {
[build]       int swig_val;
[build]       int swig_res = SWIG_AsVal_int($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {int},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const int& {  
[build]       int swig_val;
[build]       int swig_res = SWIG_AsVal_int($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const int & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {int}) int &DIRECTOROUT = int
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=45,fragment="SWIG_" "AsVal" "_" {int}) int, const int& {
[build]       int res = SWIG_AsVal_int($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         int val; 
[build]         int ecode = SWIG_AsVal_int($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         int val;
[build]         int ecode = SWIG_AsVal_int($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") int *INPUT, int &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=45,fragment="SWIG_" "AsVal" "_" {int}) int *INPUT, int &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_int($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {int}) int, const int {
[build]       $result = SWIG_From_int((int)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {int}) const int& {
[build]       $result = SWIG_From_int((int)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {int}) int, const int&  {
[build]       $result = SWIG_From_int((int)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {int}) int {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_int((int)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {int}) int *DIRECTORIN {
[build]       $input = SWIG_From_int((int)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {int}) int, const int& {
[build]       $input = SWIG_From_int((int)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {int}) int {
[build]       SWIG_Python_Raise(SWIG_From_int((int)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      int *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      int &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {int}) int *OUTPUT, int &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_int((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) int *INOUT = int *INPUT;
[build]    %typemap(in) int &INOUT = int &INPUT;
[build]    %typemap(typecheck) int *INOUT = int *INPUT;
[build]    %typemap(typecheck) int &INOUT = int &INPUT;
[build]    %typemap(argout) int *INOUT = int *OUTPUT;
[build]    %typemap(argout) int &INOUT = int &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int (unsigned int val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) unsigned int "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) const unsigned int & ($*ltype temp, unsigned int val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const unsigned int& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int {
[build]       unsigned int val;
[build]       int res = SWIG_AsVal_unsigned_SS_int($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int *DIRECTOROUT(unsigned int swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_unsigned_SS_int($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int {
[build]       unsigned int swig_val;
[build]       int swig_res = SWIG_AsVal_unsigned_SS_int($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const unsigned int& {  
[build]       unsigned int swig_val;
[build]       int swig_res = SWIG_AsVal_unsigned_SS_int($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const unsigned int & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int &DIRECTOROUT = unsigned int
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=40,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int, const unsigned int& {
[build]       int res = SWIG_AsVal_unsigned_SS_int($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         unsigned int val; 
[build]         int ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         unsigned int val;
[build]         int ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") unsigned int *INPUT, unsigned int &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=40,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int *INPUT, unsigned int &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_unsigned_SS_int($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int, const unsigned int {
[build]       $result = SWIG_From_unsigned_SS_int((unsigned int)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) const unsigned int& {
[build]       $result = SWIG_From_unsigned_SS_int((unsigned int)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int, const unsigned int&  {
[build]       $result = SWIG_From_unsigned_SS_int((unsigned int)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_unsigned_SS_int((unsigned int)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int *DIRECTORIN {
[build]       $input = SWIG_From_unsigned_SS_int((unsigned int)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int, const unsigned int& {
[build]       $input = SWIG_From_unsigned_SS_int((unsigned int)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int {
[build]       SWIG_Python_Raise(SWIG_From_unsigned_SS_int((unsigned int)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      unsigned int *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      unsigned int &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int *OUTPUT, unsigned int &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_int((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) unsigned int *INOUT = unsigned int *INPUT;
[build]    %typemap(in) unsigned int &INOUT = unsigned int &INPUT;
[build]    %typemap(typecheck) unsigned int *INOUT = unsigned int *INPUT;
[build]    %typemap(typecheck) unsigned int &INOUT = unsigned int &INPUT;
[build]    %typemap(argout) unsigned int *INOUT = unsigned int *OUTPUT;
[build]    %typemap(argout) unsigned int &INOUT = unsigned int &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long (long val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_long($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) long "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) const long & ($*ltype temp, long val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_long($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const long& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {long}) long {
[build]       long val;
[build]       int res = SWIG_AsVal_long($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long *DIRECTOROUT(long swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_long($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long {
[build]       long swig_val;
[build]       int swig_res = SWIG_AsVal_long($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {long},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const long& {  
[build]       long swig_val;
[build]       int swig_res = SWIG_AsVal_long($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const long & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {long}) long &DIRECTOROUT = long
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=55,fragment="SWIG_" "AsVal" "_" {long}) long, const long& {
[build]       int res = SWIG_AsVal_long($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         long val; 
[build]         int ecode = SWIG_AsVal_long($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         long val;
[build]         int ecode = SWIG_AsVal_long($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") long *INPUT, long &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=55,fragment="SWIG_" "AsVal" "_" {long}) long *INPUT, long &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_long($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long}) long, const long {
[build]       $result = SWIG_From_long((long)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long}) const long& {
[build]       $result = SWIG_From_long((long)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {long}) long, const long&  {
[build]       $result = SWIG_From_long((long)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {long}) long {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_long((long)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {long}) long *DIRECTORIN {
[build]       $input = SWIG_From_long((long)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {long}) long, const long& {
[build]       $input = SWIG_From_long((long)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {long}) long {
[build]       SWIG_Python_Raise(SWIG_From_long((long)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {long}) long *OUTPUT, long &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_long((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) long *INOUT = long *INPUT;
[build]    %typemap(in) long &INOUT = long &INPUT;
[build]    %typemap(typecheck) long *INOUT = long *INPUT;
[build]    %typemap(typecheck) long &INOUT = long &INPUT;
[build]    %typemap(argout) long *INOUT = long *OUTPUT;
[build]    %typemap(argout) long &INOUT = long &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long (unsigned long val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_unsigned_SS_long($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) unsigned long "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) const unsigned long & ($*ltype temp, unsigned long val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_unsigned_SS_long($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const unsigned long& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long {
[build]       unsigned long val;
[build]       int res = SWIG_AsVal_unsigned_SS_long($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long *DIRECTOROUT(unsigned long swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_unsigned_SS_long($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long {
[build]       unsigned long swig_val;
[build]       int swig_res = SWIG_AsVal_unsigned_SS_long($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const unsigned long& {  
[build]       unsigned long swig_val;
[build]       int swig_res = SWIG_AsVal_unsigned_SS_long($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const unsigned long & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long &DIRECTOROUT = unsigned long
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=50,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long, const unsigned long& {
[build]       int res = SWIG_AsVal_unsigned_SS_long($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         unsigned long val; 
[build]         int ecode = SWIG_AsVal_unsigned_SS_long($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         unsigned long val;
[build]         int ecode = SWIG_AsVal_unsigned_SS_long($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") unsigned long *INPUT, unsigned long &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=50,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long *INPUT, unsigned long &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_unsigned_SS_long($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long, const unsigned long {
[build]       $result = SWIG_From_unsigned_SS_long((unsigned long)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) const unsigned long& {
[build]       $result = SWIG_From_unsigned_SS_long((unsigned long)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long, const unsigned long&  {
[build]       $result = SWIG_From_unsigned_SS_long((unsigned long)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_unsigned_SS_long((unsigned long)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long *DIRECTORIN {
[build]       $input = SWIG_From_unsigned_SS_long((unsigned long)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long, const unsigned long& {
[build]       $input = SWIG_From_unsigned_SS_long((unsigned long)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long {
[build]       SWIG_Python_Raise(SWIG_From_unsigned_SS_long((unsigned long)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      unsigned long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      unsigned long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long *OUTPUT, unsigned long &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_long((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) unsigned long *INOUT = unsigned long *INPUT;
[build]    %typemap(in) unsigned long &INOUT = unsigned long &INPUT;
[build]    %typemap(typecheck) unsigned long *INOUT = unsigned long *INPUT;
[build]    %typemap(typecheck) unsigned long &INOUT = unsigned long &INPUT;
[build]    %typemap(argout) unsigned long *INOUT = unsigned long *OUTPUT;
[build]    %typemap(argout) unsigned long &INOUT = unsigned long &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long (long long val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_long_SS_long($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) long long "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) const long long & ($*ltype temp, long long val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_long_SS_long($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const long long& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {long long}) long long {
[build]       long long val;
[build]       int res = SWIG_AsVal_long_SS_long($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long *DIRECTOROUT(long long swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_long_SS_long($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long {
[build]       long long swig_val;
[build]       int swig_res = SWIG_AsVal_long_SS_long($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {long long},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const long long& {  
[build]       long long swig_val;
[build]       int swig_res = SWIG_AsVal_long_SS_long($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const long long & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {long long}) long long &DIRECTOROUT = long long
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=65,fragment="SWIG_" "AsVal" "_" {long long}) long long, const long long& {
[build]       int res = SWIG_AsVal_long_SS_long($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         long long val; 
[build]         int ecode = SWIG_AsVal_long_SS_long($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         long long val;
[build]         int ecode = SWIG_AsVal_long_SS_long($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") long long *INPUT, long long &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=65,fragment="SWIG_" "AsVal" "_" {long long}) long long *INPUT, long long &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_long_SS_long($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long, const long long {
[build]       $result = SWIG_From_long_SS_long((long long)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long long}) const long long& {
[build]       $result = SWIG_From_long_SS_long((long long)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long, const long long&  {
[build]       $result = SWIG_From_long_SS_long((long long)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_long_SS_long((long long)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long *DIRECTORIN {
[build]       $input = SWIG_From_long_SS_long((long long)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long, const long long& {
[build]       $input = SWIG_From_long_SS_long((long long)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long {
[build]       SWIG_Python_Raise(SWIG_From_long_SS_long((long long)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      long long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      long long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long *OUTPUT, long long &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_long_SS_long((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) long long *INOUT = long long *INPUT;
[build]    %typemap(in) long long &INOUT = long long &INPUT;
[build]    %typemap(typecheck) long long *INOUT = long long *INPUT;
[build]    %typemap(typecheck) long long &INOUT = long long &INPUT;
[build]    %typemap(argout) long long *INOUT = long long *OUTPUT;
[build]    %typemap(argout) long long &INOUT = long long &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long (unsigned long long val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_unsigned_SS_long_SS_long($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) unsigned long long "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) const unsigned long long & ($*ltype temp, unsigned long long val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_unsigned_SS_long_SS_long($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const unsigned long long& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long {
[build]       unsigned long long val;
[build]       int res = SWIG_AsVal_unsigned_SS_long_SS_long($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long *DIRECTOROUT(unsigned long long swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_unsigned_SS_long_SS_long($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long {
[build]       unsigned long long swig_val;
[build]       int swig_res = SWIG_AsVal_unsigned_SS_long_SS_long($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const unsigned long long& {  
[build]       unsigned long long swig_val;
[build]       int swig_res = SWIG_AsVal_unsigned_SS_long_SS_long($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const unsigned long long & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long &DIRECTOROUT = unsigned long long
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=60,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long, const unsigned long long& {
[build]       int res = SWIG_AsVal_unsigned_SS_long_SS_long($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         unsigned long long val; 
[build]         int ecode = SWIG_AsVal_unsigned_SS_long_SS_long($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         unsigned long long val;
[build]         int ecode = SWIG_AsVal_unsigned_SS_long_SS_long($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") unsigned long long *INPUT, unsigned long long &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=60,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long *INPUT, unsigned long long &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_unsigned_SS_long_SS_long($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long, const unsigned long long {
[build]       $result = SWIG_From_unsigned_SS_long_SS_long((unsigned long long)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) const unsigned long long& {
[build]       $result = SWIG_From_unsigned_SS_long_SS_long((unsigned long long)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long, const unsigned long long&  {
[build]       $result = SWIG_From_unsigned_SS_long_SS_long((unsigned long long)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_unsigned_SS_long_SS_long((unsigned long long)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long *DIRECTORIN {
[build]       $input = SWIG_From_unsigned_SS_long_SS_long((unsigned long long)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long, const unsigned long long& {
[build]       $input = SWIG_From_unsigned_SS_long_SS_long((unsigned long long)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long {
[build]       SWIG_Python_Raise(SWIG_From_unsigned_SS_long_SS_long((unsigned long long)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      unsigned long long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      unsigned long long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long *OUTPUT, unsigned long long &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_long_SS_long((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) unsigned long long *INOUT = unsigned long long *INPUT;
[build]    %typemap(in) unsigned long long &INOUT = unsigned long long &INPUT;
[build]    %typemap(typecheck) unsigned long long *INOUT = unsigned long long *INPUT;
[build]    %typemap(typecheck) unsigned long long &INOUT = unsigned long long &INPUT;
[build]    %typemap(argout) unsigned long long *INOUT = unsigned long long *OUTPUT;
[build]    %typemap(argout) unsigned long long &INOUT = unsigned long long &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float (float val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_float($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) float "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) const float & ($*ltype temp, float val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_float($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const float& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {float}) float {
[build]       float val;
[build]       int res = SWIG_AsVal_float($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float *DIRECTOROUT(float swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_float($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float {
[build]       float swig_val;
[build]       int swig_res = SWIG_AsVal_float($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {float},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const float& {  
[build]       float swig_val;
[build]       int swig_res = SWIG_AsVal_float($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const float & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {float}) float &DIRECTOROUT = float
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=80,fragment="SWIG_" "AsVal" "_" {float}) float, const float& {
[build]       int res = SWIG_AsVal_float($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         float val; 
[build]         int ecode = SWIG_AsVal_float($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         float val;
[build]         int ecode = SWIG_AsVal_float($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") float *INPUT, float &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=80,fragment="SWIG_" "AsVal" "_" {float}) float *INPUT, float &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_float($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {float}) float, const float {
[build]       $result = SWIG_From_float((float)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {float}) const float& {
[build]       $result = SWIG_From_float((float)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {float}) float, const float&  {
[build]       $result = SWIG_From_float((float)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {float}) float {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_float((float)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {float}) float *DIRECTORIN {
[build]       $input = SWIG_From_float((float)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {float}) float, const float& {
[build]       $input = SWIG_From_float((float)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {float}) float {
[build]       SWIG_Python_Raise(SWIG_From_float((float)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      float *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      float &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {float}) float *OUTPUT, float &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_float((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) float *INOUT = float *INPUT;
[build]    %typemap(in) float &INOUT = float &INPUT;
[build]    %typemap(typecheck) float *INOUT = float *INPUT;
[build]    %typemap(typecheck) float &INOUT = float &INPUT;
[build]    %typemap(argout) float *INOUT = float *OUTPUT;
[build]    %typemap(argout) float &INOUT = float &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double (double val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_double($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) double "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) const double & ($*ltype temp, double val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_double($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const double& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {double}) double {
[build]       double val;
[build]       int res = SWIG_AsVal_double($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double *DIRECTOROUT(double swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_double($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double {
[build]       double swig_val;
[build]       int swig_res = SWIG_AsVal_double($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {double},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const double& {  
[build]       double swig_val;
[build]       int swig_res = SWIG_AsVal_double($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const double & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {double}) double &DIRECTOROUT = double
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=90,fragment="SWIG_" "AsVal" "_" {double}) double, const double& {
[build]       int res = SWIG_AsVal_double($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         double val; 
[build]         int ecode = SWIG_AsVal_double($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         double val;
[build]         int ecode = SWIG_AsVal_double($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") double *INPUT, double &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=90,fragment="SWIG_" "AsVal" "_" {double}) double *INPUT, double &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_double($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {double}) double, const double {
[build]       $result = SWIG_From_double((double)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {double}) const double& {
[build]       $result = SWIG_From_double((double)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {double}) double, const double&  {
[build]       $result = SWIG_From_double((double)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {double}) double {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_double((double)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {double}) double *DIRECTORIN {
[build]       $input = SWIG_From_double((double)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {double}) double, const double& {
[build]       $input = SWIG_From_double((double)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {double}) double {
[build]       SWIG_Python_Raise(SWIG_From_double((double)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      double *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      double &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {double}) double *OUTPUT, double &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_double((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) double *INOUT = double *INPUT;
[build]    %typemap(in) double &INOUT = double &INPUT;
[build]    %typemap(typecheck) double *INOUT = double *INPUT;
[build]    %typemap(typecheck) double &INOUT = double &INPUT;
[build]    %typemap(argout) double *INOUT = double *OUTPUT;
[build]    %typemap(argout) double &INOUT = double &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char (char val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_char($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) char "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) const char & ($*ltype temp, char val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_char($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const char& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {char}) char {
[build]       char val;
[build]       int res = SWIG_AsVal_char($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char *DIRECTOROUT(char swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_char($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char {
[build]       char swig_val;
[build]       int swig_res = SWIG_AsVal_char($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {char},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const char& {  
[build]       char swig_val;
[build]       int swig_res = SWIG_AsVal_char($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const char & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {char}) char &DIRECTOROUT = char
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=130,fragment="SWIG_" "AsVal" "_" {char}) char, const char& {
[build]       int res = SWIG_AsVal_char($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         char val; 
[build]         int ecode = SWIG_AsVal_char($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         char val;
[build]         int ecode = SWIG_AsVal_char($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") char *INPUT, char &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=130,fragment="SWIG_" "AsVal" "_" {char}) char *INPUT, char &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_char($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {char}) char, const char {
[build]       $result = SWIG_From_char((char)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {char}) const char& {
[build]       $result = SWIG_From_char((char)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {char}) char, const char&  {
[build]       $result = SWIG_From_char((char)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {char}) char {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_char((char)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {char}) char *DIRECTORIN {
[build]       $input = SWIG_From_char((char)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {char}) char, const char& {
[build]       $input = SWIG_From_char((char)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {char}) char {
[build]       SWIG_Python_Raise(SWIG_From_char((char)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      char *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      char &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {char}) char *OUTPUT, char &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_char((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) char *INOUT = char *INPUT;
[build]    %typemap(in) char &INOUT = char &INPUT;
[build]    %typemap(typecheck) char *INOUT = char *INPUT;
[build]    %typemap(typecheck) char &INOUT = char &INPUT;
[build]    %typemap(argout) char *INOUT = char *OUTPUT;
[build]    %typemap(argout) char &INOUT = char &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t (wchar_t val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_wchar_t($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) wchar_t "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) const wchar_t & ($*ltype temp, wchar_t val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_wchar_t($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const wchar_t& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t {
[build]       wchar_t val;
[build]       int res = SWIG_AsVal_wchar_t($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t *DIRECTOROUT(wchar_t swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_wchar_t($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t {
[build]       wchar_t swig_val;
[build]       int swig_res = SWIG_AsVal_wchar_t($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const wchar_t& {  
[build]       wchar_t swig_val;
[build]       int swig_res = SWIG_AsVal_wchar_t($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const wchar_t & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t &DIRECTOROUT = wchar_t
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=110,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t, const wchar_t& {
[build]       int res = SWIG_AsVal_wchar_t($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         wchar_t val; 
[build]         int ecode = SWIG_AsVal_wchar_t($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         wchar_t val;
[build]         int ecode = SWIG_AsVal_wchar_t($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") wchar_t *INPUT, wchar_t &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=110,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t *INPUT, wchar_t &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_wchar_t($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t, const wchar_t {
[build]       $result = SWIG_From_wchar_t((wchar_t)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) const wchar_t& {
[build]       $result = SWIG_From_wchar_t((wchar_t)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t, const wchar_t&  {
[build]       $result = SWIG_From_wchar_t((wchar_t)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_wchar_t((wchar_t)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t *DIRECTORIN {
[build]       $input = SWIG_From_wchar_t((wchar_t)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t, const wchar_t& {
[build]       $input = SWIG_From_wchar_t((wchar_t)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t {
[build]       SWIG_Python_Raise(SWIG_From_wchar_t((wchar_t)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      wchar_t *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      wchar_t &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t *OUTPUT, wchar_t &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_wchar_t((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) wchar_t *INOUT = wchar_t *INPUT;
[build]    %typemap(in) wchar_t &INOUT = wchar_t &INPUT;
[build]    %typemap(typecheck) wchar_t *INOUT = wchar_t *INPUT;
[build]    %typemap(typecheck) wchar_t &INOUT = wchar_t &INPUT;
[build]    %typemap(argout) wchar_t *INOUT = wchar_t *OUTPUT;
[build]    %typemap(argout) wchar_t &INOUT = wchar_t &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t (size_t val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_size_t($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) size_t "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) const size_t & ($*ltype temp, size_t val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_size_t($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const size_t& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {size_t}) size_t {
[build]       size_t val;
[build]       int res = SWIG_AsVal_size_t($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t *DIRECTOROUT(size_t swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_size_t($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t {
[build]       size_t swig_val;
[build]       int swig_res = SWIG_AsVal_size_t($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const size_t& {  
[build]       size_t swig_val;
[build]       int swig_res = SWIG_AsVal_size_t($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const size_t & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {size_t}) size_t &DIRECTOROUT = size_t
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=47,fragment="SWIG_" "AsVal" "_" {size_t}) size_t, const size_t& {
[build]       int res = SWIG_AsVal_size_t($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         size_t val; 
[build]         int ecode = SWIG_AsVal_size_t($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         size_t val;
[build]         int ecode = SWIG_AsVal_size_t($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") size_t *INPUT, size_t &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=47,fragment="SWIG_" "AsVal" "_" {size_t}) size_t *INPUT, size_t &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_size_t($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t, const size_t {
[build]       $result = SWIG_From_size_t((size_t)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {size_t}) const size_t& {
[build]       $result = SWIG_From_size_t((size_t)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t, const size_t&  {
[build]       $result = SWIG_From_size_t((size_t)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_size_t((size_t)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t *DIRECTORIN {
[build]       $input = SWIG_From_size_t((size_t)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t, const size_t& {
[build]       $input = SWIG_From_size_t((size_t)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t {
[build]       SWIG_Python_Raise(SWIG_From_size_t((size_t)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      size_t *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      size_t &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t *OUTPUT, size_t &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_size_t((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) size_t *INOUT = size_t *INPUT;
[build]    %typemap(in) size_t &INOUT = size_t &INPUT;
[build]    %typemap(typecheck) size_t *INOUT = size_t *INPUT;
[build]    %typemap(typecheck) size_t &INOUT = size_t &INPUT;
[build]    %typemap(argout) size_t *INOUT = size_t *OUTPUT;
[build]    %typemap(argout) size_t &INOUT = size_t &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,208,%typemaps_asvalfromn@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,197,%typemaps_asvalfrom@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,171,%typemaps_asval@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,33,%value_in_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t (ptrdiff_t val, int ecode = 0) {
[build]       ecode = SWIG_AsVal_ptrdiff_t($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
[build]       } 
[build]       $1 = ($ltype)(val);
[build]     }
[build]     %typemap(freearg) ptrdiff_t "";
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) const ptrdiff_t & ($*ltype temp, ptrdiff_t val, int ecode = 0) {  
[build]       ecode = SWIG_AsVal_ptrdiff_t($input, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]       } 
[build]       temp = ($*ltype)(val);
[build]       $1 = &temp;
[build]     }
[build]     %typemap(freearg) const ptrdiff_t& "";
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,66,%value_varin_typemap@*/
[build]     %typemap(varin,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t {
[build]       ptrdiff_t val;
[build]       int res = SWIG_AsVal_ptrdiff_t($input, &val);
[build]       if (!SWIG_IsOK(res)) {
[build]         SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]       $1 = ($ltype)(val);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,109,%value_directorout_typemap@*/
[build]     %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t *DIRECTOROUT(ptrdiff_t swig_val, int swig_res) {
[build]       swig_res = SWIG_AsVal_ptrdiff_t($result, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       *$1 = swig_val;
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t {
[build]       ptrdiff_t swig_val;
[build]       int swig_res = SWIG_AsVal_ptrdiff_t($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       }
[build]       $result = ($type)(swig_val);
[build]     }
[build]     %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const ptrdiff_t& {  
[build]       ptrdiff_t swig_val;
[build]       int swig_res = SWIG_AsVal_ptrdiff_t($input, &swig_val);
[build]       if (!SWIG_IsOK(swig_res)) {
[build]         Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
[build]       } 
[build]       $basetype *temp = new $basetype(($basetype)swig_val);
[build]       swig_acquire_ownership(temp);
[build]       $result = temp;
[build]     }
[build]     %typemap(directorfree,noblock=1) const ptrdiff_t & {
[build]       if (director) {
[build]         director->swig_release_ownership(SWIG_as_voidptr($input));
[build]       }
[build]     }
[build]     %typemap(directorout,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t &DIRECTOROUT = ptrdiff_t
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,161,%value_typecheck_typemap@*/
[build]     %typemap(typecheck,precedence=48,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t, const ptrdiff_t& {
[build]       int res = SWIG_AsVal_ptrdiff_t($input, NULL);
[build]       $1 = SWIG_CheckState(res);
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,250,%value_input_typemap@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,79,%_value_input_typemap@*/
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t *INPUT ($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         ptrdiff_t val; 
[build]         int ecode = SWIG_AsVal_ptrdiff_t($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t &INPUT($*ltype temp, int res = 0) {
[build]       if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
[build]         ptrdiff_t val;
[build]         int ecode = SWIG_AsVal_ptrdiff_t($input, &val);
[build]         if (!SWIG_IsOK(ecode)) { 
[build]   	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
[build]         }
[build]         temp = ($*ltype)(val);
[build]         $1 = &temp;
[build]         res = SWIG_AddTmpMask(ecode);
[build]       }
[build]     }
[build]     %typemap(freearg,noblock=1,match="in") ptrdiff_t *INPUT, ptrdiff_t &INPUT {
[build]       if (SWIG_IsNewObj(res$argnum)) free((char*)$1);
[build]     }
[build]     %typemap(typecheck,noblock=1,precedence=48,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t *INPUT, ptrdiff_t &INPUT {
[build]       void *ptr = 0;
[build]       int res = SWIG_AsVal_ptrdiff_t($input, 0);
[build]       $1 = SWIG_CheckState(res);
[build]       if (!$1) {
[build]         $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
[build]       }
[build]     }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,183,%typemaps_from@*/
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,55,%value_out_typemap@*/
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t, const ptrdiff_t {
[build]       $result = SWIG_From_ptrdiff_t((ptrdiff_t)($1)); 
[build]     }
[build]     %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) const ptrdiff_t& {
[build]       $result = SWIG_From_ptrdiff_t((ptrdiff_t)(*$1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,79,%value_varout_typemap@*/
[build]     %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t, const ptrdiff_t&  {
[build]       $result = SWIG_From_ptrdiff_t((ptrdiff_t)($1));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,87,%value_constcode_typemap@*/
[build]     %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t {
[build]       SWIG_Python_SetConstant(d, "$symname",SWIG_From_ptrdiff_t((ptrdiff_t)($value)));
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,98,%value_directorin_typemap@*/
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t *DIRECTORIN {
[build]       $input = SWIG_From_ptrdiff_t((ptrdiff_t)(*$1)); 
[build]     }
[build]     %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t, const ptrdiff_t& {
[build]       $input = SWIG_From_ptrdiff_t((ptrdiff_t)($1)); 
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\valtypes.swg,153,%value_throws_typemap@*/
[build]     %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t {
[build]       SWIG_Python_Raise(SWIG_From_ptrdiff_t((ptrdiff_t)($1)), "$type", 0); SWIG_fail;
[build]     }
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,258,%value_output_typemap@*/		
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,175,%_value_output_typemap@*/
[build]    %typemap(in,numinputs=0,noblock=1) 
[build]      ptrdiff_t *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
[build]      ptrdiff_t &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
[build]      $1 = &temp;
[build]    }
[build]    %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t *OUTPUT, ptrdiff_t &OUTPUT {
[build]      if (SWIG_IsTmpObj(res$argnum)) {
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_From_ptrdiff_t((*$1)));
[build]      } else {
[build]        int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]        $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
[build]      }
[build]    }
[build]   /*@SWIG@*/
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]     /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\inoutlist.swg,230,%_value_inout_typemap@*/
[build]    %typemap(in) ptrdiff_t *INOUT = ptrdiff_t *INPUT;
[build]    %typemap(in) ptrdiff_t &INOUT = ptrdiff_t &INPUT;
[build]    %typemap(typecheck) ptrdiff_t *INOUT = ptrdiff_t *INPUT;
[build]    %typemap(typecheck) ptrdiff_t &INOUT = ptrdiff_t &INPUT;
[build]    %typemap(argout) ptrdiff_t *INOUT = ptrdiff_t *OUTPUT;
[build]    %typemap(argout) ptrdiff_t &INOUT = ptrdiff_t &OUTPUT;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   ;
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/;
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\typemaps\\string.swg" %beginfile
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,285,%ensure_fragment@*/
[build]   %fragment("SWIG_AsCharPtrAndSize","header") {
[build]   #error "SWIG language implementation must provide the SWIG_AsCharPtrAndSize fragment"
[build]   }
[build]   /*@SWIG@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\fragments.swg,285,%ensure_fragment@*/
[build]   %fragment("SWIG_FromCharPtrAndSize","header") {
[build]   #error "SWIG language implementation must provide the SWIG_FromCharPtrAndSize fragment"
[build]   }
[build]   /*@SWIG@*/
[build]   
[build]   %types(char *);
[build]   
[build]   %fragment("SWIG_pchar_descriptor","header") {
[build]   SWIGINTERN swig_type_info*
[build]   SWIG_pchar_descriptor(void)
[build]   {
[build]     static int init = 0;
[build]     static swig_type_info* info = 0;
[build]     if (!init) {
[build]       info = SWIG_TypeQuery("_p_char");
[build]       init = 1;
[build]     }
[build]     return info;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_strnlen","header",fragment="SWIG_FromCharPtrAndSize") {
[build]   SWIGINTERN size_t
[build]   SWIG_strnlen(const char* s, size_t maxlen)
[build]   {
[build]     const char *p;
[build]     for (p = s; maxlen-- && *p; p++)
[build]       ;
[build]     return p - s;
[build]   }
[build]   }
[build]   
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\typemaps\\strings.swg" %beginfile
[build]   //
[build]   // Use the macro SWIG_PRESERVE_CARRAY_SIZE if you prefer to preserve
[build]   // the size of char arrays, ie
[build]   //  ------------------------------------------
[build]   //       C Side             =>   Language Side
[build]   //  ------------------------------------------
[build]   //   char name[5] = "hola"  =>   'hola\0'
[build]   //
[build]   // the default behaviour is 
[build]   //
[build]   //   char name[5] = "hola"  =>   'hola'
[build]   //
[build]   //
[build]   //#define SWIG_PRESERVE_CARRAY_SIZE
[build]   
[build]   /* ------------------------------------------------------------
[build]    *  String typemaps for type Char (char or wchar_t)
[build]    * ------------------------------------------------------------ */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------
[build]    * --- String fragment methods ---
[build]    * ------------------------------------------------------------ */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------
[build]    *  String typemaps and fragments, with default allocators
[build]    * ------------------------------------------------------------ */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------
[build]    *  String typemaps and fragments, with custom allocators
[build]    * ------------------------------------------------------------ */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\strings.swg,611,%typemaps_string@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\strings.swg,503,%_typemap2_string@*/
[build]     
[build]   %fragment("SWIG_From""Char""Ptr","header",fragment="SWIG_FromCharPtrAndSize") {
[build]   SWIGINTERNINLINE PyObject * 
[build]   SWIG_FromCharPtr(const char *cptr)
[build]   { 
[build]     return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_From""Char""Array","header",fragment="SWIG_FromCharPtrAndSize") {
[build]   SWIGINTERNINLINE PyObject * 
[build]   SWIG_FromCharArray(const char *cptr, size_t size)
[build]   { 
[build]     return SWIG_FromCharPtrAndSize(cptr, size);
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_As""Char" "Ptr","header",fragment="SWIG_AsCharPtrAndSize") {
[build]   
[build]   }
[build]   
[build]   %fragment("SWIG_As""Char" "Array","header",fragment="SWIG_AsCharPtrAndSize") {
[build]   SWIGINTERN int
[build]   SWIG_AsCharArray(PyObject * obj, char *val, size_t size)
[build]   { 
[build]     char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
[build]     int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
[build]     if (SWIG_IsOK(res)) {
[build]       /* special case of single char conversion when we don't need space for NUL */
[build]       if (size == 1 && csize == 2 && cptr && !cptr[1]) --csize;
[build]       if (csize <= size) {
[build]         if (val) {
[build]   	if (csize) memcpy(val, cptr, csize*sizeof(char));
[build]   	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
[build]         }
[build]         if (alloc == SWIG_NEWOBJ) {
[build]   	free((char*)cptr);
[build]   	res = SWIG_DelNewMask(res);
[build]         }      
[build]         return res;
[build]       }
[build]       if (alloc == SWIG_NEWOBJ) free((char*)cptr);
[build]     }
[build]     return SWIG_TypeError;
[build]   }
[build]   }
[build]   
[build]   /* char */
[build]   
[build]   %fragment("SWIG_" "From" "_" {char},"header",fragment="SWIG_FromCharPtrAndSize") {
[build]   SWIGINTERNINLINE PyObject *
[build]   SWIG_From_char  (char c) 
[build]   { 
[build]     return SWIG_FromCharPtrAndSize(&c,1);
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "AsVal" "_" {char},"header",
[build]   	  fragment="SWIG_As""Char""Array",
[build]   	  fragment="<limits.h>",
[build]   	  fragment="SWIG_" "AsVal" "_" {long}) {
[build]   SWIGINTERN int
[build]   SWIG_AsVal_char (PyObject * obj, char *val)
[build]   {    
[build]     int res = SWIG_AsCharArray(obj, val, 1);
[build]     if (!SWIG_IsOK(res)) {
[build]       long v;
[build]       res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
[build]       if (SWIG_IsOK(res)) {
[build]         if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
[build]   	if (val) *val = (char)(v);
[build]         } else {
[build]   	res = SWIG_OverflowError;
[build]         }
[build]       }
[build]     }
[build]     return res;
[build]   }
[build]   }
[build]   
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\strings.swg,20,%_typemap_string@*/
[build]   
[build]   /* in */
[build]   
[build]   %typemap(in,noblock=1,fragment="SWIG_AsCharPtr") 
[build]     char * (int res, char *buf = 0, int alloc = 0),
[build]     const char * (int res, char *buf = 0, int alloc = 0) {
[build]     res = SWIG_AsCharPtrAndSize($input, &buf, NULL, &alloc);
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
[build]     }
[build]     $1 = ($1_ltype)(buf);
[build]   }
[build]   %typemap(freearg,noblock=1,match="in") char *, const char * {
[build]     if (alloc$argnum == SWIG_NEWOBJ) free((char*)buf$argnum);
[build]   }
[build]   
[build]   %typemap(in,noblock=1,fragment="SWIG_AsCharPtr") char const*& (int res, char *buf = 0, int alloc = 0) {
[build]     res = SWIG_AsCharPtrAndSize($input, &buf, NULL, &alloc);
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
[build]     }
[build]     $1 = &buf;
[build]   }    
[build]   %typemap(freearg, noblock=1,match="in") char const*& {
[build]     if (alloc$argnum == SWIG_NEWOBJ) free((char*)buf$argnum);
[build]   }
[build]   
[build]   /* out */
[build]   
[build]   %typemap(out,noblock=1,fragment="SWIG_FromCharPtr") char *, const char * {
[build]     $result = SWIG_FromCharPtr((const char *)$1);
[build]   }
[build]   
[build]   
[build]   %typemap(out,noblock=1,fragment="SWIG_FromCharPtr") char const*& {
[build]     $result = SWIG_FromCharPtr(*$1);
[build]   }
[build]   
[build]   %typemap(newfree,noblock=1) char * {
[build]     free((char*)$1);
[build]   }
[build]   
[build]   /* varin */
[build]   
[build]   %typemap(varin,fragment="SWIG_AsCharPtrAndSize") char * {
[build]     char *cptr = 0; size_t csize = 0; int alloc = SWIG_NEWOBJ;
[build]     int res = SWIG_AsCharPtrAndSize($input, &cptr, &csize, &alloc);
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]     }
[build]     if ($1) free((char*)$1);
[build]     if (alloc == SWIG_NEWOBJ) {
[build]       $1 = cptr;
[build]     } else {
[build]       $1 = csize ? ($1_type)(char *)memcpy(malloc((csize)*sizeof(char)), cptr, sizeof(char)*(csize)) : 0;
[build]     }
[build]   }
[build]   
[build]   %typemap(varin,fragment="SWIG_AsCharPtrAndSize",warning=        "451:Setting a const char * variable may leak memory." ) const char * {
[build]     char *cptr = 0; size_t csize = 0; int alloc = SWIG_NEWOBJ;
[build]     int res = SWIG_AsCharPtrAndSize($input, &cptr, &csize, &alloc);
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]     }
[build]     if (alloc == SWIG_NEWOBJ) {
[build]       $1 = cptr;
[build]     } else {
[build]       $1 = csize ? ($1_type)(char *)memcpy(malloc((csize)*sizeof(char)), cptr, sizeof(char)*(csize)) : 0;
[build]     }
[build]   }
[build]   
[build]   /* varout */
[build]   
[build]   %typemap(varout,noblock=1,fragment="SWIG_FromCharPtr") char *, const char * {
[build]     $result = SWIG_FromCharPtr($1);
[build]   }
[build]   
[build]   /* memberin */
[build]   
[build]   %typemap(memberin,noblock=1) char * {
[build]     if ($1) free((char*)$1);
[build]     if ($input) {
[build]       size_t size = strlen((const char *)($input)) + 1;
[build]       $1 = ($1_type)(char *)memcpy(malloc((size)*sizeof(char)), (const char *)($input), sizeof(char)*(size));
[build]     } else {
[build]       $1 = 0;
[build]     }
[build]   }
[build]   
[build]   %typemap(memberin,noblock=1,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
[build]     if ($input) {
[build]       size_t size = strlen((const char *)((const char *)($input))) + 1;
[build]       $1 = ($1_type)(char *)memcpy(malloc((size)*sizeof(char)), $input, sizeof(char)*(size));
[build]     } else {
[build]       $1 = 0;
[build]     }
[build]   }
[build]   
[build]   /* globalin */
[build]   
[build]   %typemap(globalin,noblock=1) char * {
[build]     if ($1) free((char*)$1);
[build]     if ($input) {
[build]       size_t size = strlen((const char *)((const char *)($input))) + 1;
[build]       $1 = ($1_type)(char *)memcpy(malloc((size)*sizeof(char)), $input, sizeof(char)*(size));
[build]     } else {
[build]       $1 = 0;
[build]     }
[build]   }
[build]   
[build]   %typemap(globalin,noblock=1,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
[build]     if ($input) {
[build]       size_t size = strlen($input) + 1;
[build]       $1 = ($1_type)(char *)memcpy(malloc((size)*sizeof(char)), $input, sizeof(char)*(size));
[build]     } else {
[build]       $1 = 0;
[build]     }
[build]   }
[build]   
[build]   /* constant */
[build]   
[build]   %typemap(constcode,noblock=1,fragment="SWIG_FromCharPtr")
[build]     char *, char const*, char * const, char const* const {
[build]     SWIG_Python_SetConstant(d, "$symname",SWIG_FromCharPtr($value));
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   /* directorin */
[build]   
[build]   %typemap(directorin,noblock=1,fragment="SWIG_FromCharPtr")
[build]     char *, char const*, char *const, char const *const, 
[build]     char const *&, char *const &, char const *const & {
[build]     $input = SWIG_FromCharPtr((const char *)$1);
[build]   }
[build]   
[build]   
[build]   /* directorout */
[build]   
[build]   %typemap(directorout,noblock=1,fragment="SWIG_AsCharPtr",warning= "473:Returning a pointer or reference in a director method is not recommended." ) char * (int res, char *buf = 0, int alloc = SWIG_NEWOBJ) {
[build]     res = SWIG_AsCharPtrAndSize($input, &buf, NULL, &alloc);
[build]     if (!SWIG_IsOK(res)) {
[build]       Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(res)), "in output value of type '""$type""'");
[build]     }
[build]     if (alloc == SWIG_NEWOBJ) {
[build]       swig_acquire_ownership_array(buf);
[build]     }
[build]     $result = ($1_ltype)(buf);
[build]   }
[build]   %typemap(directorfree,noblock=1) char *
[build]   {
[build]     if (director) {
[build]       director->swig_release_ownership(SWIG_as_voidptr($input));
[build]     }
[build]   }
[build]   
[build]   
[build]   %typemap(directorout,noblock=1,fragment="SWIG_AsCharPtr",warning= "473:Returning a pointer or reference in a director method is not recommended." ) char *const& (int res, char *buf = 0, int alloc = SWIG_NEWOBJ), char const*const& (int res, char *buf = 0, int alloc = SWIG_NEWOBJ) { 
[build]     res = SWIG_AsCharPtrAndSize($input, &buf, NULL, &alloc);
[build]     if (!SWIG_IsOK(res)) {
[build]       Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(res)), "in output value of type '""$type""'");
[build]     }
[build]     static $*1_ltype tmp = buf;
[build]     $result = &tmp;
[build]     if (alloc == SWIG_NEWOBJ) {
[build]       swig_acquire_ownership_array(buf);
[build]     }
[build]   }
[build]   %typemap(directorfree,noblock=1)
[build]     char * const&, char const* const& {
[build]     if (director) {
[build]       director->swig_release_ownership(SWIG_as_voidptr(*$input));
[build]     }
[build]   }
[build]   
[build]   
[build]   
[build]   /* typecheck */
[build]   
[build]   %typemap(typecheck,noblock=1,precedence=140,
[build]   	 fragment="SWIG_AsCharPtr") char *, const char *, char const*& {
[build]     int res = SWIG_AsCharPtrAndSize($input, 0, NULL, 0);
[build]     $1 = SWIG_CheckState(res);
[build]   }
[build]   
[build]   
[build]   /* throws */
[build]   
[build]   %typemap(throws,noblock=1,fragment="SWIG_FromCharPtr") char * {
[build]     SWIG_Python_Raise(SWIG_FromCharPtr($1), "$type", 0); SWIG_fail;
[build]   }
[build]   
[build]   
[build]   /* ------------------------------------------------------------
[build]    *  Unknown size const Character array char[ANY] handling
[build]    * ------------------------------------------------------------ */
[build]   
[build]   %apply char * { char [] };
[build]   %apply const char * { const char [] };
[build]   
[build]   %typemap(varin,noblock=1,warning="462:Unable to set variable of type char []") char []
[build]   {
[build]     SWIG_exception_fail(SWIG_ArgError(SWIG_AttributeError), "in variable '""read-only $name""' of type '""$type""'");
[build]   }
[build]   
[build]   
[build]   /* ------------------------------------------------------------
[build]    *  Fixed size Character array char[ANY] handling
[build]    * ------------------------------------------------------------ */
[build]   
[build]   /*  memberin and globalin typemaps  */
[build]   
[build]   %typemap(memberin,noblock=1) char [ANY]
[build]   {
[build]     if ($input) memcpy($1,$input,$1_dim0*sizeof(char));
[build]     else memset($1,0,$1_dim0*sizeof(char));
[build]   }
[build]   
[build]   %typemap(globalin,noblock=1) char [ANY]
[build]   {
[build]     if ($input) memcpy($1,$input,$1_dim0*sizeof(char));
[build]     else memset($1,0,$1_dim0*sizeof(char));
[build]   }
[build]   
[build]   /* in */
[build]   
[build]   %typemap(in,noblock=1,fragment="SWIG_AsCharArray")
[build]     char [ANY] (char temp[$1_dim0], int res), 
[build]     const char [ANY](char temp[$1_dim0], int res)
[build]   {  
[build]     res = SWIG_AsCharArray($input, temp, $1_dim0);
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
[build]     }
[build]     $1 = ($1_ltype)(temp);
[build]   }
[build]   %typemap(freearg) char [ANY], const char [ANY] "";
[build]   
[build]   %typemap(in,noblock=1,fragment="SWIG_AsCharArray") const char (&)[ANY] (char temp[$1_dim0], int res)
[build]   {  
[build]     res = SWIG_AsCharArray($input, temp, $1_dim0);
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
[build]     }
[build]     $1 = &temp;
[build]   }
[build]   %typemap(freearg) const char (&)[ANY] "";
[build]   
[build]   %typemap(out,fragment="SWIG_FromCharPtrAndSize",fragment="SWIG_strnlen")
[build]     char [ANY], const char[ANY] 
[build]   {
[build]   
[build]     size_t size = SWIG_strnlen($1, $1_dim0);
[build]   
[build]   
[build]   
[build]      $result = SWIG_FromCharPtrAndSize($1, size);
[build]   }
[build]   
[build]   /* varin */
[build]   
[build]   %typemap(varin,fragment="SWIG_AsCharArray") char [ANY]
[build]   {
[build]     int res = SWIG_AsCharArray($input, $1, $1_dim0);
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
[build]     }
[build]   }
[build]   
[build]   /* varout */
[build]   
[build]   %typemap(varout,fragment="SWIG_strnlen")
[build]     char [ANY], const char [ANY] {
[build]   
[build]     size_t size = SWIG_strnlen($1, $1_dim0);
[build]   
[build]   
[build]   
[build]     $result = SWIG_FromCharPtrAndSize($1, size);
[build]   }
[build]   
[build]   /* constant */
[build]   
[build]   %typemap(constcode,fragment="SWIG_strnlen")
[build]     char [ANY], const char [ANY]
[build]   {
[build]   
[build]     size_t size = SWIG_strnlen($1, $1_dim0);
[build]   
[build]   
[build]   
[build]     SWIG_Python_SetConstant(d, "$symname",SWIG_FromCharPtrAndSize($value,size));
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   /* directorin */
[build]   %typemap(directorin,fragment="SWIG_strnlen")
[build]     char [ANY], const char [ANY] 
[build]   {
[build]   
[build]     size_t size = SWIG_strnlen($1, $1_dim0);
[build]   
[build]   
[build]   
[build]     $input = SWIG_FromCharPtrAndSize($1, size);
[build]   }
[build]   
[build]   /* directorout */
[build]   
[build]   %typemap(directorout,noblock=1,fragment="SWIG_AsCharArray")
[build]     char [ANY] (char temp[$result_dim0]),
[build]     const char [ANY] (char temp[$result_dim0], int res)
[build]   { 
[build]     res = SWIG_AsCharArray($input, temp, $result_dim0);
[build]     if (!SWIG_IsOK(res)) {
[build]       Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(res)), "in output value of type '""$type""'");
[build]     }
[build]     $result = temp;
[build]   }
[build]   
[build]   
[build]   
[build]   /* typecheck */
[build]   
[build]   %typemap(typecheck,noblock=1,precedence=140,
[build]   	 fragment="SWIG_AsCharArray")  
[build]     char [ANY], const char[ANY] {
[build]     int res = SWIG_AsCharArray($input, (char *)0, $1_dim0);
[build]     $1 = SWIG_CheckState(res);
[build]   }
[build]   
[build]   
[build]   /* throws */
[build]   
[build]   %typemap(throws,fragment="SWIG_strnlen")
[build]     char [ANY], const char[ANY]
[build]   {
[build]   
[build]     size_t size = SWIG_strnlen($1, $1_dim0);
[build]   
[build]   
[build]   
[build]     SWIG_Python_Raise(SWIG_FromCharPtrAndSize($1, size), "$type", 0); SWIG_fail; 
[build]   }
[build]   
[build]   /* -------------------------------------------------------------------
[build]    * --- Really fix size char arrays, including '\0'chars at the end ---
[build]    * ------------------------------------------------------------------- */
[build]   
[build]   %typemap(varout,noblock=1,fragment="SWIG_FromCharPtrAndSize")
[build]     char FIXSIZE[ANY], const char FIXSIZE[ANY]
[build]   {
[build]     $result = SWIG_FromCharPtrAndSize($1, $1_dim0);
[build]   }
[build]   
[build]   %typemap(out,noblock=1,fragment="SWIG_FromCharPtrAndSize")
[build]     char FIXSIZE[ANY], const char FIXSIZE[ANY]
[build]   {
[build]     $result = SWIG_FromCharPtrAndSize($1, $1_dim0);
[build]   }
[build]   
[build]   
[build]   
[build]   %typemap(directorin,noblock=1,fragment="SWIG_FromCharPtrAndSize")
[build]     char FIXSIZE[ANY], const char FIXSIZE[ANY]
[build]   {
[build]     $input = SWIG_FromCharPtrAndSize($1, $1_dim0);
[build]   }
[build]   
[build]   
[build]   
[build]   %typemap(throws,noblock=1,fragment="SWIG_FromCharPtrAndSize")
[build]     char FIXSIZE[ANY], const char FIXSIZE[ANY] {
[build]     SWIG_Python_Raise(SWIG_FromCharPtrAndSize($1, $1_dim0), "$type", 0); SWIG_fail; 
[build]   }
[build]   
[build]   /* ------------------------------------------------------------
[build]    * --- String & length ---
[build]    * ------------------------------------------------------------ */
[build]   
[build]   /* Here len doesn't include the '0' terminator */
[build]   %typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize") 
[build]     (char *STRING, size_t LENGTH) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
[build]     (const char *STRING, size_t LENGTH) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
[build]   {
[build]     res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
[build]     if (!SWIG_IsOK(res)) { 
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
[build]     }  
[build]     $1 = ($1_ltype)(buf);
[build]     $2 = ($2_ltype)(size - 1);
[build]   }
[build]   %typemap(freearg,noblock=1,match="in") (char *STRING, size_t LENGTH) {
[build]     if (alloc$argnum == SWIG_NEWOBJ) free((char*)buf$argnum);
[build]   }
[build]   /* old 'int' form */
[build]   %typemap(in) (char *STRING, int LENGTH) = (char *STRING, size_t LENGTH);
[build]   %typemap(freearg) (char *STRING, int LENGTH) = (char *STRING, size_t LENGTH);
[build]   
[build]   
[build]   /* Here size includes the '0' terminator */
[build]   %typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize")
[build]     (char *STRING, size_t SIZE) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
[build]     (const char *STRING, size_t SIZE) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
[build]   {
[build]     res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
[build]     }
[build]     $1 = ($1_ltype)(buf);
[build]     $2 = ($2_ltype)(size);
[build]   }
[build]   %typemap(freearg,noblock=1,match="in") (char *STRING, size_t SIZE) {
[build]     if (alloc$argnum == SWIG_NEWOBJ) free((char*)buf$argnum);
[build]   }
[build]   /* old 'int' form */
[build]   %typemap(in) (char *STRING, int SIZE) = (char *STRING, size_t SIZE);
[build]   %typemap(freearg) (char *STRING, int SIZE) = (char *STRING, size_t SIZE);
[build]   
[build]   
[build]   /* reverse order versions */
[build]   
[build]   /* Here len doesn't include the '0' terminator */
[build]   %typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize") 
[build]     (size_t LENGTH, char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
[build]     (size_t LENGTH, const char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
[build]   {
[build]     res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
[build]     if (!SWIG_IsOK(res)) { 
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
[build]     }  
[build]     $2 = ($2_ltype)(buf) ;
[build]     $1 = ($1_ltype)(size - 1) ;
[build]   }
[build]   %typemap(freearg, noblock=1, match="in") (size_t LENGTH, char *STRING) {
[build]     if (alloc$argnum == SWIG_NEWOBJ) free((char*)buf$argnum);
[build]   }
[build]   /* old 'int' form */
[build]   %typemap(in) (int LENGTH, char *STRING) = (size_t LENGTH, char *STRING);
[build]   %typemap(freearg) (int LENGTH, char *STRING) = (size_t LENGTH, char *STRING);
[build]   
[build]   /* Here size includes the '0' terminator */
[build]   %typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize")
[build]     (size_t SIZE, char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
[build]     (size_t SIZE, const char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
[build]   {
[build]     res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
[build]     if (!SWIG_IsOK(res)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
[build]     }
[build]     $2 = ($2_ltype)(buf) ;
[build]     $1 = ($1_ltype)(size) ;
[build]   }
[build]   %typemap(freearg, noblock=1, match="in") (size_t SIZE, char *STRING) {
[build]     if (alloc$argnum == SWIG_NEWOBJ) free((char*)buf$argnum);
[build]   }
[build]   /* old 'int' form */
[build]   %typemap(in) (int SIZE, char *STRING) = (size_t SIZE, char *STRING);
[build]   %typemap(freearg) (int SIZE, char *STRING) = (size_t SIZE, char *STRING);
[build]   
[build]   
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*@SWIG@*/
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\typemaps\\misctypes.swg" %beginfile
[build]   
[build]   /* ------------------------------------------------------------
[build]    * --- ANSI/Posix C/C++ types ---
[build]    * ------------------------------------------------------------ */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\typemaps\\enumint.swg" %beginfile
[build]   /* ------------------------------------------------------------
[build]    *  Enums mapped as integer values
[build]    * ------------------------------------------------------------ */
[build]   
[build]   %apply int { enum SWIGTYPE };
[build]   %apply const int& { const enum SWIGTYPE & };
[build]   %apply const int& { const enum SWIGTYPE && };
[build]   
[build]   %typemap(in,fragment="SWIG_" "AsVal" "_" {int},noblock=1) const enum SWIGTYPE & (int val, int ecode, $basetype temp) {  
[build]     ecode = SWIG_AsVal_int ($input, &val);
[build]     if (!SWIG_IsOK(ecode)) {
[build]       SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
[build]     } else {
[build]       temp = ($basetype)(val);
[build]       $1 = &temp;
[build]     }
[build]   }
[build]   
[build]   %typemap(in,fragment="SWIG_" "AsVal" "_" {int},noblock=1) const enum SWIGTYPE && (int val, int ecode, $basetype temp) {  
[build]     ecode = SWIG_AsVal_int ($input, &val);
[build]     if (!SWIG_IsOK(ecode)) {
[build]       SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
[build]     } else {
[build]       temp = ($basetype)(val);
[build]       $1 = &temp;
[build]     }
[build]   }
[build]   
[build]   %typemap(varin,fragment="SWIG_" "AsVal" "_" {int},noblock=1) enum SWIGTYPE {
[build]     if (sizeof(int) != sizeof($1)) {
[build]       SWIG_exception_fail(SWIG_ArgError(SWIG_AttributeError), "in variable '""arch, read-only $name""' of type '""$type""'");
[build]     }  else {
[build]       int ecode = SWIG_AsVal_int ($input, (int*)(&$1));
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in variable '""$name""' of type '""$type""'");
[build]       }
[build]     }
[build]   }
[build]   
[build]   %endoffile
[build]   
[build]   
[build]   %endoffile
[build]   
[build]   
[build]   /*  ------------------------------------------------------------
[build]    *  Python extra typemaps / typemap overrides
[build]    * ------------------------------------------------------------ */
[build]   
[build]   /* Get the address of the 'python self' object */
[build]   
[build]   %typemap(in,numinputs=0,noblock=1) PyObject **PYTHON_SELF {
[build]     $1 = &$self;
[build]   }
[build]   
[build]   
[build]   /* Consttab, needed for callbacks, it should be removed later */
[build]   
[build]   %typemap(consttab) SWIGTYPE ((*)(ANY))
[build]   { SWIG_PY_POINTER, (char*)"$symname", 0, 0, (void *)($value), &$descriptor }
[build]   %typemap(consttab) SWIGTYPE ((* const)(ANY)) = SWIGTYPE ((*)(ANY));
[build]   
[build]   %typemap(constcode) SWIGTYPE ((*)(ANY)) "";
[build]   %typemap(constcode) SWIGTYPE ((* const)(ANY)) = SWIGTYPE ((*)(ANY));
[build]   
[build]   
[build]   /* Smart Pointers */
[build]   %typemap(out,noblock=1) const SWIGTYPE & SMARTPOINTER  {
[build]     $result = SWIG_NewPointerObj(($*ltype *)memcpy(($*ltype *)calloc(1,sizeof($*ltype)),&*$1,sizeof($*ltype)), $descriptor, SWIG_POINTER_OWN |  0 );
[build]   }
[build]   
[build]   %typemap(ret,noblock=1) const SWIGTYPE & SMARTPOINTER, SWIGTYPE SMARTPOINTER {
[build]     if ($result) {
[build]       PyObject *robj = PyObject_CallMethod($result, (char *)"__deref__", NULL);
[build]       if (robj && !PyErr_Occurred()) {
[build]         SwigPyObject_append((PyObject *) SWIG_Python_GetSwigThis($result), 
[build]   			  (PyObject *) SWIG_Python_GetSwigThis(robj));
[build]         Py_DECREF(robj);
[build]       }
[build]     }
[build]   }
[build]   
[build]   %endoffile
[build]   
[build]   /* ------------------------------------------------------------
[build]    *  Overloaded operator support
[build]    * ------------------------------------------------------------ */
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\python\\pyopers.swg" %beginfile
[build]   /* ------------------------------------------------------------
[build]    * Overloaded operator support
[build]   
[build]    The directives in this file apply whether or not you use the
[build]    -builtin option to SWIG, but operator overloads are particularly
[build]    attractive when using -builtin, because they are much faster
[build]    than named methods.
[build]   
[build]    If you're using the -builtin option to SWIG, and you want to define
[build]    python operator overloads beyond the defaults defined in this file,
[build]    here's what you need to know:
[build]   
[build]    There are two ways to define a python slot function: dispatch to a
[build]    statically defined function; or dispatch to a method defined on the
[build]    operand.
[build]   
[build]    To dispatch to a statically defined function, use %feature("python:<slot>"),
[build]    where <slot> is the name of a field in a PyTypeObject, PyNumberMethods,
[build]    PyMappingMethods, PySequenceMethods, or PyBufferProcs.  For example:
[build]   
[build]      %feature("python:tp_hash") MyClass "myHashFunc";
[build]   
[build]      class MyClass {
[build]        public:
[build]          ...
[build]      };
[build]   
[build]      %{
[build]        // Note: Py_hash_t was introduced in Python 3.2
[build]        static Py_hash_t myHashFunc(PyObject *pyobj) {
[build]          MyClass *cobj;
[build]          // Convert pyobj to cobj
[build]          return (cobj->field1 * (cobj->field2 << 7));
[build]        }
[build]      %}
[build]   
[build]    NOTE: It is the responsibility of the programmer (that's you) to ensure
[build]    that a statically defined slot function has the correct signature.
[build]   
[build]    If, instead, you want to dispatch to an instance method, you can
[build]    use %feature("python:slot").  For example:
[build]   
[build]      %feature("python:slot", "tp_hash", functype="hashfunc") MyClass::myHashFunc;
[build]   
[build]      class MyClass {
[build]        public:
[build]          Py_hash_t myHashFunc () const;
[build]          ...
[build]      };
[build]   
[build]    NOTE: Some python slots use a method signature which does not
[build]    match the signature of SWIG-wrapped methods.  For those slots,
[build]    SWIG will automatically generate a "closure" function to re-marshall
[build]    the arguments before dispatching to the wrapped method.  Setting
[build]    the "functype" attribute of the feature enables SWIG to generate
[build]    a correct closure function.
[build]   
[build]    --------------------------------------------------------------
[build]   
[build]    The tp_richcompare slot is a special case: SWIG automatically generates
[build]    a rich compare function for all wrapped types.  If a type defines C++
[build]    operator overloads for comparison (operator==, operator<, etc.), they
[build]    will be called from the generated rich compare function.  If you
[build]    want to explicitly choose a method to handle a certain comparison
[build]    operation, you may use a different feature, %feature("python:compare")
[build]    like this:
[build]   
[build]      %feature("python:compare", "Py_LT") MyClass::lessThan;
[build]   
[build]      class MyClass {
[build]        public:
[build]          bool lessThan(const MyClass& other) const;
[build]          ...
[build]      };
[build]      
[build]    ... where "Py_LT" is one of the rich comparison opcodes defined in the
[build]    python header file object.h.
[build]   
[build]    If there's no method defined to handle a particular comparison operation,
[build]    the default behavior is to compare pointer values of the wrapped
[build]    C++ objects.
[build]   
[build]    --------------------------------------------------------------
[build]   
[build]   
[build]    For more information about python slots, including their names and
[build]    signatures, you may refer to the python documentation :
[build]   
[build]      http://docs.python.org/c-api/typeobj.html
[build]   
[build]    * ------------------------------------------------------------ */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   
[build]   /* ------------------------------------------------------------
[build]    * Warnings for Python keywords 
[build]    * ------------------------------------------------------------ */
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\python\\pythonkw.swg" %beginfile
[build]   /*
[build]     Warnings for Python keywords, built-in names and bad names.
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*
[build]     Warnings for Python keywords 
[build]     https://docs.python.org/2/reference/lexical_analysis.html#keywords
[build]   */
[build]   
[build]   %namewarn("314"":""'" "and" "' is a python keyword, renaming to '_" "and" "'",rename="_%s")  "and";
[build]   %namewarn("314"":""'" "as" "' is a python keyword, renaming to '_" "as" "'",rename="_%s")  "as";
[build]   %namewarn("314"":""'" "assert" "' is a python keyword, renaming to '_" "assert" "'",rename="_%s")  "assert";
[build]   %namewarn("314"":""'" "break" "' is a python keyword, renaming to '_" "break" "'",rename="_%s")  "break";
[build]   %namewarn("314"":""'" "class" "' is a python keyword, renaming to '_" "class" "'",rename="_%s")  "class";
[build]   %namewarn("314"":""'" "continue" "' is a python keyword, renaming to '_" "continue" "'",rename="_%s")  "continue";
[build]   %namewarn("314"":""'" "def" "' is a python keyword, renaming to '_" "def" "'",rename="_%s")  "def";
[build]   %namewarn("314"":""'" "del" "' is a python keyword, renaming to '_" "del" "'",rename="_%s")  "del";
[build]   %namewarn("314"":""'" "elif" "' is a python keyword, renaming to '_" "elif" "'",rename="_%s")  "elif";
[build]   %namewarn("314"":""'" "else" "' is a python keyword, renaming to '_" "else" "'",rename="_%s")  "else";
[build]   %namewarn("314"":""'" "except" "' is a python keyword, renaming to '_" "except" "'",rename="_%s")  "except";
[build]   %namewarn("314"":""'" "exec" "' is a python keyword, renaming to '_" "exec" "'",rename="_%s")  "exec";
[build]   %namewarn("314"":""'" "finally" "' is a python keyword, renaming to '_" "finally" "'",rename="_%s")  "finally";
[build]   %namewarn("314"":""'" "for" "' is a python keyword, renaming to '_" "for" "'",rename="_%s")  "for";
[build]   %namewarn("314"":""'" "from" "' is a python keyword, renaming to '_" "from" "'",rename="_%s")  "from";
[build]   %namewarn("314"":""'" "global" "' is a python keyword, renaming to '_" "global" "'",rename="_%s")  "global";
[build]   %namewarn("314"":""'" "if" "' is a python keyword, renaming to '_" "if" "'",rename="_%s")  "if";
[build]   %namewarn("314"":""'" "import" "' is a python keyword, renaming to '_" "import" "'",rename="_%s")  "import";
[build]   %namewarn("314"":""'" "in" "' is a python keyword, renaming to '_" "in" "'",rename="_%s")  "in";
[build]   %namewarn("314"":""'" "is" "' is a python keyword, renaming to '_" "is" "'",rename="_%s")  "is";
[build]   %namewarn("314"":""'" "lambda" "' is a python keyword, renaming to '_" "lambda" "'",rename="_%s")  "lambda";
[build]   %namewarn("314"":""'" "not" "' is a python keyword, renaming to '_" "not" "'",rename="_%s")  "not";
[build]   %namewarn("314"":""'" "or" "' is a python keyword, renaming to '_" "or" "'",rename="_%s")  "or";
[build]   %namewarn("314"":""'" "pass" "' is a python keyword, renaming to '_" "pass" "'",rename="_%s")  "pass";
[build]   %namewarn("314"":""'" "print" "' is a python keyword, renaming to '_" "print" "'",rename="_%s")  "print";
[build]   %namewarn("314"":""'" "raise" "' is a python keyword, renaming to '_" "raise" "'",rename="_%s")  "raise";
[build]   %namewarn("314"":""'" "return" "' is a python keyword, renaming to '_" "return" "'",rename="_%s")  "return";
[build]   %namewarn("314"":""'" "try" "' is a python keyword, renaming to '_" "try" "'",rename="_%s")  "try";
[build]   %namewarn("314"":""'" "while" "' is a python keyword, renaming to '_" "while" "'",rename="_%s")  "while";
[build]   %namewarn("314"":""'" "with" "' is a python keyword, renaming to '_" "with" "'",rename="_%s")  "with";
[build]   %namewarn("314"":""'" "yield" "' is a python keyword, renaming to '_" "yield" "'",rename="_%s")  "yield";
[build]   
[build]   /*
[build]     built-in functions
[build]     https://docs.python.org/2/library/functions.html
[build]    */ 
[build]   
[build]   %namewarn("321"":""'" "abs" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "abs";
[build]   %namewarn("321"":""'" "apply" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "apply";
[build]   %namewarn("321"":""'" "bool" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "bool";
[build]   %namewarn("321"":""'" "buffer" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "buffer";
[build]   %namewarn("321"":""'" "callable" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "callable";
[build]   %namewarn("321"":""'" "chr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "chr";
[build]   %namewarn("321"":""'" "classmethod" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "classmethod";
[build]   %namewarn("321"":""'" "cmp" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "cmp";
[build]   %namewarn("321"":""'" "coerce" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "coerce";
[build]   %namewarn("321"":""'" "compile" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "compile";
[build]   %namewarn("321"":""'" "complex" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "complex";
[build]   %namewarn("321"":""'" "delattr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "delattr";
[build]   %namewarn("321"":""'" "dict" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "dict";
[build]   %namewarn("321"":""'" "dir" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "dir";
[build]   %namewarn("321"":""'" "divmod" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "divmod";
[build]   %namewarn("321"":""'" "enumerate" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "enumerate";
[build]   %namewarn("321"":""'" "eval" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "eval";
[build]   %namewarn("321"":""'" "execfile" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "execfile";
[build]   %namewarn("321"":""'" "file" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "file";
[build]   %namewarn("321"":""'" "filter" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "filter";
[build]   %namewarn("321"":""'" "float" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "float";
[build]   %namewarn("321"":""'" "frozenset" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "frozenset";
[build]   %namewarn("321"":""'" "getattr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "getattr";
[build]   %namewarn("321"":""'" "globals" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "globals";
[build]   %namewarn("321"":""'" "hasattr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "hasattr";
[build]   %namewarn("321"":""'" "hash" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "hash";
[build]   %namewarn("321"":""'" "hex" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "hex";
[build]   %namewarn("321"":""'" "id" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "id";
[build]   %namewarn("321"":""'" "input" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "input";
[build]   %namewarn("321"":""'" "int" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "int";
[build]   %namewarn("321"":""'" "intern" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "intern";
[build]   %namewarn("321"":""'" "isinstance" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "isinstance";
[build]   %namewarn("321"":""'" "issubclass" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "issubclass";
[build]   %namewarn("321"":""'" "iter" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "iter";
[build]   %namewarn("321"":""'" "len" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "len";
[build]   %namewarn("321"":""'" "list" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "list";
[build]   %namewarn("321"":""'" "locals" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "locals";
[build]   %namewarn("321"":""'" "long" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "long";
[build]   %namewarn("321"":""'" "map" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "map";
[build]   %namewarn("321"":""'" "max" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "max";
[build]   %namewarn("321"":""'" "min" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "min";
[build]   %namewarn("321"":""'" "object" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "object";
[build]   %namewarn("321"":""'" "oct" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "oct";
[build]   %namewarn("321"":""'" "open" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "open";
[build]   %namewarn("321"":""'" "ord" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "ord";
[build]   %namewarn("321"":""'" "pow" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "pow";
[build]   %namewarn("321"":""'" "property" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "property";
[build]   %namewarn("321"":""'" "range" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "range";
[build]   %namewarn("321"":""'" "raw_input" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "raw_input";
[build]   %namewarn("321"":""'" "reduce" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "reduce";
[build]   %namewarn("321"":""'" "reload" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "reload";
[build]   %namewarn("321"":""'" "repr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "repr";
[build]   %namewarn("321"":""'" "reversed" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "reversed";
[build]   %namewarn("321"":""'" "round" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "round";
[build]   %namewarn("321"":""'" "set" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "set";
[build]   %namewarn("321"":""'" "setattr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "setattr";
[build]   %namewarn("321"":""'" "slice" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "slice";
[build]   %namewarn("321"":""'" "sorted" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "sorted";
[build]   %namewarn("321"":""'" "staticmethod" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "staticmethod";
[build]   %namewarn("321"":""'" "str" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "str";
[build]   %namewarn("321"":""'" "sum" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "sum";
[build]   %namewarn("321"":""'" "super" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "super";
[build]   %namewarn("321"":""'" "tuple" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "tuple";
[build]   %namewarn("321"":""'" "type" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "type";
[build]   %namewarn("321"":""'" "unichr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "unichr";
[build]   %namewarn("321"":""'" "unicode" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "unicode";
[build]   %namewarn("321"":""'" "vars" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "vars";
[build]   %namewarn("321"":""'" "xrange" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "xrange";
[build]   %namewarn("321"":""'" "zip" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "zip";
[build]   
[build]   
[build]   /* 
[build]      built-in names
[build]      boolean type and None
[build]   */
[build]   %namewarn("321"":""'" "True" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "True";
[build]   %namewarn("321"":""'" "False" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "False";
[build]   
[build]   %namewarn("314"":""'" "None" "' is a python keyword, renaming to '_" "None" "'",rename="_%s")  "None";
[build]   
[build]   
[build]   /* 
[build]      'self' is also a bad Name
[build]   */
[build]   %namewarn("314"":""'" "self" "' is a python keyword, renaming to '_" "self" "'",rename="_%s")  "self";
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   
[build]   /* ------------------------------------------------------------
[build]    * The Python autodoc support
[build]    * ------------------------------------------------------------ */
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\python\\pydocs.swg" %beginfile
[build]   
[build]   // Documentation for use with the autodoc feature.
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %typemap(doc) SWIGTYPE "$1_name: $1_type";
[build]   %typemap(doc) SWIGTYPE * "$1_name: $1_type";
[build]   %typemap(doc) const SWIGTYPE & "$1_name: $1_type";
[build]   %typemap(doc) const SWIGTYPE && "$1_name: $1_type";
[build]   %typemap(doc) enum SWIGTYPE "$1_name: enum $1_type";
[build]   
[build]   %typemap(doc) SWIGTYPE *INOUT, SWIGTYPE &INOUT "$1_name: $1_type (input/output)";
[build]   %typemap(doc) SWIGTYPE *INPUT, SWIGTYPE &INPUT "$1_name: $1_type (input)";
[build]   %typemap(doc) SWIGTYPE *OUTPUT, SWIGTYPE &OUTPUT "$1_name: $1_type (output)";
[build]   
[build]   %endoffile
[build]   
[build]   /* ------------------------------------------------------------
[build]    * The Python classes, for C++
[build]    * ------------------------------------------------------------ */
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\python\\pyclasses.swg" %beginfile
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   
[build]   /* ------------------------------------------------------------
[build]    * The Python initialization function 
[build]    * ------------------------------------------------------------ */
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\python\\pyinit.swg" %beginfile
[build]   /* ------------------------------------------------------------
[build]    * The start of the Python initialization function 
[build]    * ------------------------------------------------------------ */
[build]   
[build]   %insert(init) "swiginit.swg"
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %insert("init") %{
[build]   
[build]   #ifdef __cplusplus
[build]   extern "C" {
[build]   #endif
[build]   
[build]   /* Python-specific SWIG API */
[build]   #define SWIG_newvarlink()                             SWIG_Python_newvarlink()
[build]   #define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
[build]   #define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
[build]    
[build]   /* -----------------------------------------------------------------------------
[build]    * global variable support code.
[build]    * ----------------------------------------------------------------------------- */
[build]    
[build]   typedef struct swig_globalvar {   
[build]     char       *name;                  /* Name of global variable */
[build]     PyObject *(*get_attr)(void);       /* Return the current value */
[build]     int       (*set_attr)(PyObject *); /* Set the value */
[build]     struct swig_globalvar *next;
[build]   } swig_globalvar;
[build]   
[build]   typedef struct swig_varlinkobject {
[build]     PyObject_HEAD
[build]     swig_globalvar *vars;
[build]   } swig_varlinkobject;
[build]   
[build]   SWIGINTERN PyObject *
[build]   swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
[build]   #if PY_VERSION_HEX >= 0x03000000
[build]     return PyUnicode_InternFromString("<Swig global variables>");
[build]   #else
[build]     return PyString_FromString("<Swig global variables>");
[build]   #endif
[build]   }
[build]   
[build]   SWIGINTERN PyObject *
[build]   swig_varlink_str(swig_varlinkobject *v) {
[build]   #if PY_VERSION_HEX >= 0x03000000
[build]     PyObject *str = PyUnicode_InternFromString("(");
[build]     PyObject *tail;
[build]     PyObject *joined;
[build]     swig_globalvar *var;
[build]     for (var = v->vars; var; var=var->next) {
[build]       tail = PyUnicode_FromString(var->name);
[build]       joined = PyUnicode_Concat(str, tail);
[build]       Py_DecRef(str);
[build]       Py_DecRef(tail);
[build]       str = joined;
[build]       if (var->next) {
[build]           tail = PyUnicode_InternFromString(", ");
[build]           joined = PyUnicode_Concat(str, tail);
[build]           Py_DecRef(str);
[build]           Py_DecRef(tail);
[build]           str = joined;
[build]       }
[build]     }
[build]     tail = PyUnicode_InternFromString(")");
[build]     joined = PyUnicode_Concat(str, tail);
[build]     Py_DecRef(str);
[build]     Py_DecRef(tail);
[build]     str = joined;
[build]   #else
[build]     PyObject *str = PyString_FromString("(");
[build]     swig_globalvar *var;
[build]     for (var = v->vars; var; var=var->next) {
[build]       PyString_ConcatAndDel(&str,PyString_FromString(var->name));
[build]       if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
[build]     }
[build]     PyString_ConcatAndDel(&str,PyString_FromString(")"));
[build]   #endif
[build]     return str;
[build]   }
[build]   
[build]   SWIGINTERN int
[build]   swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
[build]     char *tmp;
[build]     PyObject *str = swig_varlink_str(v);
[build]     fprintf(fp,"Swig global variables ");
[build]     fprintf(fp,"%s\n", tmp = SWIG_Python_str_AsChar(str));
[build]     SWIG_Python_str_DelForPy3(tmp);
[build]     Py_DECREF(str);
[build]     return 0;
[build]   }
[build]   
[build]   SWIGINTERN void
[build]   swig_varlink_dealloc(swig_varlinkobject *v) {
[build]     swig_globalvar *var = v->vars;
[build]     while (var) {
[build]       swig_globalvar *n = var->next;
[build]       free(var->name);
[build]       free(var);
[build]       var = n;
[build]     }
[build]   }
[build]   
[build]   SWIGINTERN PyObject *
[build]   swig_varlink_getattr(swig_varlinkobject *v, char *n) {
[build]     PyObject *res = NULL;
[build]     swig_globalvar *var = v->vars;
[build]     while (var) {
[build]       if (strcmp(var->name,n) == 0) {
[build]         res = (*var->get_attr)();
[build]         break;
[build]       }
[build]       var = var->next;
[build]     }
[build]     if (res == NULL && !PyErr_Occurred()) {
[build]       PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
[build]     }
[build]     return res;
[build]   }
[build]   
[build]   SWIGINTERN int
[build]   swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
[build]     int res = 1;
[build]     swig_globalvar *var = v->vars;
[build]     while (var) {
[build]       if (strcmp(var->name,n) == 0) {
[build]         res = (*var->set_attr)(p);
[build]         break;
[build]       }
[build]       var = var->next;
[build]     }
[build]     if (res == 1 && !PyErr_Occurred()) {
[build]       PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
[build]     }
[build]     return res;
[build]   }
[build]   
[build]   SWIGINTERN PyTypeObject*
[build]   swig_varlink_type(void) {
[build]     static char varlink__doc__[] = "Swig var link object";
[build]     static PyTypeObject varlink_type;
[build]     static int type_init = 0;
[build]     if (!type_init) {
[build]       const PyTypeObject tmp = {
[build]   #if PY_VERSION_HEX >= 0x03000000
[build]         PyVarObject_HEAD_INIT(NULL, 0)
[build]   #else
[build]         PyObject_HEAD_INIT(NULL)
[build]         0,                                  /* ob_size */
[build]   #endif
[build]         (char *)"swigvarlink",              /* tp_name */
[build]         sizeof(swig_varlinkobject),         /* tp_basicsize */
[build]         0,                                  /* tp_itemsize */
[build]         (destructor) swig_varlink_dealloc,  /* tp_dealloc */
[build]         (printfunc) swig_varlink_print,     /* tp_print */
[build]         (getattrfunc) swig_varlink_getattr, /* tp_getattr */
[build]         (setattrfunc) swig_varlink_setattr, /* tp_setattr */
[build]         0,                                  /* tp_compare */
[build]         (reprfunc) swig_varlink_repr,       /* tp_repr */
[build]         0,                                  /* tp_as_number */
[build]         0,                                  /* tp_as_sequence */
[build]         0,                                  /* tp_as_mapping */
[build]         0,                                  /* tp_hash */
[build]         0,                                  /* tp_call */
[build]         (reprfunc) swig_varlink_str,        /* tp_str */
[build]         0,                                  /* tp_getattro */
[build]         0,                                  /* tp_setattro */
[build]         0,                                  /* tp_as_buffer */
[build]         0,                                  /* tp_flags */
[build]         varlink__doc__,                     /* tp_doc */
[build]         0,                                  /* tp_traverse */
[build]         0,                                  /* tp_clear */
[build]         0,                                  /* tp_richcompare */
[build]         0,                                  /* tp_weaklistoffset */
[build]   #if PY_VERSION_HEX >= 0x02020000
[build]         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
[build]   #endif
[build]   #if PY_VERSION_HEX >= 0x02030000
[build]         0,                                  /* tp_del */
[build]   #endif
[build]   #if PY_VERSION_HEX >= 0x02060000
[build]         0,                                  /* tp_version_tag */
[build]   #endif
[build]   #if PY_VERSION_HEX >= 0x03040000
[build]         0,                                  /* tp_finalize */
[build]   #endif
[build]   #ifdef COUNT_ALLOCS
[build]         0,                                  /* tp_allocs */
[build]         0,                                  /* tp_frees */
[build]         0,                                  /* tp_maxalloc */
[build]   #if PY_VERSION_HEX >= 0x02050000
[build]         0,                                  /* tp_prev */
[build]   #endif
[build]         0                                   /* tp_next */
[build]   #endif
[build]       };
[build]       varlink_type = tmp;
[build]       type_init = 1;
[build]   #if PY_VERSION_HEX < 0x02020000
[build]       varlink_type.ob_type = &PyType_Type;
[build]   #else
[build]       if (PyType_Ready(&varlink_type) < 0)
[build]         return NULL;
[build]   #endif
[build]     }
[build]     return &varlink_type;
[build]   }
[build]   
[build]   /* Create a variable linking object for use later */
[build]   SWIGINTERN PyObject *
[build]   SWIG_Python_newvarlink(void) {
[build]     swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
[build]     if (result) {
[build]       result->vars = 0;
[build]     }
[build]     return ((PyObject*) result);
[build]   }
[build]   
[build]   SWIGINTERN void 
[build]   SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
[build]     swig_varlinkobject *v = (swig_varlinkobject *) p;
[build]     swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
[build]     if (gv) {
[build]       size_t size = strlen(name)+1;
[build]       gv->name = (char *)malloc(size);
[build]       if (gv->name) {
[build]         strncpy(gv->name,name,size);
[build]         gv->get_attr = get_attr;
[build]         gv->set_attr = set_attr;
[build]         gv->next = v->vars;
[build]       }
[build]     }
[build]     v->vars = gv;
[build]   }
[build]   
[build]   SWIGINTERN PyObject *
[build]   SWIG_globals(void) {
[build]     static PyObject *_SWIG_globals = 0; 
[build]     if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
[build]     return _SWIG_globals;
[build]   }
[build]   
[build]   /* -----------------------------------------------------------------------------
[build]    * constants/methods manipulation
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   /* Install Constants */
[build]   SWIGINTERN void
[build]   SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
[build]     PyObject *obj = 0;
[build]     size_t i;
[build]     for (i = 0; constants[i].type; ++i) {
[build]       switch(constants[i].type) {
[build]       case SWIG_PY_POINTER:
[build]         obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
[build]         break;
[build]       case SWIG_PY_BINARY:
[build]         obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
[build]         break;
[build]       default:
[build]         obj = 0;
[build]         break;
[build]       }
[build]       if (obj) {
[build]         PyDict_SetItemString(d, constants[i].name, obj);
[build]         Py_DECREF(obj);
[build]       }
[build]     }
[build]   }
[build]   
[build]   /* -----------------------------------------------------------------------------*/
[build]   /* Fix SwigMethods to carry the callback ptrs when needed */
[build]   /* -----------------------------------------------------------------------------*/
[build]   
[build]   SWIGINTERN void
[build]   SWIG_Python_FixMethods(PyMethodDef *methods,
[build]   		       swig_const_info *const_table,
[build]   		       swig_type_info **types,
[build]   		       swig_type_info **types_initial) {
[build]     size_t i;
[build]     for (i = 0; methods[i].ml_name; ++i) {
[build]       const char *c = methods[i].ml_doc;
[build]       if (!c) continue;
[build]       c = strstr(c, "swig_ptr: ");
[build]       if (c) {
[build]         int j;
[build]         swig_const_info *ci = 0;
[build]         const char *name = c + 10;
[build]         for (j = 0; const_table[j].type; ++j) {
[build]   	if (strncmp(const_table[j].name, name, 
[build]   		    strlen(const_table[j].name)) == 0) {
[build]   	  ci = &(const_table[j]);
[build]   	  break;
[build]   	}
[build]         }
[build]         if (ci) {
[build]   	void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
[build]   	if (ptr) {
[build]   	  size_t shift = (ci->ptype) - types;
[build]   	  swig_type_info *ty = types_initial[shift];
[build]   	  size_t ldoc = (c - methods[i].ml_doc);
[build]   	  size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
[build]   	  char *ndoc = (char*)malloc(ldoc + lptr + 10);
[build]   	  if (ndoc) {
[build]   	    char *buff = ndoc;
[build]   	    strncpy(buff, methods[i].ml_doc, ldoc);
[build]   	    buff += ldoc;
[build]   	    strncpy(buff, "swig_ptr: ", 10);
[build]   	    buff += 10;
[build]   	    SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
[build]   	    methods[i].ml_doc = ndoc;
[build]   	  }
[build]   	}
[build]         }
[build]       }
[build]     }
[build]   } 
[build]   
[build]   #ifdef __cplusplus
[build]   }
[build]   #endif
[build]   
[build]   /* -----------------------------------------------------------------------------*
[build]    *  Partial Init method
[build]    * -----------------------------------------------------------------------------*/
[build]   
[build]   #ifdef __cplusplus
[build]   extern "C"
[build]   #endif
[build]   
[build]   SWIGEXPORT 
[build]   #if PY_VERSION_HEX >= 0x03000000
[build]     PyObject*
[build]   #else
[build]     void
[build]   #endif
[build]   SWIG_init(void) {
[build]     PyObject *m, *d, *md;
[build]   #if PY_VERSION_HEX >= 0x03000000
[build]     static struct PyModuleDef SWIG_module = {
[build]   # if PY_VERSION_HEX >= 0x03020000
[build]       PyModuleDef_HEAD_INIT,
[build]   # else
[build]       {
[build]         PyObject_HEAD_INIT(NULL)
[build]         NULL, /* m_init */
[build]         0,    /* m_index */
[build]         NULL, /* m_copy */
[build]       },
[build]   # endif
[build]       (char *) SWIG_name,
[build]       NULL,
[build]       -1,
[build]       SwigMethods,
[build]       NULL,
[build]       NULL,
[build]       NULL,
[build]       NULL
[build]     };
[build]   #endif
[build]   
[build]   #if defined(SWIGPYTHON_BUILTIN)
[build]     static SwigPyClientData SwigPyObject_clientdata = {0, 0, 0, 0, 0, 0, 0};
[build]     static PyGetSetDef this_getset_def = {
[build]       (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
[build]     };
[build]     static SwigPyGetSet thisown_getset_closure = {
[build]       (PyCFunction) SwigPyObject_own,
[build]       (PyCFunction) SwigPyObject_own
[build]     };
[build]     static PyGetSetDef thisown_getset_def = {
[build]       (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
[build]     };
[build]     PyTypeObject *builtin_pytype;
[build]     int builtin_base_count;
[build]     swig_type_info *builtin_basetype;
[build]     PyObject *tuple;
[build]     PyGetSetDescrObject *static_getset;
[build]     PyTypeObject *metatype;
[build]     PyTypeObject *swigpyobject;
[build]     SwigPyClientData *cd;
[build]     PyObject *public_interface, *public_symbol;
[build]     PyObject *this_descr;
[build]     PyObject *thisown_descr;
[build]     PyObject *self = 0;
[build]     int i;
[build]   
[build]     (void)builtin_pytype;
[build]     (void)builtin_base_count;
[build]     (void)builtin_basetype;
[build]     (void)tuple;
[build]     (void)static_getset;
[build]     (void)self;
[build]   
[build]     /* Metaclass is used to implement static member variables */
[build]     metatype = SwigPyObjectType();
[build]     assert(metatype);
[build]   #endif
[build]   
[build]     /* Fix SwigMethods to carry the callback ptrs when needed */
[build]     SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
[build]   
[build]   #if PY_VERSION_HEX >= 0x03000000
[build]     m = PyModule_Create(&SWIG_module);
[build]   #else
[build]     m = Py_InitModule((char *) SWIG_name, SwigMethods);
[build]   #endif
[build]   
[build]     md = d = PyModule_GetDict(m);
[build]     (void)md;
[build]   
[build]     SWIG_InitializeModule(0);
[build]   
[build]   #ifdef SWIGPYTHON_BUILTIN
[build]     swigpyobject = SwigPyObject_TypeOnce();
[build]   
[build]     SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
[build]     assert(SwigPyObject_stype);
[build]     cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
[build]     if (!cd) {
[build]       SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
[build]       SwigPyObject_clientdata.pytype = swigpyobject;
[build]     } else if (swigpyobject->tp_basicsize != cd->pytype->tp_basicsize) {
[build] CUSTOMBUILD : PyErr_SetString(PyExc_RuntimeError, "Import error : attempted to load two incompatible swig-generated modules."); [D:\bfxdev\obs-studio\build\deps\obs-scripting\obspython\_obspython.vcxproj]
[build]   # if PY_VERSION_HEX >= 0x03000000
[build]       return NULL;
[build]   # else
[build]       return;
[build]   # endif
[build]     }
[build]   
[build]     /* All objects have a 'this' attribute */
[build]     this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
[build]     (void)this_descr;
[build]   
[build]     /* All objects have a 'thisown' attribute */
[build]     thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
[build]     (void)thisown_descr;
[build]   
[build]     public_interface = PyList_New(0);
[build]     public_symbol = 0;
[build]     (void)public_symbol;
[build]   
[build]     PyDict_SetItemString(md, "__all__", public_interface);
[build]     Py_DECREF(public_interface);
[build]     for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
[build]       SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
[build]     for (i = 0; swig_const_table[i].name != 0; ++i)
[build]       SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
[build]   #endif
[build]   
[build]     SWIG_InstallConstants(d,swig_const_table);
[build]   %}
[build]   
[build]   %endoffile
[build]   
[build]   
[build]   /* ------------------------------------------------------------
[build]    * For backward compatibility
[build]    * ------------------------------------------------------------ */
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\python\\pybackward.swg" %beginfile
[build]   /* 
[build]      adding backward compatibility macros
[build]   */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\typemaps\primtypes.swg,341,%apply_checkctypes@*/
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {bool},"header", fragment="SWIG_" "AsVal" "_" {bool}) {
[build]   SWIGINTERNINLINE bool
[build]   SWIG_As_bool (PyObject* obj)
[build]   {
[build]     bool v;
[build]     int res = SWIG_AsVal_bool (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(bool));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {bool},"header",fragment="SWIG_" "AsVal" "_" {bool}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_bool (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_bool (obj, (bool*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {signed char},"header", fragment="SWIG_" "AsVal" "_" {signed char}) {
[build]   SWIGINTERNINLINE signed char
[build]   SWIG_As_signed_SS_char (PyObject* obj)
[build]   {
[build]     signed char v;
[build]     int res = SWIG_AsVal_signed_SS_char (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(signed char));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {signed char},"header",fragment="SWIG_" "AsVal" "_" {signed char}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_signed_SS_char (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_signed_SS_char (obj, (signed char*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {unsigned char},"header", fragment="SWIG_" "AsVal" "_" {unsigned char}) {
[build]   SWIGINTERNINLINE unsigned char
[build]   SWIG_As_unsigned_SS_char (PyObject* obj)
[build]   {
[build]     unsigned char v;
[build]     int res = SWIG_AsVal_unsigned_SS_char (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(unsigned char));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {unsigned char},"header",fragment="SWIG_" "AsVal" "_" {unsigned char}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_unsigned_SS_char (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_unsigned_SS_char (obj, (unsigned char*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {short},"header", fragment="SWIG_" "AsVal" "_" {short}) {
[build]   SWIGINTERNINLINE short
[build]   SWIG_As_short (PyObject* obj)
[build]   {
[build]     short v;
[build]     int res = SWIG_AsVal_short (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(short));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {short},"header",fragment="SWIG_" "AsVal" "_" {short}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_short (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_short (obj, (short*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {unsigned short},"header", fragment="SWIG_" "AsVal" "_" {unsigned short}) {
[build]   SWIGINTERNINLINE unsigned short
[build]   SWIG_As_unsigned_SS_short (PyObject* obj)
[build]   {
[build]     unsigned short v;
[build]     int res = SWIG_AsVal_unsigned_SS_short (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(unsigned short));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {unsigned short},"header",fragment="SWIG_" "AsVal" "_" {unsigned short}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_unsigned_SS_short (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_unsigned_SS_short (obj, (unsigned short*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {int},"header", fragment="SWIG_" "AsVal" "_" {int}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_As_int (PyObject* obj)
[build]   {
[build]     int v;
[build]     int res = SWIG_AsVal_int (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(int));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {int},"header",fragment="SWIG_" "AsVal" "_" {int}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_int (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_int (obj, (int*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {unsigned int},"header", fragment="SWIG_" "AsVal" "_" {unsigned int}) {
[build]   SWIGINTERNINLINE unsigned int
[build]   SWIG_As_unsigned_SS_int (PyObject* obj)
[build]   {
[build]     unsigned int v;
[build]     int res = SWIG_AsVal_unsigned_SS_int (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(unsigned int));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {unsigned int},"header",fragment="SWIG_" "AsVal" "_" {unsigned int}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_unsigned_SS_int (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_unsigned_SS_int (obj, (unsigned int*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {long},"header", fragment="SWIG_" "AsVal" "_" {long}) {
[build]   SWIGINTERNINLINE long
[build]   SWIG_As_long (PyObject* obj)
[build]   {
[build]     long v;
[build]     int res = SWIG_AsVal_long (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(long));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {long},"header",fragment="SWIG_" "AsVal" "_" {long}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_long (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_long (obj, (long*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {unsigned long},"header", fragment="SWIG_" "AsVal" "_" {unsigned long}) {
[build]   SWIGINTERNINLINE unsigned long
[build]   SWIG_As_unsigned_SS_long (PyObject* obj)
[build]   {
[build]     unsigned long v;
[build]     int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(unsigned long));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {unsigned long},"header",fragment="SWIG_" "AsVal" "_" {unsigned long}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_unsigned_SS_long (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_unsigned_SS_long (obj, (unsigned long*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {long long},"header", fragment="SWIG_" "AsVal" "_" {long long}) {
[build]   SWIGINTERNINLINE long long
[build]   SWIG_As_long_SS_long (PyObject* obj)
[build]   {
[build]     long long v;
[build]     int res = SWIG_AsVal_long_SS_long (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(long long));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {long long},"header",fragment="SWIG_" "AsVal" "_" {long long}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_long_SS_long (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_long_SS_long (obj, (long long*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {unsigned long long},"header", fragment="SWIG_" "AsVal" "_" {unsigned long long}) {
[build]   SWIGINTERNINLINE unsigned long long
[build]   SWIG_As_unsigned_SS_long_SS_long (PyObject* obj)
[build]   {
[build]     unsigned long long v;
[build]     int res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(unsigned long long));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {unsigned long long},"header",fragment="SWIG_" "AsVal" "_" {unsigned long long}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_unsigned_SS_long_SS_long (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, (unsigned long long*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {float},"header", fragment="SWIG_" "AsVal" "_" {float}) {
[build]   SWIGINTERNINLINE float
[build]   SWIG_As_float (PyObject* obj)
[build]   {
[build]     float v;
[build]     int res = SWIG_AsVal_float (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(float));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {float},"header",fragment="SWIG_" "AsVal" "_" {float}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_float (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_float (obj, (float*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {double},"header", fragment="SWIG_" "AsVal" "_" {double}) {
[build]   SWIGINTERNINLINE double
[build]   SWIG_As_double (PyObject* obj)
[build]   {
[build]     double v;
[build]     int res = SWIG_AsVal_double (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(double));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {double},"header",fragment="SWIG_" "AsVal" "_" {double}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_double (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_double (obj, (double*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {char},"header", fragment="SWIG_" "AsVal" "_" {char}) {
[build]   SWIGINTERNINLINE char
[build]   SWIG_As_char (PyObject* obj)
[build]   {
[build]     char v;
[build]     int res = SWIG_AsVal_char (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(char));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {char},"header",fragment="SWIG_" "AsVal" "_" {char}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_char (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_char (obj, (char*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {wchar_t},"header", fragment="SWIG_" "AsVal" "_" {wchar_t}) {
[build]   SWIGINTERNINLINE wchar_t
[build]   SWIG_As_wchar_t (PyObject* obj)
[build]   {
[build]     wchar_t v;
[build]     int res = SWIG_AsVal_wchar_t (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(wchar_t));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {wchar_t},"header",fragment="SWIG_" "AsVal" "_" {wchar_t}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_wchar_t (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_wchar_t (obj, (wchar_t*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {size_t},"header", fragment="SWIG_" "AsVal" "_" {size_t}) {
[build]   SWIGINTERNINLINE size_t
[build]   SWIG_As_size_t (PyObject* obj)
[build]   {
[build]     size_t v;
[build]     int res = SWIG_AsVal_size_t (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(size_t));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {size_t},"header",fragment="SWIG_" "AsVal" "_" {size_t}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_size_t (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_size_t (obj, (size_t*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG:D:/bfxdev/obs-studio-deps/win64/swig/Lib\python\pybackward.swg,16,%ascheck_methods@*/
[build]   %fragment("SWIG_" "As" "_" {ptrdiff_t},"header", fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) {
[build]   SWIGINTERNINLINE ptrdiff_t
[build]   SWIG_As_ptrdiff_t (PyObject* obj)
[build]   {
[build]     ptrdiff_t v;
[build]     int res = SWIG_AsVal_ptrdiff_t (obj, &v);
[build]     if (!SWIG_IsOK(res)) {
[build]       /*
[build]         this is needed to make valgrind/purify happier. 
[build]        */
[build]       memset((void*)&v, 0, sizeof(ptrdiff_t));
[build]       SWIG_Error(res, "");
[build]     }
[build]     return v;
[build]   }
[build]   }
[build]   
[build]   %fragment("SWIG_" "Check" "_" {ptrdiff_t},"header",fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) {
[build]   SWIGINTERNINLINE int
[build]   SWIG_Check_ptrdiff_t (PyObject* obj)
[build]   {
[build]     int res = SWIG_AsVal_ptrdiff_t (obj, (ptrdiff_t*)0);
[build]     return SWIG_IsOK(res);
[build]   }
[build]   }
[build]   /*@SWIG@*/;
[build]   /*@SWIG@*/
[build]   
[build]   %endoffile
[build]   
[build]   
[build]   %endoffile
[build]   %includefile(maininput="D:\\bfxdev\\obs-studio\\deps\\obs-scripting\\obspython\\obspython.i") "D:\\bfxdev\\obs-studio\\deps\\obs-scripting\\obspython\\obspython.i" %beginfile
[build]   %module(threads="1") obspython
[build]   %feature("nothread");
[build]   %{
[build]   #define SWIG_FILE_WITH_INIT
[build]   #define DEPRECATED_START
[build]   #define DEPRECATED_END
[build]   #include <graphics/graphics.h>
[build]   #include <graphics/vec4.h>
[build]   #include <graphics/vec3.h>
[build]   #include <graphics/vec2.h>
[build]   #include <graphics/matrix4.h>
[build]   #include <graphics/matrix3.h>
[build]   #include <graphics/quat.h>
[build]   #include <obs.h>
[build]   #include <obs-hotkey.h>
[build]   #include <obs-source.h>
[build]   #include <obs-data.h>
[build]   #include <obs-properties.h>
[build]   #include <obs-interaction.h>
[build]   #include <callback/calldata.h>
[build]   #include <callback/decl.h>
[build]   #include <callback/proc.h>
[build]   #include <callback/signal.h>
[build]   #include <util/bmem.h>
[build]   #include <util/base.h>
[build]   #include "obs-scripting-config.h"
[build]   #include <util/platform.h>
[build]   
[build]   #if UI_ENABLED
[build]   #include "obs-frontend-api.h"
[build]   #endif
[build]   
[build]   %}
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %rename(blog) wrap_blog;
[build]   %inline %{
[build]   static inline void wrap_blog(int log_level, const char *message)
[build]   {
[build]           blog(log_level, "%s", message);
[build]   }
[build]   %}
[build]   
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\stdint.i" %beginfile
[build]   /* -----------------------------------------------------------------------------
[build]    * stdint.i
[build]    *
[build]    * SWIG library file for ISO C99 types: 7.18 Integer types <stdint.h>
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   %{
[build]   #include <stdint.h>		// Use the C99 official header
[build]   %}
[build]   
[build]   %includefile "D:\\bfxdev\\obs-studio-deps\\win64\\swig\\Lib\\swigarch.i" %beginfile
[build]   /* -----------------------------------------------------------------------------
[build]    * swigarch.i
[build]    *
[build]    * SWIG library file for 32bit/64bit code specialization and checking.
[build]    *
[build]    * Use only in extreme cases, when no arch. independent code can be
[build]    * generated
[build]    * 
[build]    * To activate architecture specific code, use
[build]    *
[build]    *     swig -DSWIGWORDSIZE32
[build]    *
[build]    * or
[build]    *
[build]    *     swig -DSWIGWORDSIZE64
[build]    *
[build]    * Note that extra checking code will be added to the wrapped code,
[build]    * which will prevent the compilation in a different architecture.
[build]    *
[build]    * If you don't specify the SWIGWORDSIZE (the default case), swig will
[build]    * generate architecture independent and/or 32bits code, with no extra
[build]    * checking code added.
[build]    * ----------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]     
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]     
[build]   
[build]   %endoffile
[build]   
[build]   /* Exact integral types.  */
[build]   
[build]   /* Signed.  */
[build]   
[build]   typedef signed char		int8_t;
[build]   typedef short int		int16_t;
[build]   typedef int			int32_t;
[build]   
[build]   
[build]   
[build]   typedef long long int		int64_t;
[build]   
[build]   
[build]   /* Unsigned.  */
[build]   typedef unsigned char		uint8_t;
[build]   typedef unsigned short int	uint16_t;
[build]   typedef unsigned int		uint32_t;
[build]   
[build]   
[build]   
[build]   typedef unsigned long long int	uint64_t;
[build]   
[build]   
[build]   
[build]   /* Small types.  */
[build]   
[build]   /* Signed.  */
[build]   typedef signed char		int_least8_t;
[build]   typedef short int		int_least16_t;
[build]   typedef int			int_least32_t;
[build]   
[build]   
[build]   
[build]   typedef long long int		int_least64_t;
[build]   
[build]   
[build]   /* Unsigned.  */
[build]   typedef unsigned char		uint_least8_t;
[build]   typedef unsigned short int	uint_least16_t;
[build]   typedef unsigned int		uint_least32_t;
[build]   
[build]   
[build]   
[build]   typedef unsigned long long int	uint_least64_t;
[build]   
[build]   
[build]   
[build]   /* Fast types.  */
[build]   
[build]   /* Signed.  */
[build]   typedef signed char		int_fast8_t;
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   typedef int			int_fast16_t;
[build]   typedef int			int_fast32_t;
[build]   typedef long long int		int_fast64_t;
[build]   
[build]   
[build]   /* Unsigned.  */
[build]   typedef unsigned char		uint_fast8_t;
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   typedef unsigned int		uint_fast16_t;
[build]   typedef unsigned int		uint_fast32_t;
[build]   typedef unsigned long long int	uint_fast64_t;
[build]   
[build]   
[build]   
[build]   /* Types for `void *' pointers.  */
[build]   
[build]   
[build]   
[build]   
[build]   typedef int			intptr_t;
[build]   typedef unsigned int		uintptr_t;
[build]   
[build]   
[build]   
[build]   /* Largest integral types.  */
[build]   
[build]   
[build]   
[build]   
[build]   typedef long long int		intmax_t;
[build]   typedef unsigned long long int	uintmax_t;
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   
[build]   /* Used to free when using %newobject functions.  E.G.:
[build]    * %newobject obs_module_get_config_path; */
[build]   %typemap(newfree) char * "bfree($1);";
[build]   
[build]   ///////////////////////////////////////////////////////////////////////
[build]   
[build]   %typemap(in) SWIGTYPE
[build]   
[build]   
[build]   // Defines a temporary variable to hold the value and assigns its address to the argument
[build]   %typemap(arginit, noblock=1) uint32_t *OUTREF {
[build]     // OUTREF typemap(arginit) for $1_type $1_name
[build]     $*1_type temp$argnum = 0;
[build]     $1 = &temp$argnum;
[build]   }
[build]   
[build]   %typemap(argout, noblock=1, doc="bytearray") uint32_t *OUTREF {
[build]     // OUTREF typemap(out) for OBS see obspython.i
[build]     $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_int((temp$argnum)));
[build]   }
[build]   
[build]   %typemap(out) uint32_t *OUTREF "// typemap(out)";
[build]   %typemap(in, numinputs=0) uint32_t *OUTREF "// typemap(in)";
[build]   %typemap(typecheck) uint32_t *OUTREF "// typemap(typecheck)";
[build]   %typemap(check) uint32_t *OUTREF "// typemap(check)";
[build]   %typemap(default) uint32_t *OUTREF "// typemap(default)";
[build]   %typemap(doc) uint32_t *OUTREF "// typemap(doc)";
[build]   
[build]   void gs_get_size(uint32_t *OUTREF, uint32_t *OUTREF);
[build]   
[build]   %typemap(arginit) uint8_t **OUTREF = uint32_t *OUTREF;
[build]   %typemap(in) uint8_t **OUTREF = uint32_t *OUTREF;
[build]   
[build]   
[build]   %typemap(argout, noblock=1) uint8_t **OUTREF {
[build]     // OUTREF typemap(out) for OBS see obspython.i
[build]     int size = gs_stagesurface_get_height(arg1)*(*arg3);
[build]     $result = SWIG_Python_AppendOutput($result, PyByteArray_FromStringAndSize((const char *)temp$argnum, size));
[build]   }
[build]   
[build]   
[build]   bool gs_stagesurface_map(gs_stagesurf_t *stagesurf, uint8_t **OUTREF, uint32_t *OUTREF);
[build]   
[build]   /* No added value: %feature("autodoc", "0"); */
[build]   
[build]   /* Code generated with void gs_get_size(uint32_t *INOUT, uint32_t *INOUT);
[build]   
[build]   SWIGINTERN PyObject *_wrap_gs_get_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
[build]     PyObject *resultobj = 0;
[build]     uint32_t *arg1 = (uint32_t *) 0 ;
[build]     uint32_t *arg2 = (uint32_t *) 0 ;
[build]     uint32_t temp1 ;
[build]     int res1 = 0 ;
[build]     uint32_t temp2 ;
[build]     int res2 = 0 ;
[build]     PyObject * obj0 = 0 ;
[build]     PyObject * obj1 = 0 ;
[build]     
[build]     if (!PyArg_ParseTuple(args,(char *)"OO:gs_get_size",&obj0,&obj1)) SWIG_fail;
[build]     if (!(SWIG_IsOK((res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1),SWIGTYPE_p_unsigned_int,0))))) {
[build]       unsigned int val; 
[build]       int ecode = SWIG_AsVal_unsigned_SS_int(obj0, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "gs_get_size" "', argument " "1"" of type '" "uint32_t""'");
[build]       }
[build]       temp1 = (uint32_t)(val);
[build]       arg1 = &temp1;
[build]       res1 = SWIG_AddTmpMask(ecode);
[build]     }
[build]     if (!(SWIG_IsOK((res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2),SWIGTYPE_p_unsigned_int,0))))) {
[build]       unsigned int val; 
[build]       int ecode = SWIG_AsVal_unsigned_SS_int(obj1, &val);
[build]       if (!SWIG_IsOK(ecode)) {
[build]         SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "gs_get_size" "', argument " "2"" of type '" "uint32_t""'");
[build]       }
[build]       temp2 = (uint32_t)(val);
[build]       arg2 = &temp2;
[build]       res2 = SWIG_AddTmpMask(ecode);
[build]     }
[build]     gs_get_size(arg1,arg2);
[build]     resultobj = SWIG_Py_Void();
[build]     if (SWIG_IsTmpObj(res1)) {
[build]       resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_unsigned_SS_int((*arg1)));
[build]     } else {
[build]       int new_flags = SWIG_IsNewObj(res1) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]       resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_unsigned_int, new_flags));
[build]     }
[build]     if (SWIG_IsTmpObj(res2)) {
[build]       resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_unsigned_SS_int((*arg2)));
[build]     } else {
[build]       int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]       resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_unsigned_int, new_flags));
[build]     }
[build]     return resultobj;
[build]   fail:
[build]     return NULL;
[build]   }
[build]   /*
[build]   
[build]   /* Code generated with void gs_get_size(uint32_t *OUTPUT, uint32_t *OUTPUT);
[build]   SWIGINTERN PyObject *_wrap_gs_get_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
[build]     PyObject *resultobj = 0;
[build]     uint32_t *arg1 = (uint32_t *) 0 ;
[build]     uint32_t *arg2 = (uint32_t *) 0 ;
[build]     uint32_t temp1 ;
[build]     int res1 = SWIG_TMPOBJ ;
[build]     uint32_t temp2 ;
[build]     int res2 = SWIG_TMPOBJ ;
[build]     
[build]     arg1 = &temp1;
[build]     arg2 = &temp2;
[build]     if (!PyArg_ParseTuple(args,(char *)":gs_get_size")) SWIG_fail;
[build]     gs_get_size(arg1,arg2);
[build]     resultobj = SWIG_Py_Void();
[build]     if (SWIG_IsTmpObj(res1)) {
[build]       resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_unsigned_SS_int((*arg1)));
[build]     } else {
[build]       int new_flags = SWIG_IsNewObj(res1) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]       resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_unsigned_int, new_flags));
[build]     }
[build]     if (SWIG_IsTmpObj(res2)) {
[build]       resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_unsigned_SS_int((*arg2)));
[build]     } else {
[build]       int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
[build]       resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_unsigned_int, new_flags));
[build]     }
[build]     return resultobj;
[build]   fail:
[build]     return NULL;
[build]   } */
[build]   
[build]   /* Code generated with no extra definition
[build]   SWIGINTERN PyObject *_wrap_gs_get_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
[build]     PyObject *resultobj = 0;
[build]     uint32_t *arg1 = (uint32_t *) 0 ;
[build]     uint32_t *arg2 = (uint32_t *) 0 ;
[build]     void *argp1 = 0 ;
[build]     int res1 = 0 ;
[build]     void *argp2 = 0 ;
[build]     int res2 = 0 ;
[build]     PyObject * obj0 = 0 ;
[build]     PyObject * obj1 = 0 ;
[build]     
[build]     if (!PyArg_ParseTuple(args,(char *)"OO:gs_get_size",&obj0,&obj1)) SWIG_fail;
[build]     res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_unsigned_int, 0 |  0 );
[build]     if (!SWIG_IsOK(res1)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gs_get_size" "', argument " "1"" of type '" "uint32_t *""'"); 
[build]     }
[build]     arg1 = (uint32_t *)(argp1);
[build]     res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 );
[build]     if (!SWIG_IsOK(res2)) {
[build]       SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gs_get_size" "', argument " "2"" of type '" "uint32_t *""'"); 
[build]     }
[build]     arg2 = (uint32_t *)(argp2);
[build]     gs_get_size(arg1,arg2);
[build]     resultobj = SWIG_Py_Void();
[build]     return resultobj;
[build]   fail:
[build]     return NULL;
[build]   }*/
[build]   
[build]   
[build]   // Can be imported, unclear if necessary
[build]   // %include "pybuffer.i"
[build]   
[build]   
[build]   // Not necessary, already included somewhere
[build]   // %include "typemaps.i"
[build]   
[build]   // Does not work, unclear why, it should be the same as redefining arguments in functions
[build]   // %apply uint32_t *INOUT { uint32_t *cx};
[build]   // %apply uint32_t *INOUT { uint32_t *cy};
[build]   
[build]   // Works only with variables passed as arguments, crashes with None or no argument
[build]   // void gs_get_size(uint32_t *INOUT, uint32_t *INOUT);
[build]   
[build]   // Works only with no variable passed as argument, crashes with arguments or None
[build]   // void gs_get_size(uint32_t *OUTPUT, uint32_t *OUTPUT);
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   ///////////////////////////////////////////////////////////////////////
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %rename($ignore) blog;
[build]   %rename($ignore) blogva;
[build]   %rename($ignore) bcrash;
[build]   %rename($ignore) obs_source_info;
[build]   %rename($ignore) obs_register_source_s(const struct obs_source_info *info, size_t size);
[build]   %rename($ignore) obs_output_set_video(obs_output_t *output, video_t *video);
[build]   %rename($ignore) obs_output_video(const obs_output_t *output);
[build]   %rename($ignore) obs_add_tick_callback;
[build]   %rename($ignore) obs_remove_tick_callback;
[build]   %rename($ignore) obs_add_main_render_callback;
[build]   %rename($ignore) obs_remove_main_render_callback;
[build]   %rename($ignore) obs_enum_sources;
[build]   %rename($ignore) obs_properties_add_button;
[build]   %rename($ignore) obs_property_set_modified_callback;
[build]   %rename($ignore) signal_handler_connect;
[build]   %rename($ignore) signal_handler_disconnect;
[build]   %rename($ignore) signal_handler_connect_global;
[build]   %rename($ignore) signal_handler_disconnect_global;
[build]   %rename($ignore) signal_handler_remove_current;
[build]   %rename($ignore) obs_hotkey_register_frontend;
[build]   %rename($ignore) obs_hotkey_register_encoder;
[build]   %rename($ignore) obs_hotkey_register_output;
[build]   %rename($ignore) obs_hotkey_register_service;
[build]   %rename($ignore) obs_hotkey_register_source;
[build]   %rename($ignore) obs_hotkey_pair_register_frontend;
[build]   %rename($ignore) obs_hotkey_pair_register_encoder;
[build]   %rename($ignore) obs_hotkey_pair_register_output;
[build]   %rename($ignore) obs_hotkey_pair_register_service;
[build]   %rename($ignore) obs_hotkey_pair_register_source;
[build]   
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\graphics\\graphics.h" %beginfile
[build]   /******************************************************************************
[build]       Copyright (C) 2013 by Hugh Bailey <obs.jim@gmail.com>
[build]   
[build]       This program is free software: you can redistribute it and/or modify
[build]       it under the terms of the GNU General Public License as published by
[build]       the Free Software Foundation, either version 2 of the License, or
[build]       (at your option) any later version.
[build]   
[build]       This program is distributed in the hope that it will be useful,
[build]       but WITHOUT ANY WARRANTY; without even the implied warranty of
[build]       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
[build]       GNU General Public License for more details.
[build]   
[build]       You should have received a copy of the GNU General Public License
[build]       along with this program.  If not, see <http://www.gnu.org/licenses/>.
[build]   ******************************************************************************/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*
[build]    * This is an API-independent graphics subsystem wrapper.
[build]    *
[build]    *   This allows the use of OpenGL and different Direct3D versions through
[build]    * one shared interface.
[build]    */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %constant GS_MAX_TEXTURES = 8;
[build]   
[build]   struct vec2;
[build]   struct vec3;
[build]   struct vec4;
[build]   struct quat;
[build]   struct axisang;
[build]   struct plane;
[build]   struct matrix3;
[build]   struct matrix4;
[build]   
[build]   enum gs_draw_mode {
[build]   	GS_POINTS,
[build]   	GS_LINES,
[build]   	GS_LINESTRIP,
[build]   	GS_TRIS,
[build]   	GS_TRISTRIP,
[build]   };
[build]   
[build]   enum gs_color_format {
[build]   	GS_UNKNOWN,
[build]   	GS_A8,
[build]   	GS_R8,
[build]   	GS_RGBA,
[build]   	GS_BGRX,
[build]   	GS_BGRA,
[build]   	GS_R10G10B10A2,
[build]   	GS_RGBA16,
[build]   	GS_R16,
[build]   	GS_RGBA16F,
[build]   	GS_RGBA32F,
[build]   	GS_RG16F,
[build]   	GS_RG32F,
[build]   	GS_R16F,
[build]   	GS_R32F,
[build]   	GS_DXT1,
[build]   	GS_DXT3,
[build]   	GS_DXT5,
[build]   	GS_R8G8,
[build]   };
[build]   
[build]   enum gs_zstencil_format {
[build]   	GS_ZS_NONE,
[build]   	GS_Z16,
[build]   	GS_Z24_S8,
[build]   	GS_Z32F,
[build]   	GS_Z32F_S8X24,
[build]   };
[build]   
[build]   enum gs_index_type {
[build]   	GS_UNSIGNED_SHORT,
[build]   	GS_UNSIGNED_LONG,
[build]   };
[build]   
[build]   enum gs_cull_mode {
[build]   	GS_BACK,
[build]   	GS_FRONT,
[build]   	GS_NEITHER,
[build]   };
[build]   
[build]   enum gs_blend_type {
[build]   	GS_BLEND_ZERO,
[build]   	GS_BLEND_ONE,
[build]   	GS_BLEND_SRCCOLOR,
[build]   	GS_BLEND_INVSRCCOLOR,
[build]   	GS_BLEND_SRCALPHA,
[build]   	GS_BLEND_INVSRCALPHA,
[build]   	GS_BLEND_DSTCOLOR,
[build]   	GS_BLEND_INVDSTCOLOR,
[build]   	GS_BLEND_DSTALPHA,
[build]   	GS_BLEND_INVDSTALPHA,
[build]   	GS_BLEND_SRCALPHASAT,
[build]   };
[build]   
[build]   enum gs_depth_test {
[build]   	GS_NEVER,
[build]   	GS_LESS,
[build]   	GS_LEQUAL,
[build]   	GS_EQUAL,
[build]   	GS_GEQUAL,
[build]   	GS_GREATER,
[build]   	GS_NOTEQUAL,
[build]   	GS_ALWAYS,
[build]   };
[build]   
[build]   enum gs_stencil_side {
[build]   	GS_STENCIL_FRONT = 1,
[build]   	GS_STENCIL_BACK,
[build]   	GS_STENCIL_BOTH,
[build]   };
[build]   
[build]   enum gs_stencil_op_type {
[build]   	GS_KEEP,
[build]   	GS_ZERO,
[build]   	GS_REPLACE,
[build]   	GS_INCR,
[build]   	GS_DECR,
[build]   	GS_INVERT,
[build]   };
[build]   
[build]   enum gs_cube_sides {
[build]   	GS_POSITIVE_X,
[build]   	GS_NEGATIVE_X,
[build]   	GS_POSITIVE_Y,
[build]   	GS_NEGATIVE_Y,
[build]   	GS_POSITIVE_Z,
[build]   	GS_NEGATIVE_Z,
[build]   };
[build]   
[build]   enum gs_sample_filter {
[build]   	GS_FILTER_POINT,
[build]   	GS_FILTER_LINEAR,
[build]   	GS_FILTER_ANISOTROPIC,
[build]   	GS_FILTER_MIN_MAG_POINT_MIP_LINEAR,
[build]   	GS_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT,
[build]   	GS_FILTER_MIN_POINT_MAG_MIP_LINEAR,
[build]   	GS_FILTER_MIN_LINEAR_MAG_MIP_POINT,
[build]   	GS_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR,
[build]   	GS_FILTER_MIN_MAG_LINEAR_MIP_POINT,
[build]   };
[build]   
[build]   enum gs_address_mode {
[build]   	GS_ADDRESS_CLAMP,
[build]   	GS_ADDRESS_WRAP,
[build]   	GS_ADDRESS_MIRROR,
[build]   	GS_ADDRESS_BORDER,
[build]   	GS_ADDRESS_MIRRORONCE,
[build]   };
[build]   
[build]   enum gs_texture_type {
[build]   	GS_TEXTURE_2D,
[build]   	GS_TEXTURE_3D,
[build]   	GS_TEXTURE_CUBE,
[build]   };
[build]   
[build]   struct gs_device_loss {
[build]   	void (*device_loss_release)(void *data);
[build]   	void (*device_loss_rebuild)(void *device, void *data);
[build]   	void *data;
[build]   };
[build]   
[build]   struct gs_monitor_info {
[build]   	int rotation_degrees;
[build]   	long x;
[build]   	long y;
[build]   	long cx;
[build]   	long cy;
[build]   };
[build]   
[build]   struct gs_tvertarray {
[build]   	size_t width;
[build]   	void *array;
[build]   };
[build]   
[build]   struct gs_vb_data {
[build]   	size_t num;
[build]   	struct vec3 *points;
[build]   	struct vec3 *normals;
[build]   	struct vec3 *tangents;
[build]   	uint32_t *colors;
[build]   
[build]   	size_t num_tex;
[build]   	struct gs_tvertarray *tvarray;
[build]   };
[build]   
[build]   static inline struct gs_vb_data *gs_vbdata_create(void)
[build]   {
[build]   	return (struct gs_vb_data *)bzalloc(sizeof(struct gs_vb_data));
[build]   }
[build]   
[build]   static inline void gs_vbdata_destroy(struct gs_vb_data *data)
[build]   {
[build]   	uint32_t i;
[build]   	if (!data)
[build]   		return;
[build]   
[build]   	bfree(data->points);
[build]   	bfree(data->normals);
[build]   	bfree(data->tangents);
[build]   	bfree(data->colors);
[build]   	for (i = 0; i < data->num_tex; i++)
[build]   		bfree(data->tvarray[i].array);
[build]   	bfree(data->tvarray);
[build]   	bfree(data);
[build]   }
[build]   
[build]   struct gs_sampler_info {
[build]   	enum gs_sample_filter filter;
[build]   	enum gs_address_mode address_u;
[build]   	enum gs_address_mode address_v;
[build]   	enum gs_address_mode address_w;
[build]   	int max_anisotropy;
[build]   	uint32_t border_color;
[build]   };
[build]   
[build]   struct gs_display_mode {
[build]   	uint32_t width;
[build]   	uint32_t height;
[build]   	uint32_t bits;
[build]   	uint32_t freq;
[build]   };
[build]   
[build]   struct gs_rect {
[build]   	int x;
[build]   	int y;
[build]   	int cx;
[build]   	int cy;
[build]   };
[build]   
[build]   /* wrapped opaque data types */
[build]   
[build]   struct gs_texture;
[build]   struct gs_stage_surface;
[build]   struct gs_zstencil_buffer;
[build]   struct gs_vertex_buffer;
[build]   struct gs_index_buffer;
[build]   struct gs_sampler_state;
[build]   struct gs_shader;
[build]   struct gs_swap_chain;
[build]   struct gs_timer;
[build]   struct gs_texrender;
[build]   struct gs_shader_param;
[build]   struct gs_effect;
[build]   struct gs_effect_technique;
[build]   struct gs_effect_pass;
[build]   struct gs_effect_param;
[build]   struct gs_device;
[build]   struct graphics_subsystem;
[build]   
[build]   typedef struct gs_texture gs_texture_t;
[build]   typedef struct gs_stage_surface gs_stagesurf_t;
[build]   typedef struct gs_zstencil_buffer gs_zstencil_t;
[build]   typedef struct gs_vertex_buffer gs_vertbuffer_t;
[build]   typedef struct gs_index_buffer gs_indexbuffer_t;
[build]   typedef struct gs_sampler_state gs_samplerstate_t;
[build]   typedef struct gs_swap_chain gs_swapchain_t;
[build]   typedef struct gs_timer gs_timer_t;
[build]   typedef struct gs_timer_range gs_timer_range_t;
[build]   typedef struct gs_texture_render gs_texrender_t;
[build]   typedef struct gs_shader gs_shader_t;
[build]   typedef struct gs_shader_param gs_sparam_t;
[build]   typedef struct gs_effect gs_effect_t;
[build]   typedef struct gs_effect_technique gs_technique_t;
[build]   typedef struct gs_effect_pass gs_epass_t;
[build]   typedef struct gs_effect_param gs_eparam_t;
[build]   typedef struct gs_device gs_device_t;
[build]   typedef struct graphics_subsystem graphics_t;
[build]   
[build]   /* ---------------------------------------------------
[build]    * shader functions
[build]    * --------------------------------------------------- */
[build]   
[build]   enum gs_shader_param_type {
[build]   	GS_SHADER_PARAM_UNKNOWN,
[build]   	GS_SHADER_PARAM_BOOL,
[build]   	GS_SHADER_PARAM_FLOAT,
[build]   	GS_SHADER_PARAM_INT,
[build]   	GS_SHADER_PARAM_STRING,
[build]   	GS_SHADER_PARAM_VEC2,
[build]   	GS_SHADER_PARAM_VEC3,
[build]   	GS_SHADER_PARAM_VEC4,
[build]   	GS_SHADER_PARAM_INT2,
[build]   	GS_SHADER_PARAM_INT3,
[build]   	GS_SHADER_PARAM_INT4,
[build]   	GS_SHADER_PARAM_MATRIX4X4,
[build]   	GS_SHADER_PARAM_TEXTURE,
[build]   };
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ---------------------------------------------------
[build]    * effect functions
[build]    * --------------------------------------------------- */
[build]   
[build]   /*enum gs_effect_property_type {
[build]   	GS_EFFECT_NONE,
[build]   	GS_EFFECT_BOOL,
[build]   	GS_EFFECT_FLOAT,
[build]   	GS_EFFECT_COLOR,
[build]   	GS_EFFECT_TEXTURE
[build]   };*/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]    void gs_effect_destroy(gs_effect_t *effect);
[build]   
[build]    gs_technique_t *gs_effect_get_technique(const gs_effect_t *effect,
[build]   					       const char *name);
[build]   
[build]    gs_technique_t *
[build]   gs_effect_get_current_technique(const gs_effect_t *effect);
[build]   
[build]    size_t gs_technique_begin(gs_technique_t *technique);
[build]    void gs_technique_end(gs_technique_t *technique);
[build]    bool gs_technique_begin_pass(gs_technique_t *technique, size_t pass);
[build]    bool gs_technique_begin_pass_by_name(gs_technique_t *technique,
[build]   					    const char *name);
[build]    void gs_technique_end_pass(gs_technique_t *technique);
[build]    gs_epass_t *gs_technique_get_pass_by_idx(const gs_technique_t *technique,
[build]   						size_t pass);
[build]    gs_epass_t *
[build]   gs_technique_get_pass_by_name(const gs_technique_t *technique,
[build]   			      const char *name);
[build]   
[build]    size_t gs_effect_get_num_params(const gs_effect_t *effect);
[build]    gs_eparam_t *gs_effect_get_param_by_idx(const gs_effect_t *effect,
[build]   					       size_t param);
[build]    gs_eparam_t *gs_effect_get_param_by_name(const gs_effect_t *effect,
[build]   						const char *name);
[build]    size_t gs_param_get_num_annotations(const gs_eparam_t *param);
[build]    gs_eparam_t *gs_param_get_annotation_by_idx(const gs_eparam_t *param,
[build]   						   size_t annotation);
[build]    gs_eparam_t *gs_param_get_annotation_by_name(const gs_eparam_t *param,
[build]   						    const char *name);
[build]   
[build]   /** Helper function to simplify effect usage.  Use with a while loop that
[build]    * contains drawing functions.  Automatically handles techniques, passes, and
[build]    * unloading. */
[build]    bool gs_effect_loop(gs_effect_t *effect, const char *name);
[build]   
[build]   /** used internally */
[build]    void gs_effect_update_params(gs_effect_t *effect);
[build]   
[build]    gs_eparam_t *gs_effect_get_viewproj_matrix(const gs_effect_t *effect);
[build]    gs_eparam_t *gs_effect_get_world_matrix(const gs_effect_t *effect);
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]    void gs_effect_set_bool(gs_eparam_t *param, bool val);
[build]    void gs_effect_set_float(gs_eparam_t *param, float val);
[build]    void gs_effect_set_int(gs_eparam_t *param, int val);
[build]    void gs_effect_set_matrix4(gs_eparam_t *param,
[build]   				  const struct matrix4 *val);
[build]    void gs_effect_set_vec2(gs_eparam_t *param, const struct vec2 *val);
[build]    void gs_effect_set_vec3(gs_eparam_t *param, const struct vec3 *val);
[build]    void gs_effect_set_vec4(gs_eparam_t *param, const struct vec4 *val);
[build]    void gs_effect_set_texture(gs_eparam_t *param, gs_texture_t *val);
[build]    void gs_effect_set_val(gs_eparam_t *param, const void *val, size_t size);
[build]    void gs_effect_set_default(gs_eparam_t *param);
[build]    size_t gs_effect_get_val_size(gs_eparam_t *param);
[build]    void *gs_effect_get_val(gs_eparam_t *param);
[build]    size_t gs_effect_get_default_val_size(gs_eparam_t *param);
[build]    void *gs_effect_get_default_val(gs_eparam_t *param);
[build]    void gs_effect_set_next_sampler(gs_eparam_t *param,
[build]   				       gs_samplerstate_t *sampler);
[build]   
[build]    void gs_effect_set_color(gs_eparam_t *param, uint32_t argb);
[build]   
[build]   /* ---------------------------------------------------
[build]    * texture render helper functions
[build]    * --------------------------------------------------- */
[build]   
[build]    gs_texrender_t *gs_texrender_create(enum gs_color_format format,
[build]   					   enum gs_zstencil_format zsformat);
[build]    void gs_texrender_destroy(gs_texrender_t *texrender);
[build]    bool gs_texrender_begin(gs_texrender_t *texrender, uint32_t cx,
[build]   			       uint32_t cy);
[build]    void gs_texrender_end(gs_texrender_t *texrender);
[build]    void gs_texrender_reset(gs_texrender_t *texrender);
[build]    gs_texture_t *gs_texrender_get_texture(const gs_texrender_t *texrender);
[build]   
[build]   /* ---------------------------------------------------
[build]    * graphics subsystem
[build]    * --------------------------------------------------- */
[build]   
[build]   %constant GS_BUILD_MIPMAPS = (1 << 0);
[build]   %constant GS_DYNAMIC = (1 << 1);
[build]   %constant GS_RENDER_TARGET = (1 << 2);
[build]   %constant GS_GL_DUMMYTEX = (1 << 3); /**<< texture with no allocated texture data */
[build]   %constant GS_DUP_BUFFER =  	(1 << 4); /**<< do not pass buffer ownership when
[build]   				 *    creating a vertex/index buffer */
[build]   
[build]   %constant GS_SHARED_TEX = (1 << 5);
[build]   %constant GS_SHARED_KM_TEX = (1 << 6);
[build]   
[build]   /* ---------------- */
[build]   /* global functions */
[build]   
[build]   %constant GS_SUCCESS = 0;
[build]   %constant GS_ERROR_FAIL = -1;
[build]   %constant GS_ERROR_MODULE_NOT_FOUND = -2;
[build]   %constant GS_ERROR_NOT_SUPPORTED = -3;
[build]   
[build]   struct gs_window {
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   };
[build]   
[build]   struct gs_init_data {
[build]   	struct gs_window window;
[build]   	uint32_t cx, cy;
[build]   	uint32_t num_backbuffers;
[build]   	enum gs_color_format format;
[build]   	enum gs_zstencil_format zsformat;
[build]   	uint32_t adapter;
[build]   };
[build]   
[build]   %constant GS_DEVICE_OPENGL = 1;
[build]   %constant GS_DEVICE_DIRECT3D_11 = 2;
[build]   
[build]    const char *gs_get_device_name(void);
[build]    int gs_get_device_type(void);
[build]    void gs_enum_adapters(bool (*callback)(void *param, const char *name,
[build]   					      uint32_t id),
[build]   			     void *param);
[build]   
[build]    int gs_create(graphics_t **graphics, const char *module,
[build]   		     uint32_t adapter);
[build]    void gs_destroy(graphics_t *graphics);
[build]   
[build]    void gs_enter_context(graphics_t *graphics);
[build]    void gs_leave_context(void);
[build]    graphics_t *gs_get_context(void);
[build]    void *gs_get_device_obj(void);
[build]   
[build]    void gs_matrix_push(void);
[build]    void gs_matrix_pop(void);
[build]    void gs_matrix_identity(void);
[build]    void gs_matrix_transpose(void);
[build]    void gs_matrix_set(const struct matrix4 *matrix);
[build]    void gs_matrix_get(struct matrix4 *dst);
[build]    void gs_matrix_mul(const struct matrix4 *matrix);
[build]    void gs_matrix_rotquat(const struct quat *rot);
[build]    void gs_matrix_rotaa(const struct axisang *rot);
[build]    void gs_matrix_translate(const struct vec3 *pos);
[build]    void gs_matrix_scale(const struct vec3 *scale);
[build]    void gs_matrix_rotaa4f(float x, float y, float z, float angle);
[build]    void gs_matrix_translate3f(float x, float y, float z);
[build]    void gs_matrix_scale3f(float x, float y, float z);
[build]   
[build]    void gs_render_start(bool b_new);
[build]    void gs_render_stop(enum gs_draw_mode mode);
[build]    gs_vertbuffer_t *gs_render_save(void);
[build]    void gs_vertex2f(float x, float y);
[build]    void gs_vertex3f(float x, float y, float z);
[build]    void gs_normal3f(float x, float y, float z);
[build]    void gs_color(uint32_t color);
[build]    void gs_texcoord(float x, float y, int unit);
[build]    void gs_vertex2v(const struct vec2 *v);
[build]    void gs_vertex3v(const struct vec3 *v);
[build]    void gs_normal3v(const struct vec3 *v);
[build]    void gs_color4v(const struct vec4 *v);
[build]    void gs_texcoord2v(const struct vec2 *v, int unit);
[build]   
[build]    input_t *gs_get_input(void);
[build]    gs_effect_t *gs_get_effect(void);
[build]   
[build]    gs_effect_t *gs_effect_create_from_file(const char *file,
[build]   					       char **error_string);
[build]    gs_effect_t *gs_effect_create(const char *effect_string,
[build]   				     const char *filename, char **error_string);
[build]   
[build]    gs_shader_t *gs_vertexshader_create_from_file(const char *file,
[build]   						     char **error_string);
[build]    gs_shader_t *gs_pixelshader_create_from_file(const char *file,
[build]   						    char **error_string);
[build]   
[build]    gs_texture_t *gs_texture_create_from_file(const char *file);
[build]    uint8_t *gs_create_texture_file_data(const char *file,
[build]   					    enum gs_color_format *format,
[build]   					    uint32_t *cx, uint32_t *cy);
[build]   
[build]   %constant GS_FLIP_U = (1 << 0);
[build]   %constant GS_FLIP_V = (1 << 1);
[build]   
[build]   /**
[build]    * Draws a 2D sprite
[build]    *
[build]    *   If width or height is 0, the width or height of the texture will be used.
[build]    * The flip value specifies whether the texture should be flipped on the U or V
[build]    * axis with GS_FLIP_U and GS_FLIP_V.
[build]    */
[build]    void gs_draw_sprite(gs_texture_t *tex, uint32_t flip, uint32_t width,
[build]   			   uint32_t height);
[build]   
[build]    void gs_draw_sprite_subregion(gs_texture_t *tex, uint32_t flip,
[build]   				     uint32_t x, uint32_t y, uint32_t cx,
[build]   				     uint32_t cy);
[build]   
[build]    void gs_draw_cube_backdrop(gs_texture_t *cubetex, const struct quat *rot,
[build]   				  float left, float right, float top,
[build]   				  float bottom, float znear);
[build]   
[build]   /** sets the viewport to current swap chain size */
[build]    void gs_reset_viewport(void);
[build]   
[build]   /** sets default screen-sized orthographic mode */
[build]    void gs_set_2d_mode(void);
[build]   /** sets default screen-sized perspective mode */
[build]    void gs_set_3d_mode(double fovy, double znear, double zvar);
[build]   
[build]    void gs_viewport_push(void);
[build]    void gs_viewport_pop(void);
[build]   
[build]    void gs_texture_set_image(gs_texture_t *tex, const uint8_t *data,
[build]   				 uint32_t linesize, bool invert);
[build]    void gs_cubetexture_set_image(gs_texture_t *cubetex, uint32_t side,
[build]   				     const void *data, uint32_t linesize,
[build]   				     bool invert);
[build]   
[build]    void gs_perspective(float fovy, float aspect, float znear, float zfar);
[build]   
[build]    void gs_blend_state_push(void);
[build]    void gs_blend_state_pop(void);
[build]    void gs_reset_blend_state(void);
[build]   
[build]   /* -------------------------- */
[build]   /* library-specific functions */
[build]   
[build]    gs_swapchain_t *gs_swapchain_create(const struct gs_init_data *data);
[build]   
[build]    void gs_resize(uint32_t x, uint32_t y);
[build]    void gs_get_size(uint32_t *x, uint32_t *y);
[build]    uint32_t gs_get_width(void);
[build]    uint32_t gs_get_height(void);
[build]   
[build]    gs_texture_t *gs_texture_create(uint32_t width, uint32_t height,
[build]   				       enum gs_color_format color_format,
[build]   				       uint32_t levels, const uint8_t **data,
[build]   				       uint32_t flags);
[build]    gs_texture_t *
[build]   gs_cubetexture_create(uint32_t size, enum gs_color_format color_format,
[build]   		      uint32_t levels, const uint8_t **data, uint32_t flags);
[build]    gs_texture_t *gs_voltexture_create(uint32_t width, uint32_t height,
[build]   					  uint32_t depth,
[build]   					  enum gs_color_format color_format,
[build]   					  uint32_t levels, const uint8_t **data,
[build]   					  uint32_t flags);
[build]   
[build]    gs_zstencil_t *gs_zstencil_create(uint32_t width, uint32_t height,
[build]   					 enum gs_zstencil_format format);
[build]   
[build]    gs_stagesurf_t *
[build]   gs_stagesurface_create(uint32_t width, uint32_t height,
[build]   		       enum gs_color_format color_format);
[build]   
[build]    gs_samplerstate_t *
[build]   gs_samplerstate_create(const struct gs_sampler_info *info);
[build]   
[build]    gs_shader_t *gs_vertexshader_create(const char *shader, const char *file,
[build]   					   char **error_string);
[build]    gs_shader_t *gs_pixelshader_create(const char *shader, const char *file,
[build]   					  char **error_string);
[build]   
[build]    gs_vertbuffer_t *gs_vertexbuffer_create(struct gs_vb_data *data,
[build]   					       uint32_t flags);
[build]    gs_indexbuffer_t *gs_indexbuffer_create(enum gs_index_type type,
[build]   					       void *indices, size_t num,
[build]   					       uint32_t flags);
[build]   
[build]    gs_timer_t *gs_timer_create();
[build]    gs_timer_range_t *gs_timer_range_create();
[build]   
[build]    enum gs_texture_type gs_get_texture_type(const gs_texture_t *texture);
[build]   
[build]    void gs_load_vertexbuffer(gs_vertbuffer_t *vertbuffer);
[build]    void gs_load_indexbuffer(gs_indexbuffer_t *indexbuffer);
[build]    void gs_load_texture(gs_texture_t *tex, int unit);
[build]    void gs_load_samplerstate(gs_samplerstate_t *samplerstate, int unit);
[build]    void gs_load_vertexshader(gs_shader_t *vertshader);
[build]    void gs_load_pixelshader(gs_shader_t *pixelshader);
[build]   
[build]    void gs_load_default_samplerstate(bool b_3d, int unit);
[build]   
[build]    gs_shader_t *gs_get_vertex_shader(void);
[build]    gs_shader_t *gs_get_pixel_shader(void);
[build]   
[build]    gs_texture_t *gs_get_render_target(void);
[build]    gs_zstencil_t *gs_get_zstencil_target(void);
[build]   
[build]    void gs_set_render_target(gs_texture_t *tex, gs_zstencil_t *zstencil);
[build]    void gs_set_cube_render_target(gs_texture_t *cubetex, int side,
[build]   				      gs_zstencil_t *zstencil);
[build]   
[build]    void gs_copy_texture(gs_texture_t *dst, gs_texture_t *src);
[build]    void gs_copy_texture_region(gs_texture_t *dst, uint32_t dst_x,
[build]   				   uint32_t dst_y, gs_texture_t *src,
[build]   				   uint32_t src_x, uint32_t src_y,
[build]   				   uint32_t src_w, uint32_t src_h);
[build]    void gs_stage_texture(gs_stagesurf_t *dst, gs_texture_t *src);
[build]   
[build]    void gs_begin_frame(void);
[build]    void gs_begin_scene(void);
[build]    void gs_draw(enum gs_draw_mode draw_mode, uint32_t start_vert,
[build]   		    uint32_t num_verts);
[build]    void gs_end_scene(void);
[build]   
[build]   %constant GS_CLEAR_COLOR = (1 << 0);
[build]   %constant GS_CLEAR_DEPTH = (1 << 1);
[build]   %constant GS_CLEAR_STENCIL = (1 << 2);
[build]   
[build]    void gs_load_swapchain(gs_swapchain_t *swapchain);
[build]    void gs_clear(uint32_t clear_flags, const struct vec4 *color,
[build]   		     float depth, uint8_t stencil);
[build]    void gs_present(void);
[build]    void gs_flush(void);
[build]   
[build]    void gs_set_cull_mode(enum gs_cull_mode mode);
[build]    enum gs_cull_mode gs_get_cull_mode(void);
[build]   
[build]    void gs_enable_blending(bool enable);
[build]    void gs_enable_depth_test(bool enable);
[build]    void gs_enable_stencil_test(bool enable);
[build]    void gs_enable_stencil_write(bool enable);
[build]    void gs_enable_color(bool red, bool green, bool blue, bool alpha);
[build]   
[build]    void gs_blend_function(enum gs_blend_type src, enum gs_blend_type dest);
[build]    void gs_blend_function_separate(enum gs_blend_type src_c,
[build]   				       enum gs_blend_type dest_c,
[build]   				       enum gs_blend_type src_a,
[build]   				       enum gs_blend_type dest_a);
[build]    void gs_depth_function(enum gs_depth_test test);
[build]   
[build]    void gs_stencil_function(enum gs_stencil_side side,
[build]   				enum gs_depth_test test);
[build]    void gs_stencil_op(enum gs_stencil_side side,
[build]   			  enum gs_stencil_op_type fail,
[build]   			  enum gs_stencil_op_type zfail,
[build]   			  enum gs_stencil_op_type zpass);
[build]   
[build]    void gs_set_viewport(int x, int y, int width, int height);
[build]    void gs_get_viewport(struct gs_rect *rect);
[build]    void gs_set_scissor_rect(const struct gs_rect *rect);
[build]   
[build]    void gs_ortho(float left, float right, float top, float bottom,
[build]   		     float znear, float zfar);
[build]    void gs_frustum(float left, float right, float top, float bottom,
[build]   		       float znear, float zfar);
[build]   
[build]    void gs_projection_push(void);
[build]    void gs_projection_pop(void);
[build]   
[build]    void gs_swapchain_destroy(gs_swapchain_t *swapchain);
[build]   
[build]    void gs_texture_destroy(gs_texture_t *tex);
[build]    uint32_t gs_texture_get_width(const gs_texture_t *tex);
[build]    uint32_t gs_texture_get_height(const gs_texture_t *tex);
[build]    enum gs_color_format
[build]   gs_texture_get_color_format(const gs_texture_t *tex);
[build]    bool gs_texture_map(gs_texture_t *tex, uint8_t **ptr,
[build]   			   uint32_t *linesize);
[build]    void gs_texture_unmap(gs_texture_t *tex);
[build]   /** special-case function (GL only) - specifies whether the texture is a
[build]    * GL_TEXTURE_RECTANGLE type, which doesn't use normalized texture
[build]    * coordinates, doesn't support mipmapping, and requires address clamping */
[build]    bool gs_texture_is_rect(const gs_texture_t *tex);
[build]   /**
[build]    * Gets a pointer to the context-specific object associated with the texture.
[build]    * For example, for GL, this is a GLuint*.  For D3D11, ID3D11Texture2D*.
[build]    */
[build]    void *gs_texture_get_obj(gs_texture_t *tex);
[build]   
[build]    void gs_cubetexture_destroy(gs_texture_t *cubetex);
[build]    uint32_t gs_cubetexture_get_size(const gs_texture_t *cubetex);
[build]    enum gs_color_format
[build]   gs_cubetexture_get_color_format(const gs_texture_t *cubetex);
[build]   
[build]    void gs_voltexture_destroy(gs_texture_t *voltex);
[build]    uint32_t gs_voltexture_get_width(const gs_texture_t *voltex);
[build]    uint32_t gs_voltexture_get_height(const gs_texture_t *voltex);
[build]    uint32_t gs_voltexture_get_depth(const gs_texture_t *voltex);
[build]    enum gs_color_format
[build]   gs_voltexture_get_color_format(const gs_texture_t *voltex);
[build]   
[build]    void gs_stagesurface_destroy(gs_stagesurf_t *stagesurf);
[build]    uint32_t gs_stagesurface_get_width(const gs_stagesurf_t *stagesurf);
[build]    uint32_t gs_stagesurface_get_height(const gs_stagesurf_t *stagesurf);
[build]    enum gs_color_format
[build]   gs_stagesurface_get_color_format(const gs_stagesurf_t *stagesurf);
[build]    bool gs_stagesurface_map(gs_stagesurf_t *stagesurf, uint8_t **data,
[build]   				uint32_t *linesize);
[build]    void gs_stagesurface_unmap(gs_stagesurf_t *stagesurf);
[build]   
[build]    void gs_zstencil_destroy(gs_zstencil_t *zstencil);
[build]   
[build]    void gs_samplerstate_destroy(gs_samplerstate_t *samplerstate);
[build]   
[build]    void gs_vertexbuffer_destroy(gs_vertbuffer_t *vertbuffer);
[build]    void gs_vertexbuffer_flush(gs_vertbuffer_t *vertbuffer);
[build]    void gs_vertexbuffer_flush_direct(gs_vertbuffer_t *vertbuffer,
[build]   					 const struct gs_vb_data *data);
[build]    struct gs_vb_data *
[build]   gs_vertexbuffer_get_data(const gs_vertbuffer_t *vertbuffer);
[build]   
[build]    void gs_indexbuffer_destroy(gs_indexbuffer_t *indexbuffer);
[build]    void gs_indexbuffer_flush(gs_indexbuffer_t *indexbuffer);
[build]    void gs_indexbuffer_flush_direct(gs_indexbuffer_t *indexbuffer,
[build]   					const void *data);
[build]    void *gs_indexbuffer_get_data(const gs_indexbuffer_t *indexbuffer);
[build]    size_t
[build]   gs_indexbuffer_get_num_indices(const gs_indexbuffer_t *indexbuffer);
[build]    enum gs_index_type
[build]   gs_indexbuffer_get_type(const gs_indexbuffer_t *indexbuffer);
[build]   
[build]    void gs_timer_destroy(gs_timer_t *timer);
[build]    void gs_timer_begin(gs_timer_t *timer);
[build]    void gs_timer_end(gs_timer_t *timer);
[build]    bool gs_timer_get_data(gs_timer_t *timer, uint64_t *ticks);
[build]    void gs_timer_range_destroy(gs_timer_range_t *timer);
[build]    void gs_timer_range_begin(gs_timer_range_t *range);
[build]    void gs_timer_range_end(gs_timer_range_t *range);
[build]    bool gs_timer_range_get_data(gs_timer_range_t *range, bool *disjoint,
[build]   				    uint64_t *frequency);
[build]   
[build]    bool gs_nv12_available(void);
[build]   
[build]   %constant GS_USE_DEBUG_MARKERS = 0;
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]    void gs_debug_marker_begin(const float color[4], const char *markername);
[build]    void gs_debug_marker_begin_format(const float color[4],
[build]   					 const char *format, ...);
[build]    void gs_debug_marker_end(void);
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* inline functions used by modules */
[build]   
[build]   static inline uint32_t gs_get_format_bpp(enum gs_color_format format)
[build]   {
[build]   	switch (format) {
[build]   	case GS_A8:
[build]   		return 8;
[build]   	case GS_R8:
[build]   		return 8;
[build]   	case GS_RGBA:
[build]   		return 32;
[build]   	case GS_BGRX:
[build]   		return 32;
[build]   	case GS_BGRA:
[build]   		return 32;
[build]   	case GS_R10G10B10A2:
[build]   		return 32;
[build]   	case GS_RGBA16:
[build]   		return 64;
[build]   	case GS_R16:
[build]   		return 16;
[build]   	case GS_RGBA16F:
[build]   		return 64;
[build]   	case GS_RGBA32F:
[build]   		return 128;
[build]   	case GS_RG16F:
[build]   		return 32;
[build]   	case GS_RG32F:
[build]   		return 64;
[build]   	case GS_R16F:
[build]   		return 16;
[build]   	case GS_R32F:
[build]   		return 32;
[build]   	case GS_DXT1:
[build]   		return 4;
[build]   	case GS_DXT3:
[build]   		return 8;
[build]   	case GS_DXT5:
[build]   		return 8;
[build]   	case GS_R8G8:
[build]   		return 16;
[build]   	case GS_UNKNOWN:
[build]   		return 0;
[build]   	}
[build]   
[build]   	return 0;
[build]   }
[build]   
[build]   static inline bool gs_is_compressed_format(enum gs_color_format format)
[build]   {
[build]   	return (format == GS_DXT1 || format == GS_DXT3 || format == GS_DXT5);
[build]   }
[build]   
[build]   static inline uint32_t gs_get_total_levels(uint32_t width, uint32_t height,
[build]   					   uint32_t depth)
[build]   {
[build]   	uint32_t size = width > height ? width : height;
[build]   	size = size > depth ? size : depth;
[build]   	uint32_t num_levels = 1;
[build]   
[build]   	while (size > 1) {
[build]   		size /= 2;
[build]   		num_levels++;
[build]   	}
[build]   
[build]   	return num_levels;
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\graphics\\vec4.h" %beginfile
[build]   /******************************************************************************
[build]       Copyright (C) 2013 by Hugh Bailey <obs.jim@gmail.com>
[build]   
[build]       This program is free software: you can redistribute it and/or modify
[build]       it under the terms of the GNU General Public License as published by
[build]       the Free Software Foundation, either version 2 of the License, or
[build]       (at your option) any later version.
[build]   
[build]       This program is distributed in the hope that it will be useful,
[build]       but WITHOUT ANY WARRANTY; without even the implied warranty of
[build]       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
[build]       GNU General Public License for more details.
[build]   
[build]       You should have received a copy of the GNU General Public License
[build]       along with this program.  If not, see <http://www.gnu.org/licenses/>.
[build]   ******************************************************************************/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   struct vec3;
[build]   struct matrix4;
[build]   
[build]   struct vec4 {
[build]   	union {
[build]   		struct {
[build]   			float x, y, z, w;
[build]   		};
[build]   		float ptr[4];
[build]   		__m128 m;
[build]   	};
[build]   };
[build]   
[build]   static inline void vec4_zero(struct vec4 *v)
[build]   {
[build]   	v->m = _mm_setzero_ps();
[build]   }
[build]   
[build]   static inline void vec4_set(struct vec4 *dst, float x, float y, float z,
[build]   			    float w)
[build]   {
[build]   	dst->m = _mm_set_ps(w, z, y, x);
[build]   }
[build]   
[build]   static inline void vec4_copy(struct vec4 *dst, const struct vec4 *v)
[build]   {
[build]   	dst->m = v->m;
[build]   }
[build]   
[build]    void vec4_from_vec3(struct vec4 *dst, const struct vec3 *v);
[build]   
[build]   static inline void vec4_add(struct vec4 *dst, const struct vec4 *v1,
[build]   			    const struct vec4 *v2)
[build]   {
[build]   	dst->m = _mm_add_ps(v1->m, v2->m);
[build]   }
[build]   
[build]   static inline void vec4_sub(struct vec4 *dst, const struct vec4 *v1,
[build]   			    const struct vec4 *v2)
[build]   {
[build]   	dst->m = _mm_sub_ps(v1->m, v2->m);
[build]   }
[build]   
[build]   static inline void vec4_mul(struct vec4 *dst, const struct vec4 *v1,
[build]   			    const struct vec4 *v2)
[build]   {
[build]   	dst->m = _mm_mul_ps(v1->m, v2->m);
[build]   }
[build]   
[build]   static inline void vec4_div(struct vec4 *dst, const struct vec4 *v1,
[build]   			    const struct vec4 *v2)
[build]   {
[build]   	dst->m = _mm_div_ps(v1->m, v2->m);
[build]   }
[build]   
[build]   static inline void vec4_addf(struct vec4 *dst, const struct vec4 *v, float f)
[build]   {
[build]   	dst->m = _mm_add_ps(v->m, _mm_set1_ps(f));
[build]   }
[build]   
[build]   static inline void vec4_subf(struct vec4 *dst, const struct vec4 *v, float f)
[build]   {
[build]   	dst->m = _mm_sub_ps(v->m, _mm_set1_ps(f));
[build]   }
[build]   
[build]   static inline void vec4_mulf(struct vec4 *dst, const struct vec4 *v, float f)
[build]   {
[build]   	dst->m = _mm_mul_ps(v->m, _mm_set1_ps(f));
[build]   }
[build]   
[build]   static inline void vec4_divf(struct vec4 *dst, const struct vec4 *v, float f)
[build]   {
[build]   	dst->m = _mm_div_ps(v->m, _mm_set1_ps(f));
[build]   }
[build]   
[build]   static inline float vec4_dot(const struct vec4 *v1, const struct vec4 *v2)
[build]   {
[build]   	struct vec4 add;
[build]   	__m128 mul = _mm_mul_ps(v1->m, v2->m);
[build]   	add.m = _mm_add_ps(_mm_movehl_ps(mul, mul), mul);
[build]   	add.m = _mm_add_ps(_mm_shuffle_ps(add.m, add.m, 0x55), add.m);
[build]   	return add.x;
[build]   }
[build]   
[build]   static inline void vec4_neg(struct vec4 *dst, const struct vec4 *v)
[build]   {
[build]   	dst->x = -v->x;
[build]   	dst->y = -v->y;
[build]   	dst->z = -v->z;
[build]   	dst->w = -v->w;
[build]   }
[build]   
[build]   static inline float vec4_len(const struct vec4 *v)
[build]   {
[build]   	float dot_val = vec4_dot(v, v);
[build]   	return (dot_val > 0.0f) ? sqrtf(dot_val) : 0.0f;
[build]   }
[build]   
[build]   static inline float vec4_dist(const struct vec4 *v1, const struct vec4 *v2)
[build]   {
[build]   	struct vec4 temp;
[build]   	float dot_val;
[build]   
[build]   	vec4_sub(&temp, v1, v2);
[build]   	dot_val = vec4_dot(&temp, &temp);
[build]   	return (dot_val > 0.0f) ? sqrtf(dot_val) : 0.0f;
[build]   }
[build]   
[build]   static inline void vec4_norm(struct vec4 *dst, const struct vec4 *v)
[build]   {
[build]   	float dot_val = vec4_dot(v, v);
[build]   	dst->m = (dot_val > 0.0f)
[build]   			 ? _mm_mul_ps(v->m, _mm_set1_ps(1.0f / sqrtf(dot_val)))
[build]   			 : _mm_setzero_ps();
[build]   }
[build]   
[build]   static inline int vec4_close(const struct vec4 *v1, const struct vec4 *v2,
[build]   			     float epsilon)
[build]   {
[build]   	struct vec4 test;
[build]   	vec4_sub(&test, v1, v2);
[build]   	return test.x < epsilon && test.y < epsilon && test.z < epsilon &&
[build]   	       test.w < epsilon;
[build]   }
[build]   
[build]   static inline void vec4_min(struct vec4 *dst, const struct vec4 *v1,
[build]   			    const struct vec4 *v2)
[build]   {
[build]   	dst->m = _mm_min_ps(v1->m, v2->m);
[build]   }
[build]   
[build]   static inline void vec4_minf(struct vec4 *dst, const struct vec4 *v, float f)
[build]   {
[build]   	dst->m = _mm_min_ps(v->m, _mm_set1_ps(f));
[build]   }
[build]   
[build]   static inline void vec4_max(struct vec4 *dst, const struct vec4 *v1,
[build]   			    const struct vec4 *v2)
[build]   {
[build]   	dst->m = _mm_max_ps(v1->m, v2->m);
[build]   }
[build]   
[build]   static inline void vec4_maxf(struct vec4 *dst, const struct vec4 *v, float f)
[build]   {
[build]   	dst->m = _mm_max_ps(v->m, _mm_set1_ps(f));
[build]   }
[build]   
[build]   static inline void vec4_abs(struct vec4 *dst, const struct vec4 *v)
[build]   {
[build]   	dst->x = fabsf(v->x);
[build]   	dst->y = fabsf(v->y);
[build]   	dst->z = fabsf(v->z);
[build]   	dst->w = fabsf(v->w);
[build]   }
[build]   
[build]   static inline void vec4_floor(struct vec4 *dst, const struct vec4 *v)
[build]   {
[build]   	dst->x = floorf(v->x);
[build]   	dst->y = floorf(v->y);
[build]   	dst->z = floorf(v->z);
[build]   	dst->w = floorf(v->w);
[build]   }
[build]   
[build]   static inline void vec4_ceil(struct vec4 *dst, const struct vec4 *v)
[build]   {
[build]   	dst->x = ceilf(v->x);
[build]   	dst->y = ceilf(v->y);
[build]   	dst->z = ceilf(v->z);
[build]   	dst->w = ceilf(v->w);
[build]   }
[build]   
[build]   static inline uint32_t vec4_to_rgba(const struct vec4 *src)
[build]   {
[build]   	uint32_t val;
[build]   	val = (uint32_t)((double)src->x * 255.0);
[build]   	val |= (uint32_t)((double)src->y * 255.0) << 8;
[build]   	val |= (uint32_t)((double)src->z * 255.0) << 16;
[build]   	val |= (uint32_t)((double)src->w * 255.0) << 24;
[build]   	return val;
[build]   }
[build]   
[build]   static inline uint32_t vec4_to_bgra(const struct vec4 *src)
[build]   {
[build]   	uint32_t val;
[build]   	val = (uint32_t)((double)src->z * 255.0);
[build]   	val |= (uint32_t)((double)src->y * 255.0) << 8;
[build]   	val |= (uint32_t)((double)src->x * 255.0) << 16;
[build]   	val |= (uint32_t)((double)src->w * 255.0) << 24;
[build]   	return val;
[build]   }
[build]   
[build]   static inline void vec4_from_rgba(struct vec4 *dst, uint32_t rgba)
[build]   {
[build]   	dst->x = (float)((double)(rgba & 0xFF) * (1.0 / 255.0));
[build]   	rgba >>= 8;
[build]   	dst->y = (float)((double)(rgba & 0xFF) * (1.0 / 255.0));
[build]   	rgba >>= 8;
[build]   	dst->z = (float)((double)(rgba & 0xFF) * (1.0 / 255.0));
[build]   	rgba >>= 8;
[build]   	dst->w = (float)((double)(rgba & 0xFF) * (1.0 / 255.0));
[build]   }
[build]   
[build]   static inline void vec4_from_bgra(struct vec4 *dst, uint32_t bgra)
[build]   {
[build]   	dst->z = (float)((double)(bgra & 0xFF) * (1.0 / 255.0));
[build]   	bgra >>= 8;
[build]   	dst->y = (float)((double)(bgra & 0xFF) * (1.0 / 255.0));
[build]   	bgra >>= 8;
[build]   	dst->x = (float)((double)(bgra & 0xFF) * (1.0 / 255.0));
[build]   	bgra >>= 8;
[build]   	dst->w = (float)((double)(bgra & 0xFF) * (1.0 / 255.0));
[build]   }
[build]   
[build]    void vec4_transform(struct vec4 *dst, const struct vec4 *v,
[build]   			   const struct matrix4 *m);
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\graphics\\vec3.h" %beginfile
[build]   /******************************************************************************
[build]       Copyright (C) 2013 by Hugh Bailey <obs.jim@gmail.com>
[build]   
[build]       This program is free software: you can redistribute it and/or modify
[build]       it under the terms of the GNU General Public License as published by
[build]       the Free Software Foundation, either version 2 of the License, or
[build]       (at your option) any later version.
[build]   
[build]       This program is distributed in the hope that it will be useful,
[build]       but WITHOUT ANY WARRANTY; without even the implied warranty of
[build]       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
[build]       GNU General Public License for more details.
[build]   
[build]       You should have received a copy of the GNU General Public License
[build]       along with this program.  If not, see <http://www.gnu.org/licenses/>.
[build]   ******************************************************************************/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   struct plane;
[build]   struct matrix3;
[build]   struct matrix4;
[build]   struct quat;
[build]   
[build]   struct vec3 {
[build]   	union {
[build]   		struct {
[build]   			float x, y, z, w;
[build]   		};
[build]   		float ptr[4];
[build]   		__m128 m;
[build]   	};
[build]   };
[build]   
[build]   static inline void vec3_zero(struct vec3 *v)
[build]   {
[build]   	v->m = _mm_setzero_ps();
[build]   }
[build]   
[build]   static inline void vec3_set(struct vec3 *dst, float x, float y, float z)
[build]   {
[build]   	dst->m = _mm_set_ps(0.0f, z, y, x);
[build]   }
[build]   
[build]   static inline void vec3_copy(struct vec3 *dst, const struct vec3 *v)
[build]   {
[build]   	dst->m = v->m;
[build]   }
[build]   
[build]    void vec3_from_vec4(struct vec3 *dst, const struct vec4 *v);
[build]   
[build]   static inline void vec3_add(struct vec3 *dst, const struct vec3 *v1,
[build]   			    const struct vec3 *v2)
[build]   {
[build]   	dst->m = _mm_add_ps(v1->m, v2->m);
[build]   	dst->w = 0.0f;
[build]   }
[build]   
[build]   static inline void vec3_sub(struct vec3 *dst, const struct vec3 *v1,
[build]   			    const struct vec3 *v2)
[build]   {
[build]   	dst->m = _mm_sub_ps(v1->m, v2->m);
[build]   	dst->w = 0.0f;
[build]   }
[build]   
[build]   static inline void vec3_mul(struct vec3 *dst, const struct vec3 *v1,
[build]   			    const struct vec3 *v2)
[build]   {
[build]   	dst->m = _mm_mul_ps(v1->m, v2->m);
[build]   }
[build]   
[build]   static inline void vec3_div(struct vec3 *dst, const struct vec3 *v1,
[build]   			    const struct vec3 *v2)
[build]   {
[build]   	dst->m = _mm_div_ps(v1->m, v2->m);
[build]   	dst->w = 0.0f;
[build]   }
[build]   
[build]   static inline void vec3_addf(struct vec3 *dst, const struct vec3 *v, float f)
[build]   {
[build]   	dst->m = _mm_add_ps(v->m, _mm_set1_ps(f));
[build]   	dst->w = 0.0f;
[build]   }
[build]   
[build]   static inline void vec3_subf(struct vec3 *dst, const struct vec3 *v, float f)
[build]   {
[build]   	dst->m = _mm_sub_ps(v->m, _mm_set1_ps(f));
[build]   	dst->w = 0.0f;
[build]   }
[build]   
[build]   static inline void vec3_mulf(struct vec3 *dst, const struct vec3 *v, float f)
[build]   {
[build]   	dst->m = _mm_mul_ps(v->m, _mm_set1_ps(f));
[build]   }
[build]   
[build]   static inline void vec3_divf(struct vec3 *dst, const struct vec3 *v, float f)
[build]   {
[build]   	dst->m = _mm_div_ps(v->m, _mm_set1_ps(f));
[build]   	dst->w = 0.0f;
[build]   }
[build]   
[build]   static inline float vec3_dot(const struct vec3 *v1, const struct vec3 *v2)
[build]   {
[build]   	struct vec3 add;
[build]   	__m128 mul = _mm_mul_ps(v1->m, v2->m);
[build]   	add.m = _mm_add_ps(_mm_movehl_ps(mul, mul), mul);
[build]   	add.m = _mm_add_ps(_mm_shuffle_ps(add.m, add.m, 0x55), add.m);
[build]   	return add.x;
[build]   }
[build]   
[build]   static inline void vec3_cross(struct vec3 *dst, const struct vec3 *v1,
[build]   			      const struct vec3 *v2)
[build]   {
[build]   	__m128 s1v1 = _mm_shuffle_ps(v1->m, v1->m, _MM_SHUFFLE(3, 0, 2, 1));
[build]   	__m128 s1v2 = _mm_shuffle_ps(v2->m, v2->m, _MM_SHUFFLE(3, 1, 0, 2));
[build]   	__m128 s2v1 = _mm_shuffle_ps(v1->m, v1->m, _MM_SHUFFLE(3, 1, 0, 2));
[build]   	__m128 s2v2 = _mm_shuffle_ps(v2->m, v2->m, _MM_SHUFFLE(3, 0, 2, 1));
[build]   	dst->m = _mm_sub_ps(_mm_mul_ps(s1v1, s1v2), _mm_mul_ps(s2v1, s2v2));
[build]   }
[build]   
[build]   static inline void vec3_neg(struct vec3 *dst, const struct vec3 *v)
[build]   {
[build]   	dst->x = -v->x;
[build]   	dst->y = -v->y;
[build]   	dst->z = -v->z;
[build]   	dst->w = 0.0f;
[build]   }
[build]   
[build]   static inline float vec3_len(const struct vec3 *v)
[build]   {
[build]   	float dot_val = vec3_dot(v, v);
[build]   	return (dot_val > 0.0f) ? sqrtf(dot_val) : 0.0f;
[build]   }
[build]   
[build]   static inline float vec3_dist(const struct vec3 *v1, const struct vec3 *v2)
[build]   {
[build]   	struct vec3 temp;
[build]   	float dot_val;
[build]   
[build]   	vec3_sub(&temp, v1, v2);
[build]   	dot_val = vec3_dot(&temp, &temp);
[build]   	return (dot_val > 0.0f) ? sqrtf(dot_val) : 0.0f;
[build]   }
[build]   
[build]   static inline void vec3_norm(struct vec3 *dst, const struct vec3 *v)
[build]   {
[build]   	float dot_val = vec3_dot(v, v);
[build]   	dst->m = (dot_val > 0.0f)
[build]   			 ? _mm_mul_ps(v->m, _mm_set1_ps(1.0f / sqrtf(dot_val)))
[build]   			 : _mm_setzero_ps();
[build]   }
[build]   
[build]   static inline bool vec3_close(const struct vec3 *v1, const struct vec3 *v2,
[build]   			      float epsilon)
[build]   {
[build]   	struct vec3 test;
[build]   	vec3_sub(&test, v1, v2);
[build]   	return test.x < epsilon && test.y < epsilon && test.z < epsilon;
[build]   }
[build]   
[build]   static inline void vec3_min(struct vec3 *dst, const struct vec3 *v1,
[build]   			    const struct vec3 *v2)
[build]   {
[build]   	dst->m = _mm_min_ps(v1->m, v2->m);
[build]   	dst->w = 0.0f;
[build]   }
[build]   
[build]   static inline void vec3_minf(struct vec3 *dst, const struct vec3 *v, float f)
[build]   {
[build]   	dst->m = _mm_min_ps(v->m, _mm_set1_ps(f));
[build]   	dst->w = 0.0f;
[build]   }
[build]   
[build]   static inline void vec3_max(struct vec3 *dst, const struct vec3 *v1,
[build]   			    const struct vec3 *v2)
[build]   {
[build]   	dst->m = _mm_max_ps(v1->m, v2->m);
[build]   	dst->w = 0.0f;
[build]   }
[build]   
[build]   static inline void vec3_maxf(struct vec3 *dst, const struct vec3 *v, float f)
[build]   {
[build]   	dst->m = _mm_max_ps(v->m, _mm_set1_ps(f));
[build]   	dst->w = 0.0f;
[build]   }
[build]   
[build]   static inline void vec3_abs(struct vec3 *dst, const struct vec3 *v)
[build]   {
[build]   	dst->x = fabsf(v->x);
[build]   	dst->y = fabsf(v->y);
[build]   	dst->z = fabsf(v->z);
[build]   	dst->w = 0.0f;
[build]   }
[build]   
[build]   static inline void vec3_floor(struct vec3 *dst, const struct vec3 *v)
[build]   {
[build]   	dst->x = floorf(v->x);
[build]   	dst->y = floorf(v->y);
[build]   	dst->z = floorf(v->z);
[build]   	dst->w = 0.0f;
[build]   }
[build]   
[build]   static inline void vec3_ceil(struct vec3 *dst, const struct vec3 *v)
[build]   {
[build]   	dst->x = ceilf(v->x);
[build]   	dst->y = ceilf(v->y);
[build]   	dst->z = ceilf(v->z);
[build]   	dst->w = 0.0f;
[build]   }
[build]   
[build]    float vec3_plane_dist(const struct vec3 *v, const struct plane *p);
[build]   
[build]    void vec3_transform(struct vec3 *dst, const struct vec3 *v,
[build]   			   const struct matrix4 *m);
[build]   
[build]    void vec3_rotate(struct vec3 *dst, const struct vec3 *v,
[build]   			const struct matrix3 *m);
[build]    void vec3_transform3x4(struct vec3 *dst, const struct vec3 *v,
[build]   			      const struct matrix3 *m);
[build]   
[build]    void vec3_mirror(struct vec3 *dst, const struct vec3 *v,
[build]   			const struct plane *p);
[build]    void vec3_mirrorv(struct vec3 *dst, const struct vec3 *v,
[build]   			 const struct vec3 *vec);
[build]   
[build]    void vec3_rand(struct vec3 *dst, int positive_only);
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\graphics\\vec2.h" %beginfile
[build]   /******************************************************************************
[build]       Copyright (C) 2013 by Hugh Bailey <obs.jim@gmail.com>
[build]   
[build]       This program is free software: you can redistribute it and/or modify
[build]       it under the terms of the GNU General Public License as published by
[build]       the Free Software Foundation, either version 2 of the License, or
[build]       (at your option) any later version.
[build]   
[build]       This program is distributed in the hope that it will be useful,
[build]       but WITHOUT ANY WARRANTY; without even the implied warranty of
[build]       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
[build]       GNU General Public License for more details.
[build]   
[build]       You should have received a copy of the GNU General Public License
[build]       along with this program.  If not, see <http://www.gnu.org/licenses/>.
[build]   ******************************************************************************/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   struct vec2 {
[build]   	union {
[build]   		struct {
[build]   			float x, y;
[build]   		};
[build]   		float ptr[2];
[build]   	};
[build]   };
[build]   
[build]   static inline void vec2_zero(struct vec2 *dst)
[build]   {
[build]   	dst->x = 0.0f;
[build]   	dst->y = 0.0f;
[build]   }
[build]   
[build]   static inline void vec2_set(struct vec2 *dst, float x, float y)
[build]   {
[build]   	dst->x = x;
[build]   	dst->y = y;
[build]   }
[build]   
[build]   static inline void vec2_copy(struct vec2 *dst, const struct vec2 *v)
[build]   {
[build]   	dst->x = v->x;
[build]   	dst->y = v->y;
[build]   }
[build]   
[build]   static inline void vec2_add(struct vec2 *dst, const struct vec2 *v1,
[build]   			    const struct vec2 *v2)
[build]   {
[build]   	vec2_set(dst, v1->x + v2->x, v1->y + v2->y);
[build]   }
[build]   
[build]   static inline void vec2_sub(struct vec2 *dst, const struct vec2 *v1,
[build]   			    const struct vec2 *v2)
[build]   {
[build]   	vec2_set(dst, v1->x - v2->x, v1->y - v2->y);
[build]   }
[build]   
[build]   static inline void vec2_mul(struct vec2 *dst, const struct vec2 *v1,
[build]   			    const struct vec2 *v2)
[build]   {
[build]   	vec2_set(dst, v1->x * v2->x, v1->y * v2->y);
[build]   }
[build]   
[build]   static inline void vec2_div(struct vec2 *dst, const struct vec2 *v1,
[build]   			    const struct vec2 *v2)
[build]   {
[build]   	vec2_set(dst, v1->x / v2->x, v1->y / v2->y);
[build]   }
[build]   
[build]   static inline void vec2_addf(struct vec2 *dst, const struct vec2 *v, float f)
[build]   {
[build]   	vec2_set(dst, v->x + f, v->y + f);
[build]   }
[build]   
[build]   static inline void vec2_subf(struct vec2 *dst, const struct vec2 *v, float f)
[build]   {
[build]   	vec2_set(dst, v->x - f, v->y - f);
[build]   }
[build]   
[build]   static inline void vec2_mulf(struct vec2 *dst, const struct vec2 *v, float f)
[build]   {
[build]   	vec2_set(dst, v->x * f, v->y * f);
[build]   }
[build]   
[build]   static inline void vec2_divf(struct vec2 *dst, const struct vec2 *v, float f)
[build]   {
[build]   	vec2_set(dst, v->x / f, v->y / f);
[build]   }
[build]   
[build]   static inline void vec2_neg(struct vec2 *dst, const struct vec2 *v)
[build]   {
[build]   	vec2_set(dst, -v->x, -v->y);
[build]   }
[build]   
[build]   static inline float vec2_dot(const struct vec2 *v1, const struct vec2 *v2)
[build]   {
[build]   	return v1->x * v2->x + v1->y * v2->y;
[build]   }
[build]   
[build]   static inline float vec2_len(const struct vec2 *v)
[build]   {
[build]   	return sqrtf(v->x * v->x + v->y * v->y);
[build]   }
[build]   
[build]   static inline float vec2_dist(const struct vec2 *v1, const struct vec2 *v2)
[build]   {
[build]   	struct vec2 temp;
[build]   	vec2_sub(&temp, v1, v2);
[build]   	return vec2_len(&temp);
[build]   }
[build]   
[build]   static inline void vec2_minf(struct vec2 *dst, const struct vec2 *v, float val)
[build]   {
[build]   	if (v->x < val)
[build]   		dst->x = val;
[build]   	if (v->y < val)
[build]   		dst->y = val;
[build]   }
[build]   
[build]   static inline void vec2_min(struct vec2 *dst, const struct vec2 *v,
[build]   			    const struct vec2 *min_v)
[build]   {
[build]   	if (v->x < min_v->x)
[build]   		dst->x = min_v->x;
[build]   	if (v->y < min_v->y)
[build]   		dst->y = min_v->y;
[build]   }
[build]   
[build]   static inline void vec2_maxf(struct vec2 *dst, const struct vec2 *v, float val)
[build]   {
[build]   	if (v->x > val)
[build]   		dst->x = val;
[build]   	if (v->y > val)
[build]   		dst->y = val;
[build]   }
[build]   
[build]   static inline void vec2_max(struct vec2 *dst, const struct vec2 *v,
[build]   			    const struct vec2 *max_v)
[build]   {
[build]   	if (v->x > max_v->x)
[build]   		dst->x = max_v->x;
[build]   	if (v->y > max_v->y)
[build]   		dst->y = max_v->y;
[build]   }
[build]   
[build]    void vec2_abs(struct vec2 *dst, const struct vec2 *v);
[build]    void vec2_floor(struct vec2 *dst, const struct vec2 *v);
[build]    void vec2_ceil(struct vec2 *dst, const struct vec2 *v);
[build]    int vec2_close(const struct vec2 *v1, const struct vec2 *v2,
[build]   		      float epsilon);
[build]    void vec2_norm(struct vec2 *dst, const struct vec2 *v);
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\graphics\\matrix4.h" %beginfile
[build]   /******************************************************************************
[build]       Copyright (C) 2013 by Hugh Bailey <obs.jim@gmail.com>
[build]   
[build]       This program is free software: you can redistribute it and/or modify
[build]       it under the terms of the GNU General Public License as published by
[build]       the Free Software Foundation, either version 2 of the License, or
[build]       (at your option) any later version.
[build]   
[build]       This program is distributed in the hope that it will be useful,
[build]       but WITHOUT ANY WARRANTY; without even the implied warranty of
[build]       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
[build]       GNU General Public License for more details.
[build]   
[build]       You should have received a copy of the GNU General Public License
[build]       along with this program.  If not, see <http://www.gnu.org/licenses/>.
[build]   ******************************************************************************/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* 4x4 Matrix */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   struct matrix3;
[build]   
[build]   struct matrix4 {
[build]   	struct vec4 x, y, z, t;
[build]   };
[build]   
[build]   static inline void matrix4_copy(struct matrix4 *dst, const struct matrix4 *m)
[build]   {
[build]   	dst->x.m = m->x.m;
[build]   	dst->y.m = m->y.m;
[build]   	dst->z.m = m->z.m;
[build]   	dst->t.m = m->t.m;
[build]   }
[build]   
[build]   static inline void matrix4_identity(struct matrix4 *dst)
[build]   {
[build]   	vec4_zero(&dst->x);
[build]   	vec4_zero(&dst->y);
[build]   	vec4_zero(&dst->z);
[build]   	vec4_zero(&dst->t);
[build]   	dst->x.x = 1.0f;
[build]   	dst->y.y = 1.0f;
[build]   	dst->z.z = 1.0f;
[build]   	dst->t.w = 1.0f;
[build]   }
[build]   
[build]    void matrix4_from_matrix3(struct matrix4 *dst, const struct matrix3 *m);
[build]    void matrix4_from_quat(struct matrix4 *dst, const struct quat *q);
[build]    void matrix4_from_axisang(struct matrix4 *dst, const struct axisang *aa);
[build]   
[build]    void matrix4_mul(struct matrix4 *dst, const struct matrix4 *m1,
[build]   			const struct matrix4 *m2);
[build]   
[build]    float matrix4_determinant(const struct matrix4 *m);
[build]   
[build]    void matrix4_translate3v(struct matrix4 *dst, const struct matrix4 *m,
[build]   				const struct vec3 *v);
[build]    void matrix4_translate4v(struct matrix4 *dst, const struct matrix4 *m,
[build]   				const struct vec4 *v);
[build]    void matrix4_rotate(struct matrix4 *dst, const struct matrix4 *m,
[build]   			   const struct quat *q);
[build]    void matrix4_rotate_aa(struct matrix4 *dst, const struct matrix4 *m,
[build]   			      const struct axisang *aa);
[build]    void matrix4_scale(struct matrix4 *dst, const struct matrix4 *m,
[build]   			  const struct vec3 *v);
[build]    bool matrix4_inv(struct matrix4 *dst, const struct matrix4 *m);
[build]    void matrix4_transpose(struct matrix4 *dst, const struct matrix4 *m);
[build]   
[build]    void matrix4_translate3v_i(struct matrix4 *dst, const struct vec3 *v,
[build]   				  const struct matrix4 *m);
[build]    void matrix4_translate4v_i(struct matrix4 *dst, const struct vec4 *v,
[build]   				  const struct matrix4 *m);
[build]    void matrix4_rotate_i(struct matrix4 *dst, const struct quat *q,
[build]   			     const struct matrix4 *m);
[build]    void matrix4_rotate_aa_i(struct matrix4 *dst, const struct axisang *aa,
[build]   				const struct matrix4 *m);
[build]    void matrix4_scale_i(struct matrix4 *dst, const struct vec3 *v,
[build]   			    const struct matrix4 *m);
[build]   
[build]   static inline void matrix4_translate3f(struct matrix4 *dst,
[build]   				       const struct matrix4 *m, float x,
[build]   				       float y, float z)
[build]   {
[build]   	struct vec3 v;
[build]   	vec3_set(&v, x, y, z);
[build]   	matrix4_translate3v(dst, m, &v);
[build]   }
[build]   
[build]   static inline void matrix4_rotate_aa4f(struct matrix4 *dst,
[build]   				       const struct matrix4 *m, float x,
[build]   				       float y, float z, float rot)
[build]   {
[build]   	struct axisang aa;
[build]   	axisang_set(&aa, x, y, z, rot);
[build]   	matrix4_rotate_aa(dst, m, &aa);
[build]   }
[build]   
[build]   static inline void matrix4_scale3f(struct matrix4 *dst, const struct matrix4 *m,
[build]   				   float x, float y, float z)
[build]   {
[build]   	struct vec3 v;
[build]   	vec3_set(&v, x, y, z);
[build]   	matrix4_scale(dst, m, &v);
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\graphics\\matrix3.h" %beginfile
[build]   /******************************************************************************
[build]       Copyright (C) 2013 by Hugh Bailey <obs.jim@gmail.com>
[build]   
[build]       This program is free software: you can redistribute it and/or modify
[build]       it under the terms of the GNU General Public License as published by
[build]       the Free Software Foundation, either version 2 of the License, or
[build]       (at your option) any later version.
[build]   
[build]       This program is distributed in the hope that it will be useful,
[build]       but WITHOUT ANY WARRANTY; without even the implied warranty of
[build]       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
[build]       GNU General Public License for more details.
[build]   
[build]       You should have received a copy of the GNU General Public License
[build]       along with this program.  If not, see <http://www.gnu.org/licenses/>.
[build]   ******************************************************************************/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* 3x4 Matrix */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   struct matrix4;
[build]   
[build]   struct matrix3 {
[build]   	struct vec3 x;
[build]   	struct vec3 y;
[build]   	struct vec3 z;
[build]   	struct vec3 t;
[build]   };
[build]   
[build]   static inline void matrix3_copy(struct matrix3 *dst, const struct matrix3 *m)
[build]   {
[build]   	vec3_copy(&dst->x, &m->x);
[build]   	vec3_copy(&dst->y, &m->y);
[build]   	vec3_copy(&dst->z, &m->z);
[build]   	vec3_copy(&dst->t, &m->t);
[build]   }
[build]   
[build]   static inline void matrix3_identity(struct matrix3 *dst)
[build]   {
[build]   	vec3_zero(&dst->x);
[build]   	vec3_zero(&dst->y);
[build]   	vec3_zero(&dst->z);
[build]   	vec3_zero(&dst->t);
[build]   	dst->x.x = dst->y.y = dst->z.z = 1.0f;
[build]   }
[build]   
[build]    void matrix3_from_quat(struct matrix3 *dst, const struct quat *q);
[build]    void matrix3_from_axisang(struct matrix3 *dst, const struct axisang *aa);
[build]    void matrix3_from_matrix4(struct matrix3 *dst, const struct matrix4 *m);
[build]   
[build]    void matrix3_mul(struct matrix3 *dst, const struct matrix3 *m1,
[build]   			const struct matrix3 *m2);
[build]   static inline void matrix3_translate(struct matrix3 *dst,
[build]   				     const struct matrix3 *m,
[build]   				     const struct vec3 *v)
[build]   {
[build]   	vec3_sub(&dst->t, &m->t, v);
[build]   }
[build]   
[build]    void matrix3_rotate(struct matrix3 *dst, const struct matrix3 *m,
[build]   			   const struct quat *q);
[build]    void matrix3_rotate_aa(struct matrix3 *dst, const struct matrix3 *m,
[build]   			      const struct axisang *aa);
[build]    void matrix3_scale(struct matrix3 *dst, const struct matrix3 *m,
[build]   			  const struct vec3 *v);
[build]    void matrix3_transpose(struct matrix3 *dst, const struct matrix3 *m);
[build]    void matrix3_inv(struct matrix3 *dst, const struct matrix3 *m);
[build]   
[build]    void matrix3_mirror(struct matrix3 *dst, const struct matrix3 *m,
[build]   			   const struct plane *p);
[build]    void matrix3_mirrorv(struct matrix3 *dst, const struct matrix3 *m,
[build]   			    const struct vec3 *v);
[build]   
[build]   static inline void matrix3_translate3f(struct matrix3 *dst,
[build]   				       const struct matrix3 *m, float x,
[build]   				       float y, float z)
[build]   {
[build]   	struct vec3 v;
[build]   	vec3_set(&v, x, y, z);
[build]   	matrix3_translate(dst, m, &v);
[build]   }
[build]   
[build]   static inline void matrix3_rotate_aa4f(struct matrix3 *dst,
[build]   				       const struct matrix3 *m, float x,
[build]   				       float y, float z, float rot)
[build]   {
[build]   	struct axisang aa;
[build]   	axisang_set(&aa, x, y, z, rot);
[build]   	matrix3_rotate_aa(dst, m, &aa);
[build]   }
[build]   
[build]   static inline void matrix3_scale3f(struct matrix3 *dst, const struct matrix3 *m,
[build]   				   float x, float y, float z)
[build]   {
[build]   	struct vec3 v;
[build]   	vec3_set(&v, x, y, z);
[build]   	matrix3_scale(dst, m, &v);
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\graphics\\quat.h" %beginfile
[build]   /******************************************************************************
[build]       Copyright (C) 2013 by Hugh Bailey <obs.jim@gmail.com>
[build]   
[build]       This program is free software: you can redistribute it and/or modify
[build]       it under the terms of the GNU General Public License as published by
[build]       the Free Software Foundation, either version 2 of the License, or
[build]       (at your option) any later version.
[build]   
[build]       This program is distributed in the hope that it will be useful,
[build]       but WITHOUT ANY WARRANTY; without even the implied warranty of
[build]       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
[build]       GNU General Public License for more details.
[build]   
[build]       You should have received a copy of the GNU General Public License
[build]       along with this program.  If not, see <http://www.gnu.org/licenses/>.
[build]   ******************************************************************************/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*
[build]    * Quaternion math
[build]    *
[build]    *   Generally used to represent rotational data more than anything.  Allows
[build]    * for efficient and correct rotational interpolation without suffering from
[build]    * things like gimbal lock.
[build]    */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   struct matrix3;
[build]   struct matrix4;
[build]   struct axisang;
[build]   
[build]   struct quat {
[build]   	union {
[build]   		struct {
[build]   			float x, y, z, w;
[build]   		};
[build]   		float ptr[4];
[build]   		__m128 m;
[build]   	};
[build]   };
[build]   
[build]   static inline void quat_identity(struct quat *q)
[build]   {
[build]   	q->m = _mm_setzero_ps();
[build]   	q->w = 1.0f;
[build]   }
[build]   
[build]   static inline void quat_set(struct quat *dst, float x, float y, float z,
[build]   			    float w)
[build]   {
[build]   	dst->m = _mm_set_ps(x, y, z, w);
[build]   }
[build]   
[build]   static inline void quat_copy(struct quat *dst, const struct quat *q)
[build]   {
[build]   	dst->m = q->m;
[build]   }
[build]   
[build]   static inline void quat_add(struct quat *dst, const struct quat *q1,
[build]   			    const struct quat *q2)
[build]   {
[build]   	dst->m = _mm_add_ps(q1->m, q2->m);
[build]   }
[build]   
[build]   static inline void quat_sub(struct quat *dst, const struct quat *q1,
[build]   			    const struct quat *q2)
[build]   {
[build]   	dst->m = _mm_sub_ps(q1->m, q2->m);
[build]   }
[build]   
[build]    void quat_mul(struct quat *dst, const struct quat *q1,
[build]   		     const struct quat *q2);
[build]   
[build]   static inline void quat_addf(struct quat *dst, const struct quat *q, float f)
[build]   {
[build]   	dst->m = _mm_add_ps(q->m, _mm_set1_ps(f));
[build]   }
[build]   
[build]   static inline void quat_subf(struct quat *dst, const struct quat *q, float f)
[build]   {
[build]   	dst->m = _mm_sub_ps(q->m, _mm_set1_ps(f));
[build]   }
[build]   
[build]   static inline void quat_mulf(struct quat *dst, const struct quat *q, float f)
[build]   {
[build]   	dst->m = _mm_mul_ps(q->m, _mm_set1_ps(f));
[build]   }
[build]   
[build]   static inline void quat_divf(struct quat *dst, const struct quat *q, float f)
[build]   {
[build]   	dst->m = _mm_div_ps(q->m, _mm_set1_ps(f));
[build]   }
[build]   
[build]   static inline float quat_dot(const struct quat *q1, const struct quat *q2)
[build]   {
[build]   	struct vec3 add;
[build]   	__m128 mul = _mm_mul_ps(q1->m, q2->m);
[build]   	add.m = _mm_add_ps(_mm_movehl_ps(mul, mul), mul);
[build]   	add.m = _mm_add_ps(_mm_shuffle_ps(add.m, add.m, 0x55), add.m);
[build]   	return add.x;
[build]   }
[build]   
[build]   static inline void quat_inv(struct quat *dst, const struct quat *q)
[build]   {
[build]   	dst->x = -q->x;
[build]   	dst->y = -q->y;
[build]   	dst->z = -q->z;
[build]   }
[build]   
[build]   static inline void quat_neg(struct quat *dst, const struct quat *q)
[build]   {
[build]   	dst->x = -q->x;
[build]   	dst->y = -q->y;
[build]   	dst->z = -q->z;
[build]   	dst->w = -q->w;
[build]   }
[build]   
[build]   static inline float quat_len(const struct quat *q)
[build]   {
[build]   	float dot_val = quat_dot(q, q);
[build]   	return (dot_val > 0.0f) ? sqrtf(dot_val) : 0.0f;
[build]   }
[build]   
[build]   static inline float quat_dist(const struct quat *q1, const struct quat *q2)
[build]   {
[build]   	struct quat temp;
[build]   	float dot_val;
[build]   
[build]   	quat_sub(&temp, q1, q2);
[build]   	dot_val = quat_dot(&temp, &temp);
[build]   	return (dot_val > 0.0f) ? sqrtf(dot_val) : 0.0f;
[build]   }
[build]   
[build]   static inline void quat_norm(struct quat *dst, const struct quat *q)
[build]   {
[build]   	float dot_val = quat_dot(q, q);
[build]   	dst->m = (dot_val > 0.0f)
[build]   			 ? _mm_mul_ps(q->m, _mm_set1_ps(1.0f / sqrtf(dot_val)))
[build]   			 : _mm_setzero_ps();
[build]   }
[build]   
[build]   static inline bool quat_close(const struct quat *q1, const struct quat *q2,
[build]   			      float epsilon)
[build]   {
[build]   	struct quat test;
[build]   	quat_sub(&test, q1, q2);
[build]   	return test.x < epsilon && test.y < epsilon && test.z < epsilon &&
[build]   	       test.w < epsilon;
[build]   }
[build]   
[build]    void quat_from_axisang(struct quat *dst, const struct axisang *aa);
[build]    void quat_from_matrix3(struct quat *dst, const struct matrix3 *m);
[build]    void quat_from_matrix4(struct quat *dst, const struct matrix4 *m);
[build]   
[build]    void quat_get_dir(struct vec3 *dst, const struct quat *q);
[build]    void quat_set_look_dir(struct quat *dst, const struct vec3 *dir);
[build]   
[build]    void quat_log(struct quat *dst, const struct quat *q);
[build]    void quat_exp(struct quat *dst, const struct quat *q);
[build]   
[build]    void quat_interpolate(struct quat *dst, const struct quat *q1,
[build]   			     const struct quat *q2, float t);
[build]    void quat_get_tangent(struct quat *dst, const struct quat *prev,
[build]   			     const struct quat *q, const struct quat *next);
[build]    void quat_interpolate_cubic(struct quat *dst, const struct quat *q1,
[build]   				   const struct quat *q2, const struct quat *m1,
[build]   				   const struct quat *m2, float t);
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\build\\deps\\obs-scripting\\obs-scripting-config.h" %beginfile
[build]   
[build]   
[build]   
[build]   %constant TRUE = 1;
[build]   
[build]   
[build]   
[build]   %constant ON = 1;
[build]   
[build]   
[build]   
[build]   %constant FALSE = 0;
[build]   
[build]   
[build]   
[build]   %constant OFF = 0;
[build]   
[build]   
[build]   %constant SCRIPT_DIR = "../../data/obs-scripting/64bit";
[build]   %constant PYTHON_LIB = "python36";
[build]   %constant COMPILE_LUA = 1;
[build]   %constant COMPILE_PYTHON = 1;
[build]   %constant UI_ENABLED = 1;
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\obs-data.h" %beginfile
[build]   /******************************************************************************
[build]       Copyright (C) 2014 by Hugh Bailey <obs.jim@gmail.com>
[build]   
[build]       This program is free software: you can redistribute it and/or modify
[build]       it under the terms of the GNU General Public License as published by
[build]       the Free Software Foundation, either version 2 of the License, or
[build]       (at your option) any later version.
[build]   
[build]       This program is distributed in the hope that it will be useful,
[build]       but WITHOUT ANY WARRANTY; without even the implied warranty of
[build]       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
[build]       GNU General Public License for more details.
[build]   
[build]       You should have received a copy of the GNU General Public License
[build]       along with this program.  If not, see <http://www.gnu.org/licenses/>.
[build]   ******************************************************************************/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   struct vec2;
[build]   struct vec3;
[build]   struct vec4;
[build]   struct quat;
[build]   
[build]   /*
[build]    * OBS data settings storage
[build]    *
[build]    *   This is used for retrieving or setting the data settings for things such
[build]    * as sources, encoders, etc.  This is designed for JSON serialization.
[build]    */
[build]   
[build]   struct obs_data;
[build]   struct obs_data_item;
[build]   struct obs_data_array;
[build]   typedef struct obs_data obs_data_t;
[build]   typedef struct obs_data_item obs_data_item_t;
[build]   typedef struct obs_data_array obs_data_array_t;
[build]   
[build]   enum obs_data_type {
[build]   	OBS_DATA_NULL,
[build]   	OBS_DATA_STRING,
[build]   	OBS_DATA_NUMBER,
[build]   	OBS_DATA_BOOLEAN,
[build]   	OBS_DATA_OBJECT,
[build]   	OBS_DATA_ARRAY
[build]   };
[build]   
[build]   enum obs_data_number_type {
[build]   	OBS_DATA_NUM_INVALID,
[build]   	OBS_DATA_NUM_INT,
[build]   	OBS_DATA_NUM_DOUBLE
[build]   };
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Main usage functions */
[build]   
[build]    obs_data_t *obs_data_create();
[build]    obs_data_t *obs_data_create_from_json(const char *json_string);
[build]    obs_data_t *obs_data_create_from_json_file(const char *json_file);
[build]    obs_data_t *obs_data_create_from_json_file_safe(const char *json_file,
[build]   						       const char *backup_ext);
[build]    void obs_data_addref(obs_data_t *data);
[build]    void obs_data_release(obs_data_t *data);
[build]   
[build]    const char *obs_data_get_json(obs_data_t *data);
[build]    bool obs_data_save_json(obs_data_t *data, const char *file);
[build]    bool obs_data_save_json_safe(obs_data_t *data, const char *file,
[build]   				    const char *temp_ext,
[build]   				    const char *backup_ext);
[build]   
[build]    void obs_data_apply(obs_data_t *target, obs_data_t *apply_data);
[build]   
[build]    void obs_data_erase(obs_data_t *data, const char *name);
[build]    void obs_data_clear(obs_data_t *data);
[build]   
[build]   /* Set functions */
[build]    void obs_data_set_string(obs_data_t *data, const char *name,
[build]   				const char *val);
[build]    void obs_data_set_int(obs_data_t *data, const char *name, long long val);
[build]    void obs_data_set_double(obs_data_t *data, const char *name, double val);
[build]    void obs_data_set_bool(obs_data_t *data, const char *name, bool val);
[build]    void obs_data_set_obj(obs_data_t *data, const char *name,
[build]   			     obs_data_t *obj);
[build]    void obs_data_set_array(obs_data_t *data, const char *name,
[build]   			       obs_data_array_t *array);
[build]   
[build]   /*
[build]    * Default value functions.
[build]    */
[build]    void obs_data_set_default_string(obs_data_t *data, const char *name,
[build]   					const char *val);
[build]    void obs_data_set_default_int(obs_data_t *data, const char *name,
[build]   				     long long val);
[build]    void obs_data_set_default_double(obs_data_t *data, const char *name,
[build]   					double val);
[build]    void obs_data_set_default_bool(obs_data_t *data, const char *name,
[build]   				      bool val);
[build]    void obs_data_set_default_obj(obs_data_t *data, const char *name,
[build]   				     obs_data_t *obj);
[build]   
[build]   /*
[build]    * Application overrides
[build]    * Use these to communicate the actual values of settings in case the user
[build]    * settings aren't appropriate
[build]    */
[build]    void obs_data_set_autoselect_string(obs_data_t *data, const char *name,
[build]   					   const char *val);
[build]    void obs_data_set_autoselect_int(obs_data_t *data, const char *name,
[build]   					long long val);
[build]    void obs_data_set_autoselect_double(obs_data_t *data, const char *name,
[build]   					   double val);
[build]    void obs_data_set_autoselect_bool(obs_data_t *data, const char *name,
[build]   					 bool val);
[build]    void obs_data_set_autoselect_obj(obs_data_t *data, const char *name,
[build]   					obs_data_t *obj);
[build]   
[build]   /*
[build]    * Get functions
[build]    */
[build]    const char *obs_data_get_string(obs_data_t *data, const char *name);
[build]    long long obs_data_get_int(obs_data_t *data, const char *name);
[build]    double obs_data_get_double(obs_data_t *data, const char *name);
[build]    bool obs_data_get_bool(obs_data_t *data, const char *name);
[build]    obs_data_t *obs_data_get_obj(obs_data_t *data, const char *name);
[build]    obs_data_array_t *obs_data_get_array(obs_data_t *data, const char *name);
[build]   
[build]    const char *obs_data_get_default_string(obs_data_t *data,
[build]   					       const char *name);
[build]    long long obs_data_get_default_int(obs_data_t *data, const char *name);
[build]    double obs_data_get_default_double(obs_data_t *data, const char *name);
[build]    bool obs_data_get_default_bool(obs_data_t *data, const char *name);
[build]    obs_data_t *obs_data_get_default_obj(obs_data_t *data, const char *name);
[build]    obs_data_array_t *obs_data_get_default_array(obs_data_t *data,
[build]   						    const char *name);
[build]   
[build]    const char *obs_data_get_autoselect_string(obs_data_t *data,
[build]   						  const char *name);
[build]    long long obs_data_get_autoselect_int(obs_data_t *data,
[build]   					     const char *name);
[build]    double obs_data_get_autoselect_double(obs_data_t *data,
[build]   					     const char *name);
[build]    bool obs_data_get_autoselect_bool(obs_data_t *data, const char *name);
[build]    obs_data_t *obs_data_get_autoselect_obj(obs_data_t *data,
[build]   					       const char *name);
[build]    obs_data_array_t *obs_data_get_autoselect_array(obs_data_t *data,
[build]   						       const char *name);
[build]   
[build]   /* Array functions */
[build]    obs_data_array_t *obs_data_array_create();
[build]    void obs_data_array_addref(obs_data_array_t *array);
[build]    void obs_data_array_release(obs_data_array_t *array);
[build]   
[build]    size_t obs_data_array_count(obs_data_array_t *array);
[build]    obs_data_t *obs_data_array_item(obs_data_array_t *array, size_t idx);
[build]    size_t obs_data_array_push_back(obs_data_array_t *array,
[build]   				       obs_data_t *obj);
[build]    void obs_data_array_insert(obs_data_array_t *array, size_t idx,
[build]   				  obs_data_t *obj);
[build]    void obs_data_array_push_back_array(obs_data_array_t *array,
[build]   					   obs_data_array_t *array2);
[build]    void obs_data_array_erase(obs_data_array_t *array, size_t idx);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Item status inspection */
[build]   
[build]    bool obs_data_has_user_value(obs_data_t *data, const char *name);
[build]    bool obs_data_has_default_value(obs_data_t *data, const char *name);
[build]    bool obs_data_has_autoselect_value(obs_data_t *data, const char *name);
[build]   
[build]    bool obs_data_item_has_user_value(obs_data_item_t *data);
[build]    bool obs_data_item_has_default_value(obs_data_item_t *data);
[build]    bool obs_data_item_has_autoselect_value(obs_data_item_t *data);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Clearing data values */
[build]   
[build]    void obs_data_unset_user_value(obs_data_t *data, const char *name);
[build]    void obs_data_unset_default_value(obs_data_t *data, const char *name);
[build]    void obs_data_unset_autoselect_value(obs_data_t *data, const char *name);
[build]   
[build]    void obs_data_item_unset_user_value(obs_data_item_t *data);
[build]    void obs_data_item_unset_default_value(obs_data_item_t *data);
[build]    void obs_data_item_unset_autoselect_value(obs_data_item_t *data);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Item iteration */
[build]   
[build]    obs_data_item_t *obs_data_first(obs_data_t *data);
[build]    obs_data_item_t *obs_data_item_byname(obs_data_t *data,
[build]   					     const char *name);
[build]    bool obs_data_item_next(obs_data_item_t **item);
[build]    void obs_data_item_release(obs_data_item_t **item);
[build]    void obs_data_item_remove(obs_data_item_t **item);
[build]   
[build]   /* Gets Item type */
[build]    enum obs_data_type obs_data_item_gettype(obs_data_item_t *item);
[build]    enum obs_data_number_type obs_data_item_numtype(obs_data_item_t *item);
[build]    const char *obs_data_item_get_name(obs_data_item_t *item);
[build]   
[build]   /* Item set functions */
[build]    void obs_data_item_set_string(obs_data_item_t **item, const char *val);
[build]    void obs_data_item_set_int(obs_data_item_t **item, long long val);
[build]    void obs_data_item_set_double(obs_data_item_t **item, double val);
[build]    void obs_data_item_set_bool(obs_data_item_t **item, bool val);
[build]    void obs_data_item_set_obj(obs_data_item_t **item, obs_data_t *val);
[build]    void obs_data_item_set_array(obs_data_item_t **item,
[build]   				    obs_data_array_t *val);
[build]   
[build]    void obs_data_item_set_default_string(obs_data_item_t **item,
[build]   					     const char *val);
[build]    void obs_data_item_set_default_int(obs_data_item_t **item,
[build]   					  long long val);
[build]    void obs_data_item_set_default_double(obs_data_item_t **item,
[build]   					     double val);
[build]    void obs_data_item_set_default_bool(obs_data_item_t **item, bool val);
[build]    void obs_data_item_set_default_obj(obs_data_item_t **item,
[build]   					  obs_data_t *val);
[build]    void obs_data_item_set_default_array(obs_data_item_t **item,
[build]   					    obs_data_array_t *val);
[build]   
[build]    void obs_data_item_set_autoselect_string(obs_data_item_t **item,
[build]   						const char *val);
[build]    void obs_data_item_set_autoselect_int(obs_data_item_t **item,
[build]   					     long long val);
[build]    void obs_data_item_set_autoselect_double(obs_data_item_t **item,
[build]   						double val);
[build]    void obs_data_item_set_autoselect_bool(obs_data_item_t **item, bool val);
[build]    void obs_data_item_set_autoselect_obj(obs_data_item_t **item,
[build]   					     obs_data_t *val);
[build]    void obs_data_item_set_autoselect_array(obs_data_item_t **item,
[build]   					       obs_data_array_t *val);
[build]   
[build]   /* Item get functions */
[build]    const char *obs_data_item_get_string(obs_data_item_t *item);
[build]    long long obs_data_item_get_int(obs_data_item_t *item);
[build]    double obs_data_item_get_double(obs_data_item_t *item);
[build]    bool obs_data_item_get_bool(obs_data_item_t *item);
[build]    obs_data_t *obs_data_item_get_obj(obs_data_item_t *item);
[build]    obs_data_array_t *obs_data_item_get_array(obs_data_item_t *item);
[build]   
[build]    const char *obs_data_item_get_default_string(obs_data_item_t *item);
[build]    long long obs_data_item_get_default_int(obs_data_item_t *item);
[build]    double obs_data_item_get_default_double(obs_data_item_t *item);
[build]    bool obs_data_item_get_default_bool(obs_data_item_t *item);
[build]    obs_data_t *obs_data_item_get_default_obj(obs_data_item_t *item);
[build]    obs_data_array_t *obs_data_item_get_default_array(obs_data_item_t *item);
[build]   
[build]    const char *obs_data_item_get_autoselect_string(obs_data_item_t *item);
[build]    long long obs_data_item_get_autoselect_int(obs_data_item_t *item);
[build]    double obs_data_item_get_autoselect_double(obs_data_item_t *item);
[build]    bool obs_data_item_get_autoselect_bool(obs_data_item_t *item);
[build]    obs_data_t *obs_data_item_get_autoselect_obj(obs_data_item_t *item);
[build]    obs_data_array_t *
[build]   obs_data_item_get_autoselect_array(obs_data_item_t *item);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Helper functions for certain structures */
[build]    void obs_data_set_vec2(obs_data_t *data, const char *name,
[build]   			      const struct vec2 *val);
[build]    void obs_data_set_vec3(obs_data_t *data, const char *name,
[build]   			      const struct vec3 *val);
[build]    void obs_data_set_vec4(obs_data_t *data, const char *name,
[build]   			      const struct vec4 *val);
[build]    void obs_data_set_quat(obs_data_t *data, const char *name,
[build]   			      const struct quat *val);
[build]   
[build]    void obs_data_set_default_vec2(obs_data_t *data, const char *name,
[build]   				      const struct vec2 *val);
[build]    void obs_data_set_default_vec3(obs_data_t *data, const char *name,
[build]   				      const struct vec3 *val);
[build]    void obs_data_set_default_vec4(obs_data_t *data, const char *name,
[build]   				      const struct vec4 *val);
[build]    void obs_data_set_default_quat(obs_data_t *data, const char *name,
[build]   				      const struct quat *val);
[build]   
[build]    void obs_data_set_autoselect_vec2(obs_data_t *data, const char *name,
[build]   					 const struct vec2 *val);
[build]    void obs_data_set_autoselect_vec3(obs_data_t *data, const char *name,
[build]   					 const struct vec3 *val);
[build]    void obs_data_set_autoselect_vec4(obs_data_t *data, const char *name,
[build]   					 const struct vec4 *val);
[build]    void obs_data_set_autoselect_quat(obs_data_t *data, const char *name,
[build]   					 const struct quat *val);
[build]   
[build]    void obs_data_get_vec2(obs_data_t *data, const char *name,
[build]   			      struct vec2 *val);
[build]    void obs_data_get_vec3(obs_data_t *data, const char *name,
[build]   			      struct vec3 *val);
[build]    void obs_data_get_vec4(obs_data_t *data, const char *name,
[build]   			      struct vec4 *val);
[build]    void obs_data_get_quat(obs_data_t *data, const char *name,
[build]   			      struct quat *val);
[build]   
[build]    void obs_data_get_default_vec2(obs_data_t *data, const char *name,
[build]   				      struct vec2 *val);
[build]    void obs_data_get_default_vec3(obs_data_t *data, const char *name,
[build]   				      struct vec3 *val);
[build]    void obs_data_get_default_vec4(obs_data_t *data, const char *name,
[build]   				      struct vec4 *val);
[build]    void obs_data_get_default_quat(obs_data_t *data, const char *name,
[build]   				      struct quat *val);
[build]   
[build]    void obs_data_get_autoselect_vec2(obs_data_t *data, const char *name,
[build]   					 struct vec2 *val);
[build]    void obs_data_get_autoselect_vec3(obs_data_t *data, const char *name,
[build]   					 struct vec3 *val);
[build]    void obs_data_get_autoselect_vec4(obs_data_t *data, const char *name,
[build]   					 struct vec4 *val);
[build]    void obs_data_get_autoselect_quat(obs_data_t *data, const char *name,
[build]   					 struct quat *val);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Helper functions for media_frames_per_second/OBS_PROPERTY_FRAME_RATE */
[build]    void obs_data_set_frames_per_second(obs_data_t *data, const char *name,
[build]   					   struct media_frames_per_second fps,
[build]   					   const char *option);
[build]    void
[build]   obs_data_set_default_frames_per_second(obs_data_t *data, const char *name,
[build]   				       struct media_frames_per_second fps,
[build]   				       const char *option);
[build]    void
[build]   obs_data_set_autoselect_frames_per_second(obs_data_t *data, const char *name,
[build]   					  struct media_frames_per_second fps,
[build]   					  const char *option);
[build]   
[build]    bool obs_data_get_frames_per_second(obs_data_t *data, const char *name,
[build]   					   struct media_frames_per_second *fps,
[build]   					   const char **option);
[build]    bool
[build]   obs_data_get_default_frames_per_second(obs_data_t *data, const char *name,
[build]   				       struct media_frames_per_second *fps,
[build]   				       const char **option);
[build]    bool
[build]   obs_data_get_autoselect_frames_per_second(obs_data_t *data, const char *name,
[build]   					  struct media_frames_per_second *fps,
[build]   					  const char **option);
[build]   
[build]    void
[build]   obs_data_item_set_frames_per_second(obs_data_item_t **item,
[build]   				    struct media_frames_per_second fps,
[build]   				    const char *option);
[build]    void
[build]   obs_data_item_set_default_frames_per_second(obs_data_item_t **item,
[build]   					    struct media_frames_per_second fps,
[build]   					    const char *option);
[build]    void obs_data_item_set_autoselect_frames_per_second(
[build]   	obs_data_item_t **item, struct media_frames_per_second fps,
[build]   	const char *option);
[build]   
[build]    bool
[build]   obs_data_item_get_frames_per_second(obs_data_item_t *item,
[build]   				    struct media_frames_per_second *fps,
[build]   				    const char **option);
[build]    bool
[build]   obs_data_item_get_default_frames_per_second(obs_data_item_t *item,
[build]   					    struct media_frames_per_second *fps,
[build]   					    const char **option);
[build]    bool obs_data_item_get_autoselect_frames_per_second(
[build]   	obs_data_item_t *item, struct media_frames_per_second *fps,
[build]   	const char **option);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* OBS-specific functions */
[build]   
[build]   static inline obs_data_t *obs_data_newref(obs_data_t *data)
[build]   {
[build]   	if (data)
[build]   		obs_data_addref(data);
[build]   	else
[build]   		data = obs_data_create();
[build]   
[build]   	return data;
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\obs-source.h" %beginfile
[build]   /******************************************************************************
[build]       Copyright (C) 2013-2014 by Hugh Bailey <obs.jim@gmail.com>
[build]   
[build]       This program is free software: you can redistribute it and/or modify
[build]       it under the terms of the GNU General Public License as published by
[build]       the Free Software Foundation, either version 2 of the License, or
[build]       (at your option) any later version.
[build]   
[build]       This program is distributed in the hope that it will be useful,
[build]       but WITHOUT ANY WARRANTY; without even the implied warranty of
[build]       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
[build]       GNU General Public License for more details.
[build]   
[build]       You should have received a copy of the GNU General Public License
[build]       along with this program.  If not, see <http://www.gnu.org/licenses/>.
[build]   ******************************************************************************/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /**
[build]    * @file
[build]    * @brief header for modules implementing sources.
[build]    *
[build]    * Sources are modules that either feed data to libobs or modify it.
[build]    */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   enum obs_source_type {
[build]   	OBS_SOURCE_TYPE_INPUT,
[build]   	OBS_SOURCE_TYPE_FILTER,
[build]   	OBS_SOURCE_TYPE_TRANSITION,
[build]   	OBS_SOURCE_TYPE_SCENE,
[build]   };
[build]   
[build]   enum obs_balance_type {
[build]   	OBS_BALANCE_TYPE_SINE_LAW,
[build]   	OBS_BALANCE_TYPE_SQUARE_LAW,
[build]   	OBS_BALANCE_TYPE_LINEAR,
[build]   };
[build]   
[build]   enum obs_icon_type {
[build]   	OBS_ICON_TYPE_UNKNOWN,
[build]   	OBS_ICON_TYPE_IMAGE,
[build]   	OBS_ICON_TYPE_COLOR,
[build]   	OBS_ICON_TYPE_SLIDESHOW,
[build]   	OBS_ICON_TYPE_AUDIO_INPUT,
[build]   	OBS_ICON_TYPE_AUDIO_OUTPUT,
[build]   	OBS_ICON_TYPE_DESKTOP_CAPTURE,
[build]   	OBS_ICON_TYPE_WINDOW_CAPTURE,
[build]   	OBS_ICON_TYPE_GAME_CAPTURE,
[build]   	OBS_ICON_TYPE_CAMERA,
[build]   	OBS_ICON_TYPE_TEXT,
[build]   	OBS_ICON_TYPE_MEDIA,
[build]   	OBS_ICON_TYPE_BROWSER,
[build]   	OBS_ICON_TYPE_CUSTOM,
[build]   };
[build]   
[build]   enum obs_media_state {
[build]   	OBS_MEDIA_STATE_NONE,
[build]   	OBS_MEDIA_STATE_PLAYING,
[build]   	OBS_MEDIA_STATE_OPENING,
[build]   	OBS_MEDIA_STATE_BUFFERING,
[build]   	OBS_MEDIA_STATE_PAUSED,
[build]   	OBS_MEDIA_STATE_STOPPED,
[build]   	OBS_MEDIA_STATE_ENDED,
[build]   	OBS_MEDIA_STATE_ERROR,
[build]   };
[build]   
[build]   /**
[build]    * @name Source output flags
[build]    *
[build]    * These flags determine what type of data the source outputs and expects.
[build]    * @{
[build]    */
[build]   
[build]   /**
[build]    * Source has video.
[build]    *
[build]    * Unless SOURCE_ASYNC_VIDEO is specified, the source must include the
[build]    * video_render callback in the source definition structure.
[build]    */
[build]   %constant OBS_SOURCE_VIDEO = (1 << 0);
[build]   
[build]   /**
[build]    * Source has audio.
[build]    *
[build]    * Use the obs_source_output_audio function to pass raw audio data, which will
[build]    * be automatically converted and uploaded.  If used with SOURCE_ASYNC_VIDEO,
[build]    * audio will automatically be synced up to the video output.
[build]    */
[build]   %constant OBS_SOURCE_AUDIO = (1 << 1);
[build]   
[build]   /** Async video flag (use OBS_SOURCE_ASYNC_VIDEO) */
[build]   %constant OBS_SOURCE_ASYNC = (1 << 2);
[build]   
[build]   /**
[build]    * Source passes raw video data via RAM.
[build]    *
[build]    * Use the obs_source_output_video function to pass raw video data, which will
[build]    * be automatically uploaded at the specified timestamp.
[build]    *
[build]    * If this flag is specified, it is not necessary to include the video_render
[build]    * callback.  However, if you wish to use that function as well, you must call
[build]    * obs_source_getframe to get the current frame data, and
[build]    * obs_source_releaseframe to release the data when complete.
[build]    */
[build]   %constant OBS_SOURCE_ASYNC_VIDEO = ((1 << 2) | (1 << 0));
[build]   
[build]   /**
[build]    * Source uses custom drawing, rather than a default effect.
[build]    *
[build]    * If this flag is specified, the video_render callback will pass a NULL
[build]    * effect, and effect-based filters will not use direct rendering.
[build]    */
[build]   %constant OBS_SOURCE_CUSTOM_DRAW = (1 << 3);
[build]   
[build]   /**
[build]    * Source supports interaction.
[build]    *
[build]    * When this is used, the source will receive interaction events
[build]    * if they provide the necessary callbacks in the source definition structure.
[build]    */
[build]   %constant OBS_SOURCE_INTERACTION = (1 << 5);
[build]   
[build]   /**
[build]    * Source composites sub-sources
[build]    *
[build]    * When used specifies that the source composites one or more sub-sources.
[build]    * Sources that render sub-sources must implement the audio_render callback
[build]    * in order to perform custom mixing of sub-sources.
[build]    *
[build]    * This capability flag is always set for transitions.
[build]    */
[build]   %constant OBS_SOURCE_COMPOSITE = (1 << 6);
[build]   
[build]   /**
[build]    * Source should not be fully duplicated
[build]    *
[build]    * When this is used, specifies that the source should not be fully duplicated,
[build]    * and should prefer to duplicate via holding references rather than full
[build]    * duplication.
[build]    */
[build]   %constant OBS_SOURCE_DO_NOT_DUPLICATE = (1 << 7);
[build]   
[build]   /**
[build]    * Source is deprecated and should not be used
[build]    */
[build]   %constant OBS_SOURCE_DEPRECATED = (1 << 8);
[build]   
[build]   /**
[build]    * Source cannot have its audio monitored
[build]    *
[build]    * Specifies that this source may cause a feedback loop if audio is monitored
[build]    * with a device selected as desktop audio.
[build]    *
[build]    * This is used primarily with desktop audio capture sources.
[build]    */
[build]   %constant OBS_SOURCE_DO_NOT_SELF_MONITOR = (1 << 9);
[build]   
[build]   /**
[build]    * Source type is currently disabled and should not be shown to the user
[build]    */
[build]   %constant OBS_SOURCE_CAP_DISABLED = (1 << 10);
[build]   
[build]   /**
[build]    * Source type is obsolete (has been updated with new defaults/properties/etc)
[build]    */
[build]   %constant OBS_SOURCE_CAP_OBSOLETE = (1 << 10);
[build]   
[build]   /**
[build]    * Source should enable monitoring by default.  Monitoring should be set by the
[build]    * frontend if this flag is set.
[build]    */
[build]   %constant OBS_SOURCE_MONITOR_BY_DEFAULT = (1 << 11);
[build]   
[build]   /** Used internally for audio submixing */
[build]   %constant OBS_SOURCE_SUBMIX = (1 << 12);
[build]   
[build]   /**
[build]    * Source type can be controlled by media controls
[build]    */
[build]   %constant OBS_SOURCE_CONTROLLABLE_MEDIA = (1 << 13);
[build]   
[build]   /**
[build]    * Source type provides cea708 data
[build]    */
[build]   %constant OBS_SOURCE_CEA_708 = (1 << 14);
[build]   
[build]   /** @} */
[build]   
[build]   typedef void (*obs_source_enum_proc_t)(obs_source_t *parent,
[build]   				       obs_source_t *child, void *param);
[build]   
[build]   struct obs_source_audio_mix {
[build]   	struct audio_output_data output[MAX_AUDIO_MIXES];
[build]   };
[build]   
[build]   /**
[build]    * Source definition structure
[build]    */
[build]   struct obs_source_info {
[build]   	/* ----------------------------------------------------------------- */
[build]   	/* Required implementation*/
[build]   
[build]   	/** Unique string identifier for the source */
[build]   	const char *id;
[build]   
[build]   	/**
[build]   	 * Type of source.
[build]   	 *
[build]   	 * OBS_SOURCE_TYPE_INPUT for input sources,
[build]   	 * OBS_SOURCE_TYPE_FILTER for filter sources, and
[build]   	 * OBS_SOURCE_TYPE_TRANSITION for transition sources.
[build]   	 */
[build]   	enum obs_source_type type;
[build]   
[build]   	/** Source output flags */
[build]   	uint32_t output_flags;
[build]   
[build]   	/**
[build]   	 * Get the translated name of the source type
[build]   	 *
[build]   	 * @param  type_data  The type_data variable of this structure
[build]   	 * @return               The translated name of the source type
[build]   	 */
[build]   	const char *(*get_name)(void *type_data);
[build]   
[build]   	/**
[build]   	 * Creates the source data for the source
[build]   	 *
[build]   	 * @param  settings  Settings to initialize the source with
[build]   	 * @param  source    Source that this data is associated with
[build]   	 * @return           The data associated with this source
[build]   	 */
[build]   	void *(*create)(obs_data_t *settings, obs_source_t *source);
[build]   
[build]   	/**
[build]   	 * Destroys the private data for the source
[build]   	 *
[build]   	 * Async sources must not call obs_source_output_video after returning
[build]   	 * from destroy
[build]   	 */
[build]   	void (*destroy)(void *data);
[build]   
[build]   	/** Returns the width of the source.  Required if this is an input
[build]   	 * source and has non-async video */
[build]   	uint32_t (*get_width)(void *data);
[build]   
[build]   	/** Returns the height of the source.  Required if this is an input
[build]   	 * source and has non-async video */
[build]   	uint32_t (*get_height)(void *data);
[build]   
[build]   	/* ----------------------------------------------------------------- */
[build]   	/* Optional implementation */
[build]   
[build]   	/**
[build]   	 * Gets the default settings for this source
[build]   	 *
[build]   	 * @param[out]  settings  Data to assign default settings to
[build]   	 * @deprecated            Use get_defaults2 if type_data is needed
[build]   	 */
[build]   	void (*get_defaults)(obs_data_t *settings);
[build]   
[build]   	/**
[build]   	 * Gets the property information of this source
[build]   	 *
[build]   	 * @return         The properties data
[build]   	 * @deprecated     Use get_properties2 if type_data is needed
[build]   	 */
[build]   	obs_properties_t *(*get_properties)(void *data);
[build]   
[build]   	/**
[build]   	 * Updates the settings for this source
[build]   	 *
[build]   	 * @param data      Source data
[build]   	 * @param settings  New settings for this source
[build]   	 */
[build]   	void (*update)(void *data, obs_data_t *settings);
[build]   
[build]   	/** Called when the source has been activated in the main view */
[build]   	void (*activate)(void *data);
[build]   
[build]   	/**
[build]   	 * Called when the source has been deactivated from the main view
[build]   	 * (no longer being played/displayed)
[build]   	 */
[build]   	void (*deactivate)(void *data);
[build]   
[build]   	/** Called when the source is visible */
[build]   	void (*show)(void *data);
[build]   
[build]   	/** Called when the source is no longer visible */
[build]   	void (*hide)(void *data);
[build]   
[build]   	/**
[build]   	 * Called each video frame with the time elapsed
[build]   	 *
[build]   	 * @param  data     Source data
[build]   	 * @param  seconds  Seconds elapsed since the last frame
[build]   	 */
[build]   	void (*video_tick)(void *data, float seconds);
[build]   
[build]   	/**
[build]   	 * Called when rendering the source with the graphics subsystem.
[build]   	 *
[build]   	 * If this is an input/transition source, this is called to draw the
[build]   	 * source texture with the graphics subsystem using the specified
[build]   	 * effect.
[build]   	 *
[build]   	 * If this is a filter source, it wraps source draw calls (for
[build]   	 * example applying a custom effect with custom parameters to a
[build]   	 * source).  In this case, it's highly recommended to use the
[build]   	 * obs_source_process_filter function to automatically handle
[build]   	 * effect-based filter processing.  However, you can implement custom
[build]   	 * draw handling as desired as well.
[build]   	 *
[build]   	 * If the source output flags do not include SOURCE_CUSTOM_DRAW, all
[build]   	 * a source needs to do is set the "image" parameter of the effect to
[build]   	 * the desired texture, and then draw.  If the output flags include
[build]   	 * SOURCE_COLOR_MATRIX, you may optionally set the "color_matrix"
[build]   	 * parameter of the effect to a custom 4x4 conversion matrix (by
[build]   	 * default it will be set to an YUV->RGB conversion matrix)
[build]   	 *
[build]   	 * @param data    Source data
[build]   	 * @param effect  Effect to be used with this source.  If the source
[build]   	 *                output flags include SOURCE_CUSTOM_DRAW, this will
[build]   	 *                be NULL, and the source is expected to process with
[build]   	 *                an effect manually.
[build]   	 */
[build]   	void (*video_render)(void *data, gs_effect_t *effect);
[build]   
[build]   	/**
[build]   	 * Called to filter raw async video data.
[build]   	 *
[build]   	 * @note          This function is only used with filter sources.
[build]   	 *
[build]   	 * @param  data   Filter data
[build]   	 * @param  frame  Video frame to filter
[build]   	 * @return        New video frame data.  This can defer video data to
[build]   	 *                be drawn later if time is needed for processing
[build]   	 */
[build]   	struct obs_source_frame *(*filter_video)(
[build]   		void *data, struct obs_source_frame *frame);
[build]   
[build]   	/**
[build]   	 * Called to filter raw audio data.
[build]   	 *
[build]   	 * @note          This function is only used with filter sources.
[build]   	 *
[build]   	 * @param  data   Filter data
[build]   	 * @param  audio  Audio data to filter.
[build]   	 * @return        Modified or new audio data.  You can directly modify
[build]   	 *                the data passed and return it, or you can defer audio
[build]   	 *                data for later if time is needed for processing.  If
[build]   	 *                you are returning new data, that data must exist
[build]   	 *                until the next call to the filter_audio callback or
[build]   	 *                until the filter is removed/destroyed.
[build]   	 */
[build]   	struct obs_audio_data *(*filter_audio)(void *data,
[build]   					       struct obs_audio_data *audio);
[build]   
[build]   	/**
[build]   	 * Called to enumerate all active sources being used within this
[build]   	 * source.  If the source has children that render audio/video it must
[build]   	 * implement this callback.
[build]   	 *
[build]   	 * @param  data           Filter data
[build]   	 * @param  enum_callback  Enumeration callback
[build]   	 * @param  param          User data to pass to callback
[build]   	 */
[build]   	void (*enum_active_sources)(void *data,
[build]   				    obs_source_enum_proc_t enum_callback,
[build]   				    void *param);
[build]   
[build]   	/**
[build]   	 * Called when saving a source.  This is a separate function because
[build]   	 * sometimes a source needs to know when it is being saved so it
[build]   	 * doesn't always have to update the current settings until a certain
[build]   	 * point.
[build]   	 *
[build]   	 * @param  data      Source data
[build]   	 * @param  settings  Settings
[build]   	 */
[build]   	void (*save)(void *data, obs_data_t *settings);
[build]   
[build]   	/**
[build]   	 * Called when loading a source from saved data.  This should be called
[build]   	 * after all the loading sources have actually been created because
[build]   	 * sometimes there are sources that depend on each other.
[build]   	 *
[build]   	 * @param  data      Source data
[build]   	 * @param  settings  Settings
[build]   	 */
[build]   	void (*load)(void *data, obs_data_t *settings);
[build]   
[build]   	/**
[build]   	 * Called when interacting with a source and a mouse-down or mouse-up
[build]   	 * occurs.
[build]   	 *
[build]   	 * @param data         Source data
[build]   	 * @param event        Mouse event properties
[build]   	 * @param type         Mouse button pushed
[build]   	 * @param mouse_up     Mouse event type (true if mouse-up)
[build]   	 * @param click_count  Mouse click count (1 for single click, etc.)
[build]   	 */
[build]   	void (*mouse_click)(void *data, const struct obs_mouse_event *event,
[build]   			    int32_t type, bool mouse_up, uint32_t click_count);
[build]   	/**
[build]   	 * Called when interacting with a source and a mouse-move occurs.
[build]   	 *
[build]   	 * @param data         Source data
[build]   	 * @param event        Mouse event properties
[build]   	 * @param mouse_leave  Mouse leave state (true if mouse left source)
[build]   	 */
[build]   	void (*mouse_move)(void *data, const struct obs_mouse_event *event,
[build]   			   bool mouse_leave);
[build]   
[build]   	/**
[build]   	 * Called when interacting with a source and a mouse-wheel occurs.
[build]   	 *
[build]   	 * @param data         Source data
[build]   	 * @param event        Mouse event properties
[build]   	 * @param x_delta      Movement delta in the horizontal direction
[build]   	 * @param y_delta      Movement delta in the vertical direction
[build]   	 */
[build]   	void (*mouse_wheel)(void *data, const struct obs_mouse_event *event,
[build]   			    int x_delta, int y_delta);
[build]   	/**
[build]   	 * Called when interacting with a source and gain focus/lost focus event
[build]   	 * occurs.
[build]   	 *
[build]   	 * @param data         Source data
[build]   	 * @param focus        Focus state (true if focus gained)
[build]   	 */
[build]   	void (*focus)(void *data, bool focus);
[build]   
[build]   	/**
[build]   	 * Called when interacting with a source and a key-up or key-down
[build]   	 * occurs.
[build]   	 *
[build]   	 * @param data         Source data
[build]   	 * @param event        Key event properties
[build]   	 * @param focus        Key event type (true if mouse-up)
[build]   	 */
[build]   	void (*key_click)(void *data, const struct obs_key_event *event,
[build]   			  bool key_up);
[build]   
[build]   	/**
[build]   	 * Called when the filter is removed from a source
[build]   	 *
[build]   	 * @param  data    Filter data
[build]   	 * @param  source  Source that the filter being removed from
[build]   	 */
[build]   	void (*filter_remove)(void *data, obs_source_t *source);
[build]   
[build]   	/**
[build]   	 * Private data associated with this entry
[build]   	 */
[build]   	void *type_data;
[build]   
[build]   	/**
[build]   	 * If defined, called to free private data on shutdown
[build]   	 */
[build]   	void (*free_type_data)(void *type_data);
[build]   
[build]   	bool (*audio_render)(void *data, uint64_t *ts_out,
[build]   			     struct obs_source_audio_mix *audio_output,
[build]   			     uint32_t mixers, size_t channels,
[build]   			     size_t sample_rate);
[build]   
[build]   	/**
[build]   	 * Called to enumerate all active and inactive sources being used
[build]   	 * within this source.  If this callback isn't implemented,
[build]   	 * enum_active_sources will be called instead.
[build]   	 *
[build]   	 * This is typically used if a source can have inactive child sources.
[build]   	 *
[build]   	 * @param  data           Filter data
[build]   	 * @param  enum_callback  Enumeration callback
[build]   	 * @param  param          User data to pass to callback
[build]   	 */
[build]   	void (*enum_all_sources)(void *data,
[build]   				 obs_source_enum_proc_t enum_callback,
[build]   				 void *param);
[build]   
[build]   	void (*transition_start)(void *data);
[build]   	void (*transition_stop)(void *data);
[build]   
[build]   	/**
[build]   	 * Gets the default settings for this source
[build]   	 * 
[build]   	 * If get_defaults is also defined both will be called, and the first
[build]   	 * call will be to get_defaults, then to get_defaults2.
[build]   	 *
[build]   	 * @param       type_data The type_data variable of this structure
[build]   	 * @param[out]  settings  Data to assign default settings to
[build]   	 */
[build]   	void (*get_defaults2)(void *type_data, obs_data_t *settings);
[build]   
[build]   	/**
[build]   	 * Gets the property information of this source
[build]   	 *
[build]   	 * @param data      Source data
[build]   	 * @param type_data The type_data variable of this structure
[build]   	 * @return          The properties data
[build]   	 */
[build]   	obs_properties_t *(*get_properties2)(void *data, void *type_data);
[build]   
[build]   	bool (*audio_mix)(void *data, uint64_t *ts_out,
[build]   			  struct audio_output_data *audio_output,
[build]   			  size_t channels, size_t sample_rate);
[build]   
[build]   	/** Icon type for the source */
[build]   	enum obs_icon_type icon_type;
[build]   
[build]   	/** Media controls */
[build]   	void (*media_play_pause)(void *data, bool pause);
[build]   	void (*media_restart)(void *data);
[build]   	void (*media_stop)(void *data);
[build]   	void (*media_next)(void *data);
[build]   	void (*media_previous)(void *data);
[build]   	int64_t (*media_get_duration)(void *data);
[build]   	int64_t (*media_get_time)(void *data);
[build]   	void (*media_set_time)(void *data, int64_t miliseconds);
[build]   	enum obs_media_state (*media_get_state)(void *data);
[build]   
[build]   	/* version-related stuff */
[build]   	uint32_t version; /* increment if needed to specify a new version */
[build]   	const char *unversioned_id; /* set internally, don't set manually */
[build]   };
[build]   
[build]    void obs_register_source_s(const struct obs_source_info *info,
[build]   				  size_t size);
[build]   
[build]   /**
[build]    * Registers a source definition to the current obs context.  This should be
[build]    * used in obs_module_load.
[build]    *
[build]    * @param  info  Pointer to the source definition structure
[build]    */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\obs-properties.h" %beginfile
[build]   /******************************************************************************
[build]       Copyright (C) 2014 by Hugh Bailey <obs.jim@gmail.com>
[build]   
[build]       This program is free software: you can redistribute it and/or modify
[build]       it under the terms of the GNU General Public License as published by
[build]       the Free Software Foundation, either version 2 of the License, or
[build]       (at your option) any later version.
[build]   
[build]       This program is distributed in the hope that it will be useful,
[build]       but WITHOUT ANY WARRANTY; without even the implied warranty of
[build]       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
[build]       GNU General Public License for more details.
[build]   
[build]       You should have received a copy of the GNU General Public License
[build]       along with this program.  If not, see <http://www.gnu.org/licenses/>.
[build]   ******************************************************************************/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /**
[build]    * @file
[build]    * @brief libobs header for the properties system used in libobs
[build]    *
[build]    * @page properties Properties
[build]    * @brief Platform and Toolkit independent settings implementation
[build]    *
[build]    * @section prop_overview_sec Overview
[build]    *
[build]    * libobs uses a property system which lets for example sources specify
[build]    * settings that can be displayed to the user by the UI.
[build]    *
[build]    */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /** Only update when the user presses OK or Apply */
[build]   %constant OBS_PROPERTIES_DEFER_UPDATE = (1 << 0);
[build]   
[build]   enum obs_property_type {
[build]   	OBS_PROPERTY_INVALID,
[build]   	OBS_PROPERTY_BOOL,
[build]   	OBS_PROPERTY_INT,
[build]   	OBS_PROPERTY_FLOAT,
[build]   	OBS_PROPERTY_TEXT,
[build]   	OBS_PROPERTY_PATH,
[build]   	OBS_PROPERTY_LIST,
[build]   	OBS_PROPERTY_COLOR,
[build]   	OBS_PROPERTY_BUTTON,
[build]   	OBS_PROPERTY_FONT,
[build]   	OBS_PROPERTY_EDITABLE_LIST,
[build]   	OBS_PROPERTY_FRAME_RATE,
[build]   	OBS_PROPERTY_GROUP,
[build]   };
[build]   
[build]   enum obs_combo_format {
[build]   	OBS_COMBO_FORMAT_INVALID,
[build]   	OBS_COMBO_FORMAT_INT,
[build]   	OBS_COMBO_FORMAT_FLOAT,
[build]   	OBS_COMBO_FORMAT_STRING,
[build]   };
[build]   
[build]   enum obs_combo_type {
[build]   	OBS_COMBO_TYPE_INVALID,
[build]   	OBS_COMBO_TYPE_EDITABLE,
[build]   	OBS_COMBO_TYPE_LIST,
[build]   };
[build]   
[build]   enum obs_editable_list_type {
[build]   	OBS_EDITABLE_LIST_TYPE_STRINGS,
[build]   	OBS_EDITABLE_LIST_TYPE_FILES,
[build]   	OBS_EDITABLE_LIST_TYPE_FILES_AND_URLS,
[build]   };
[build]   
[build]   enum obs_path_type {
[build]   	OBS_PATH_FILE,
[build]   	OBS_PATH_FILE_SAVE,
[build]   	OBS_PATH_DIRECTORY,
[build]   };
[build]   
[build]   enum obs_text_type {
[build]   	OBS_TEXT_DEFAULT,
[build]   	OBS_TEXT_PASSWORD,
[build]   	OBS_TEXT_MULTILINE,
[build]   };
[build]   
[build]   enum obs_number_type {
[build]   	OBS_NUMBER_SCROLLER,
[build]   	OBS_NUMBER_SLIDER,
[build]   };
[build]   
[build]   enum obs_group_type {
[build]   	OBS_COMBO_INVALID,
[build]   	OBS_GROUP_NORMAL,
[build]   	OBS_GROUP_CHECKABLE,
[build]   };
[build]   
[build]   %constant OBS_FONT_BOLD = (1 << 0);
[build]   %constant OBS_FONT_ITALIC = (1 << 1);
[build]   %constant OBS_FONT_UNDERLINE = (1 << 2);
[build]   %constant OBS_FONT_STRIKEOUT = (1 << 3);
[build]   
[build]   struct obs_properties;
[build]   struct obs_property;
[build]   typedef struct obs_properties obs_properties_t;
[build]   typedef struct obs_property obs_property_t;
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   
[build]    obs_properties_t *obs_properties_create(void);
[build]    obs_properties_t *
[build]   obs_properties_create_param(void *param, void (*destroy)(void *param));
[build]    void obs_properties_destroy(obs_properties_t *props);
[build]   
[build]    void obs_properties_set_flags(obs_properties_t *props, uint32_t flags);
[build]    uint32_t obs_properties_get_flags(obs_properties_t *props);
[build]   
[build]    void obs_properties_set_param(obs_properties_t *props, void *param,
[build]   				     void (*destroy)(void *param));
[build]    void *obs_properties_get_param(obs_properties_t *props);
[build]   
[build]    obs_property_t *obs_properties_first(obs_properties_t *props);
[build]   
[build]    obs_property_t *obs_properties_get(obs_properties_t *props,
[build]   					  const char *property);
[build]   
[build]    obs_properties_t *obs_properties_get_parent(obs_properties_t *props);
[build]   
[build]   /** Remove a property from a properties list.
[build]    *
[build]    * Removes a property from a properties list. Only valid in either
[build]    * get_properties or modified_callback(2). modified_callback(2) must return
[build]    * true so that all UI properties are rebuilt and returning false is undefined
[build]    * behavior.
[build]    *
[build]    * @param props Properties to remove from.
[build]    * @param property Name of the property to remove.
[build]    */
[build]    void obs_properties_remove_by_name(obs_properties_t *props,
[build]   					  const char *property);
[build]   
[build]   /**
[build]    * Applies settings to the properties by calling all the necessary
[build]    * modification callbacks
[build]    */
[build]    void obs_properties_apply_settings(obs_properties_t *props,
[build]   					  obs_data_t *settings);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   
[build]   /**
[build]    * Callback for when a button property is clicked.  If the properties
[build]    * need to be refreshed due to changes to the property layout, return true,
[build]    * otherwise return false.
[build]    */
[build]   typedef bool (*obs_property_clicked_t)(obs_properties_t *props,
[build]   				       obs_property_t *property, void *data);
[build]   
[build]    obs_property_t *obs_properties_add_bool(obs_properties_t *props,
[build]   					       const char *name,
[build]   					       const char *description);
[build]   
[build]    obs_property_t *obs_properties_add_int(obs_properties_t *props,
[build]   					      const char *name,
[build]   					      const char *description, int min,
[build]   					      int max, int step);
[build]   
[build]    obs_property_t *obs_properties_add_float(obs_properties_t *props,
[build]   						const char *name,
[build]   						const char *description,
[build]   						double min, double max,
[build]   						double step);
[build]   
[build]    obs_property_t *obs_properties_add_int_slider(obs_properties_t *props,
[build]   						     const char *name,
[build]   						     const char *description,
[build]   						     int min, int max,
[build]   						     int step);
[build]   
[build]    obs_property_t *obs_properties_add_float_slider(obs_properties_t *props,
[build]   						       const char *name,
[build]   						       const char *description,
[build]   						       double min, double max,
[build]   						       double step);
[build]   
[build]    obs_property_t *obs_properties_add_text(obs_properties_t *props,
[build]   					       const char *name,
[build]   					       const char *description,
[build]   					       enum obs_text_type type);
[build]   
[build]   /**
[build]    * Adds a 'path' property.  Can be a directory or a file.
[build]    *
[build]    * If target is a file path, the filters should be this format, separated by
[build]    * double semi-colens, and extensions separated by space:
[build]    *   "Example types 1 and 2 (*.ex1 *.ex2);;Example type 3 (*.ex3)"
[build]    *
[build]    * @param  props        Properties object
[build]    * @param  name         Settings name
[build]    * @param  description  Description (display name) of the property
[build]    * @param  type         Type of path (directory or file)
[build]    * @param  filter       If type is a file path, then describes the file filter
[build]    *                      that the user can browse.  Items are separated via
[build]    *                      double semi-colens.  If multiple file types in a
[build]    *                      filter, separate with space.
[build]    */
[build]    obs_property_t *
[build]   obs_properties_add_path(obs_properties_t *props, const char *name,
[build]   			const char *description, enum obs_path_type type,
[build]   			const char *filter, const char *default_path);
[build]   
[build]    obs_property_t *obs_properties_add_list(obs_properties_t *props,
[build]   					       const char *name,
[build]   					       const char *description,
[build]   					       enum obs_combo_type type,
[build]   					       enum obs_combo_format format);
[build]   
[build]    obs_property_t *obs_properties_add_color(obs_properties_t *props,
[build]   						const char *name,
[build]   						const char *description);
[build]   
[build]    obs_property_t *
[build]   obs_properties_add_button(obs_properties_t *props, const char *name,
[build]   			  const char *text, obs_property_clicked_t callback);
[build]   
[build]    obs_property_t *
[build]   obs_properties_add_button2(obs_properties_t *props, const char *name,
[build]   			   const char *text, obs_property_clicked_t callback,
[build]   			   void *priv);
[build]   
[build]   /**
[build]    * Adds a font selection property.
[build]    *
[build]    * A font is an obs_data sub-object which contains the following items:
[build]    *   face:   face name string
[build]    *   style:  style name string
[build]    *   size:   size integer
[build]    *   flags:  font flags integer (OBS_FONT_* defined above)
[build]    */
[build]    obs_property_t *obs_properties_add_font(obs_properties_t *props,
[build]   					       const char *name,
[build]   					       const char *description);
[build]   
[build]    obs_property_t *
[build]   obs_properties_add_editable_list(obs_properties_t *props, const char *name,
[build]   				 const char *description,
[build]   				 enum obs_editable_list_type type,
[build]   				 const char *filter, const char *default_path);
[build]   
[build]    obs_property_t *obs_properties_add_frame_rate(obs_properties_t *props,
[build]   						     const char *name,
[build]   						     const char *description);
[build]   
[build]    obs_property_t *obs_properties_add_group(obs_properties_t *props,
[build]   						const char *name,
[build]   						const char *description,
[build]   						enum obs_group_type type,
[build]   						obs_properties_t *group);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   
[build]   /**
[build]    * Optional callback for when a property is modified.  If the properties
[build]    * need to be refreshed due to changes to the property layout, return true,
[build]    * otherwise return false.
[build]    */
[build]   typedef bool (*obs_property_modified_t)(obs_properties_t *props,
[build]   					obs_property_t *property,
[build]   					obs_data_t *settings);
[build]   typedef bool (*obs_property_modified2_t)(void *priv, obs_properties_t *props,
[build]   					 obs_property_t *property,
[build]   					 obs_data_t *settings);
[build]   
[build]    void
[build]   obs_property_set_modified_callback(obs_property_t *p,
[build]   				   obs_property_modified_t modified);
[build]    void obs_property_set_modified_callback2(
[build]   	obs_property_t *p, obs_property_modified2_t modified, void *priv);
[build]   
[build]    bool obs_property_modified(obs_property_t *p, obs_data_t *settings);
[build]    bool obs_property_button_clicked(obs_property_t *p, void *obj);
[build]   
[build]    void obs_property_set_visible(obs_property_t *p, bool visible);
[build]    void obs_property_set_enabled(obs_property_t *p, bool enabled);
[build]   
[build]    void obs_property_set_description(obs_property_t *p,
[build]   					 const char *description);
[build]    void obs_property_set_long_description(obs_property_t *p,
[build]   					      const char *long_description);
[build]   
[build]    const char *obs_property_name(obs_property_t *p);
[build]    const char *obs_property_description(obs_property_t *p);
[build]    const char *obs_property_long_description(obs_property_t *p);
[build]    enum obs_property_type obs_property_get_type(obs_property_t *p);
[build]    bool obs_property_enabled(obs_property_t *p);
[build]    bool obs_property_visible(obs_property_t *p);
[build]   
[build]    bool obs_property_next(obs_property_t **p);
[build]   
[build]    int obs_property_int_min(obs_property_t *p);
[build]    int obs_property_int_max(obs_property_t *p);
[build]    int obs_property_int_step(obs_property_t *p);
[build]    enum obs_number_type obs_property_int_type(obs_property_t *p);
[build]    const char *obs_property_int_suffix(obs_property_t *p);
[build]    double obs_property_float_min(obs_property_t *p);
[build]    double obs_property_float_max(obs_property_t *p);
[build]    double obs_property_float_step(obs_property_t *p);
[build]    enum obs_number_type obs_property_float_type(obs_property_t *p);
[build]    const char *obs_property_float_suffix(obs_property_t *p);
[build]    enum obs_text_type obs_property_text_type(obs_property_t *p);
[build]    enum obs_text_type obs_property_text_monospace(obs_property_t *p);
[build]    enum obs_path_type obs_property_path_type(obs_property_t *p);
[build]    const char *obs_property_path_filter(obs_property_t *p);
[build]    const char *obs_property_path_default_path(obs_property_t *p);
[build]    enum obs_combo_type obs_property_list_type(obs_property_t *p);
[build]    enum obs_combo_format obs_property_list_format(obs_property_t *p);
[build]   
[build]    void obs_property_int_set_limits(obs_property_t *p, int min, int max,
[build]   					int step);
[build]    void obs_property_float_set_limits(obs_property_t *p, double min,
[build]   					  double max, double step);
[build]    void obs_property_int_set_suffix(obs_property_t *p, const char *suffix);
[build]    void obs_property_float_set_suffix(obs_property_t *p,
[build]   					  const char *suffix);
[build]    void obs_property_text_set_monospace(obs_property_t *p, bool monospace);
[build]   
[build]    void obs_property_list_clear(obs_property_t *p);
[build]   
[build]    size_t obs_property_list_add_string(obs_property_t *p, const char *name,
[build]   					   const char *val);
[build]    size_t obs_property_list_add_int(obs_property_t *p, const char *name,
[build]   					long long val);
[build]    size_t obs_property_list_add_float(obs_property_t *p, const char *name,
[build]   					  double val);
[build]   
[build]    void obs_property_list_insert_string(obs_property_t *p, size_t idx,
[build]   					    const char *name, const char *val);
[build]    void obs_property_list_insert_int(obs_property_t *p, size_t idx,
[build]   					 const char *name, long long val);
[build]    void obs_property_list_insert_float(obs_property_t *p, size_t idx,
[build]   					   const char *name, double val);
[build]   
[build]    void obs_property_list_item_disable(obs_property_t *p, size_t idx,
[build]   					   bool disabled);
[build]    bool obs_property_list_item_disabled(obs_property_t *p, size_t idx);
[build]   
[build]    void obs_property_list_item_remove(obs_property_t *p, size_t idx);
[build]   
[build]    size_t obs_property_list_item_count(obs_property_t *p);
[build]    const char *obs_property_list_item_name(obs_property_t *p, size_t idx);
[build]    const char *obs_property_list_item_string(obs_property_t *p, size_t idx);
[build]    long long obs_property_list_item_int(obs_property_t *p, size_t idx);
[build]    double obs_property_list_item_float(obs_property_t *p, size_t idx);
[build]   
[build]    enum obs_editable_list_type
[build]   obs_property_editable_list_type(obs_property_t *p);
[build]    const char *obs_property_editable_list_filter(obs_property_t *p);
[build]    const char *obs_property_editable_list_default_path(obs_property_t *p);
[build]   
[build]    void obs_property_frame_rate_clear(obs_property_t *p);
[build]    void obs_property_frame_rate_options_clear(obs_property_t *p);
[build]    void obs_property_frame_rate_fps_ranges_clear(obs_property_t *p);
[build]   
[build]    size_t obs_property_frame_rate_option_add(obs_property_t *p,
[build]   						 const char *name,
[build]   						 const char *description);
[build]    size_t obs_property_frame_rate_fps_range_add(
[build]   	obs_property_t *p, struct media_frames_per_second min,
[build]   	struct media_frames_per_second max);
[build]   
[build]    void obs_property_frame_rate_option_insert(obs_property_t *p, size_t idx,
[build]   						  const char *name,
[build]   						  const char *description);
[build]    void
[build]   obs_property_frame_rate_fps_range_insert(obs_property_t *p, size_t idx,
[build]   					 struct media_frames_per_second min,
[build]   					 struct media_frames_per_second max);
[build]   
[build]    size_t obs_property_frame_rate_options_count(obs_property_t *p);
[build]    const char *obs_property_frame_rate_option_name(obs_property_t *p,
[build]   						       size_t idx);
[build]    const char *obs_property_frame_rate_option_description(obs_property_t *p,
[build]   							      size_t idx);
[build]   
[build]    size_t obs_property_frame_rate_fps_ranges_count(obs_property_t *p);
[build]    struct media_frames_per_second
[build]   obs_property_frame_rate_fps_range_min(obs_property_t *p, size_t idx);
[build]    struct media_frames_per_second
[build]   obs_property_frame_rate_fps_range_max(obs_property_t *p, size_t idx);
[build]   
[build]    enum obs_group_type obs_property_group_type(obs_property_t *p);
[build]    obs_properties_t *obs_property_group_content(obs_property_t *p);
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\obs-interaction.h" %beginfile
[build]   /******************************************************************************
[build]    Copyright (C) 2014 by Hugh Bailey <obs.jim@gmail.com>
[build]   
[build]    This program is free software: you can redistribute it and/or modify
[build]    it under the terms of the GNU General Public License as published by
[build]    the Free Software Foundation, either version 2 of the License, or
[build]    (at your option) any later version.
[build]   
[build]    This program is distributed in the hope that it will be useful,
[build]    but WITHOUT ANY WARRANTY; without even the implied warranty of
[build]    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
[build]    GNU General Public License for more details.
[build]   
[build]    You should have received a copy of the GNU General Public License
[build]    along with this program.  If not, see <http://www.gnu.org/licenses/>.
[build]    ******************************************************************************/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   enum obs_interaction_flags {
[build]   	INTERACT_NONE = 0,
[build]   	INTERACT_CAPS_KEY = 1,
[build]   	INTERACT_SHIFT_KEY = 1 << 1,
[build]   	INTERACT_CONTROL_KEY = 1 << 2,
[build]   	INTERACT_ALT_KEY = 1 << 3,
[build]   	INTERACT_MOUSE_LEFT = 1 << 4,
[build]   	INTERACT_MOUSE_MIDDLE = 1 << 5,
[build]   	INTERACT_MOUSE_RIGHT = 1 << 6,
[build]   	INTERACT_COMMAND_KEY = 1 << 7,
[build]   	INTERACT_NUMLOCK_KEY = 1 << 8,
[build]   	INTERACT_IS_KEY_PAD = 1 << 9,
[build]   	INTERACT_IS_LEFT = 1 << 10,
[build]   	INTERACT_IS_RIGHT = 1 << 11,
[build]   };
[build]   
[build]   enum obs_mouse_button_type {
[build]   	MOUSE_LEFT,
[build]   	MOUSE_MIDDLE,
[build]   	MOUSE_RIGHT,
[build]   };
[build]   
[build]   struct obs_mouse_event {
[build]   	uint32_t modifiers;
[build]   	int32_t x;
[build]   	int32_t y;
[build]   };
[build]   
[build]   struct obs_key_event {
[build]   	uint32_t modifiers;
[build]   	char *text;
[build]   	uint32_t native_modifiers;
[build]   	uint32_t native_scancode;
[build]   	uint32_t native_vkey;
[build]   };
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\obs-hotkey.h" %beginfile
[build]   /******************************************************************************
[build]       Copyright (C) 2014-2015 by Ruwen Hahn <palana@stunned.de>
[build]   
[build]       This program is free software: you can redistribute it and/or modify
[build]       it under the terms of the GNU General Public License as published by
[build]       the Free Software Foundation, either version 2 of the License, or
[build]       (at your option) any later version.
[build]   
[build]       This program is distributed in the hope that it will be useful,
[build]       but WITHOUT ANY WARRANTY; without even the implied warranty of
[build]       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
[build]       GNU General Public License for more details.
[build]   
[build]       You should have received a copy of the GNU General Public License
[build]       along with this program.  If not, see <http://www.gnu.org/licenses/>.
[build]   ******************************************************************************/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   typedef size_t obs_hotkey_id;
[build]   typedef size_t obs_hotkey_pair_id;
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   const size_t OBS_INVALID_HOTKEY_ID = (size_t)-1;
[build]   const size_t OBS_INVALID_HOTKEY_PAIR_ID = (size_t)-1;
[build]   
[build]   
[build]   %constant XINPUT_MOUSE_LEN = 33;
[build]   
[build]   enum obs_key {
[build]   
[build]   
[build]   
[build]   	OBS_KEY_LAST_VALUE //not an actual key
[build]   };
[build]   typedef enum obs_key obs_key_t;
[build]   
[build]   struct obs_key_combination {
[build]   	uint32_t modifiers;
[build]   	obs_key_t key;
[build]   };
[build]   typedef struct obs_key_combination obs_key_combination_t;
[build]   
[build]   typedef struct obs_hotkey obs_hotkey_t;
[build]   typedef struct obs_hotkey_binding obs_hotkey_binding_t;
[build]   
[build]   enum obs_hotkey_registerer_type {
[build]   	OBS_HOTKEY_REGISTERER_FRONTEND,
[build]   	OBS_HOTKEY_REGISTERER_SOURCE,
[build]   	OBS_HOTKEY_REGISTERER_OUTPUT,
[build]   	OBS_HOTKEY_REGISTERER_ENCODER,
[build]   	OBS_HOTKEY_REGISTERER_SERVICE,
[build]   };
[build]   typedef enum obs_hotkey_registerer_type obs_hotkey_registerer_t;
[build]   
[build]   /* getter functions */
[build]   
[build]    obs_hotkey_id obs_hotkey_get_id(const obs_hotkey_t *key);
[build]    const char *obs_hotkey_get_name(const obs_hotkey_t *key);
[build]    const char *obs_hotkey_get_description(const obs_hotkey_t *key);
[build]    obs_hotkey_registerer_t
[build]   obs_hotkey_get_registerer_type(const obs_hotkey_t *key);
[build]    void *obs_hotkey_get_registerer(const obs_hotkey_t *key);
[build]    obs_hotkey_id obs_hotkey_get_pair_partner_id(const obs_hotkey_t *key);
[build]   
[build]    obs_key_combination_t
[build]   obs_hotkey_binding_get_key_combination(obs_hotkey_binding_t *binding);
[build]    obs_hotkey_id
[build]   obs_hotkey_binding_get_hotkey_id(obs_hotkey_binding_t *binding);
[build]    obs_hotkey_t *
[build]   obs_hotkey_binding_get_hotkey(obs_hotkey_binding_t *binding);
[build]   
[build]   /* setter functions */
[build]   
[build]    void obs_hotkey_set_name(obs_hotkey_id id, const char *name);
[build]    void obs_hotkey_set_description(obs_hotkey_id id, const char *desc);
[build]    void obs_hotkey_pair_set_names(obs_hotkey_pair_id id, const char *name0,
[build]   				      const char *name1);
[build]    void obs_hotkey_pair_set_descriptions(obs_hotkey_pair_id id,
[build]   					     const char *desc0,
[build]   					     const char *desc1);
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]    void
[build]   obs_hotkeys_set_audio_hotkeys_translations(const char *mute, const char *unmute,
[build]   					   const char *push_to_mute,
[build]   					   const char *push_to_talk);
[build]   
[build]    void obs_hotkeys_set_sceneitem_hotkeys_translations(const char *show,
[build]   							   const char *hide);
[build]   
[build]   /* registering hotkeys (giving hotkeys a name and a function) */
[build]   
[build]   typedef void (*obs_hotkey_func)(void *data, obs_hotkey_id id,
[build]   				obs_hotkey_t *hotkey, bool pressed);
[build]   
[build]    obs_hotkey_id obs_hotkey_register_frontend(const char *name,
[build]   						  const char *description,
[build]   						  obs_hotkey_func func,
[build]   						  void *data);
[build]   
[build]    obs_hotkey_id obs_hotkey_register_encoder(obs_encoder_t *encoder,
[build]   						 const char *name,
[build]   						 const char *description,
[build]   						 obs_hotkey_func func,
[build]   						 void *data);
[build]   
[build]    obs_hotkey_id obs_hotkey_register_output(obs_output_t *output,
[build]   						const char *name,
[build]   						const char *description,
[build]   						obs_hotkey_func func,
[build]   						void *data);
[build]   
[build]    obs_hotkey_id obs_hotkey_register_service(obs_service_t *service,
[build]   						 const char *name,
[build]   						 const char *description,
[build]   						 obs_hotkey_func func,
[build]   						 void *data);
[build]   
[build]    obs_hotkey_id obs_hotkey_register_source(obs_source_t *source,
[build]   						const char *name,
[build]   						const char *description,
[build]   						obs_hotkey_func func,
[build]   						void *data);
[build]   
[build]   typedef bool (*obs_hotkey_active_func)(void *data, obs_hotkey_pair_id id,
[build]   				       obs_hotkey_t *hotkey, bool pressed);
[build]   
[build]    obs_hotkey_pair_id obs_hotkey_pair_register_frontend(
[build]   	const char *name0, const char *description0, const char *name1,
[build]   	const char *description1, obs_hotkey_active_func func0,
[build]   	obs_hotkey_active_func func1, void *data0, void *data1);
[build]   
[build]    obs_hotkey_pair_id obs_hotkey_pair_register_encoder(
[build]   	obs_encoder_t *encoder, const char *name0, const char *description0,
[build]   	const char *name1, const char *description1,
[build]   	obs_hotkey_active_func func0, obs_hotkey_active_func func1, void *data0,
[build]   	void *data1);
[build]   
[build]    obs_hotkey_pair_id obs_hotkey_pair_register_output(
[build]   	obs_output_t *output, const char *name0, const char *description0,
[build]   	const char *name1, const char *description1,
[build]   	obs_hotkey_active_func func0, obs_hotkey_active_func func1, void *data0,
[build]   	void *data1);
[build]   
[build]    obs_hotkey_pair_id obs_hotkey_pair_register_service(
[build]   	obs_service_t *service, const char *name0, const char *description0,
[build]   	const char *name1, const char *description1,
[build]   	obs_hotkey_active_func func0, obs_hotkey_active_func func1, void *data0,
[build]   	void *data1);
[build]   
[build]    obs_hotkey_pair_id obs_hotkey_pair_register_source(
[build]   	obs_source_t *source, const char *name0, const char *description0,
[build]   	const char *name1, const char *description1,
[build]   	obs_hotkey_active_func func0, obs_hotkey_active_func func1, void *data0,
[build]   	void *data1);
[build]   
[build]    void obs_hotkey_unregister(obs_hotkey_id id);
[build]   
[build]    void obs_hotkey_pair_unregister(obs_hotkey_pair_id id);
[build]   
[build]   /* loading hotkeys (associating a hotkey with a physical key and modifiers) */
[build]   
[build]    void obs_hotkey_load_bindings(obs_hotkey_id id,
[build]   				     obs_key_combination_t *combinations,
[build]   				     size_t num);
[build]   
[build]    void obs_hotkey_load(obs_hotkey_id id, obs_data_array_t *data);
[build]   
[build]    void obs_hotkeys_load_encoder(obs_encoder_t *encoder,
[build]   				     obs_data_t *hotkeys);
[build]   
[build]    void obs_hotkeys_load_output(obs_output_t *output, obs_data_t *hotkeys);
[build]   
[build]    void obs_hotkeys_load_service(obs_service_t *service,
[build]   				     obs_data_t *hotkeys);
[build]   
[build]    void obs_hotkeys_load_source(obs_source_t *source, obs_data_t *hotkeys);
[build]   
[build]    void obs_hotkey_pair_load(obs_hotkey_pair_id id, obs_data_array_t *data0,
[build]   				 obs_data_array_t *data1);
[build]   
[build]    obs_data_array_t *obs_hotkey_save(obs_hotkey_id id);
[build]   
[build]    void obs_hotkey_pair_save(obs_hotkey_pair_id id,
[build]   				 obs_data_array_t **p_data0,
[build]   				 obs_data_array_t **p_data1);
[build]   
[build]    obs_data_t *obs_hotkeys_save_encoder(obs_encoder_t *encoder);
[build]   
[build]    obs_data_t *obs_hotkeys_save_output(obs_output_t *output);
[build]   
[build]    obs_data_t *obs_hotkeys_save_service(obs_service_t *service);
[build]   
[build]    obs_data_t *obs_hotkeys_save_source(obs_source_t *source);
[build]   
[build]   /* enumerating hotkeys */
[build]   
[build]   typedef bool (*obs_hotkey_enum_func)(void *data, obs_hotkey_id id,
[build]   				     obs_hotkey_t *key);
[build]   
[build]    void obs_enum_hotkeys(obs_hotkey_enum_func func, void *data);
[build]   
[build]   /* enumerating bindings */
[build]   
[build]   typedef bool (*obs_hotkey_binding_enum_func)(void *data, size_t idx,
[build]   					     obs_hotkey_binding_t *binding);
[build]   
[build]    void obs_enum_hotkey_bindings(obs_hotkey_binding_enum_func func,
[build]   				     void *data);
[build]   
[build]   /* hotkey event control */
[build]   
[build]    void obs_hotkey_inject_event(obs_key_combination_t hotkey, bool pressed);
[build]   
[build]    void obs_hotkey_enable_background_press(bool enable);
[build]   
[build]    void obs_hotkey_enable_strict_modifiers(bool enable);
[build]   
[build]   /* hotkey callback routing (trigger callbacks through e.g. a UI thread) */
[build]   
[build]   typedef void (*obs_hotkey_callback_router_func)(void *data, obs_hotkey_id id,
[build]   						bool pressed);
[build]   
[build]    void
[build]   obs_hotkey_set_callback_routing_func(obs_hotkey_callback_router_func func,
[build]   				     void *data);
[build]   
[build]    void obs_hotkey_trigger_routed_callback(obs_hotkey_id id, bool pressed);
[build]   
[build]   /* hotkey callbacks won't be processed if callback rerouting is enabled and no
[build]    * router func is set */
[build]    void obs_hotkey_enable_callback_rerouting(bool enable);
[build]   
[build]   /* misc */
[build]   
[build]   typedef void (*obs_hotkey_atomic_update_func)(void *);
[build]    void obs_hotkey_update_atomic(obs_hotkey_atomic_update_func func,
[build]   				     void *data);
[build]   
[build]   struct dstr;
[build]    void obs_key_to_str(obs_key_t key, struct dstr *str);
[build]    void obs_key_combination_to_str(obs_key_combination_t key,
[build]   				       struct dstr *str);
[build]   
[build]    obs_key_t obs_key_from_virtual_key(int code);
[build]    int obs_key_to_virtual_key(obs_key_t key);
[build]   
[build]    const char *obs_key_to_name(obs_key_t key);
[build]    obs_key_t obs_key_from_name(const char *name);
[build]   
[build]   static inline bool obs_key_combination_is_empty(obs_key_combination_t combo)
[build]   {
[build]   	return !combo.modifiers && combo.key == OBS_KEY_NONE;
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\obs.h" %beginfile
[build]   /******************************************************************************
[build]       Copyright (C) 2013-2014 by Hugh Bailey <jim@obsproject.com>
[build]   
[build]       This program is free software: you can redistribute it and/or modify
[build]       it under the terms of the GNU General Public License as published by
[build]       the Free Software Foundation, either version 2 of the License, or
[build]       (at your option) any later version.
[build]   
[build]       This program is distributed in the hope that it will be useful,
[build]       but WITHOUT ANY WARRANTY; without even the implied warranty of
[build]       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
[build]       GNU General Public License for more details.
[build]   
[build]       You should have received a copy of the GNU General Public License
[build]       along with this program.  If not, see <http://www.gnu.org/licenses/>.
[build]   ******************************************************************************/
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   struct matrix4;
[build]   
[build]   /* opaque types */
[build]   struct obs_display;
[build]   struct obs_view;
[build]   struct obs_source;
[build]   struct obs_scene;
[build]   struct obs_scene_item;
[build]   struct obs_output;
[build]   struct obs_encoder;
[build]   struct obs_service;
[build]   struct obs_module;
[build]   struct obs_fader;
[build]   struct obs_volmeter;
[build]   
[build]   typedef struct obs_display obs_display_t;
[build]   typedef struct obs_view obs_view_t;
[build]   typedef struct obs_source obs_source_t;
[build]   typedef struct obs_scene obs_scene_t;
[build]   typedef struct obs_scene_item obs_sceneitem_t;
[build]   typedef struct obs_output obs_output_t;
[build]   typedef struct obs_encoder obs_encoder_t;
[build]   typedef struct obs_service obs_service_t;
[build]   typedef struct obs_module obs_module_t;
[build]   typedef struct obs_fader obs_fader_t;
[build]   typedef struct obs_volmeter obs_volmeter_t;
[build]   
[build]   typedef struct obs_weak_source obs_weak_source_t;
[build]   typedef struct obs_weak_output obs_weak_output_t;
[build]   typedef struct obs_weak_encoder obs_weak_encoder_t;
[build]   typedef struct obs_weak_service obs_weak_service_t;
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /**
[build]    * @file
[build]    * @brief Main libobs header used by applications.
[build]    *
[build]    * @mainpage
[build]    *
[build]    * @section intro_sec Introduction
[build]    *
[build]    * This document describes the api for libobs to be used by applications as well
[build]    * as @ref modules_page implementing some kind of functionality.
[build]    *
[build]    */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /** Used for changing the order of items (for example, filters in a source,
[build]    * or items in a scene) */
[build]   enum obs_order_movement {
[build]   	OBS_ORDER_MOVE_UP,
[build]   	OBS_ORDER_MOVE_DOWN,
[build]   	OBS_ORDER_MOVE_TOP,
[build]   	OBS_ORDER_MOVE_BOTTOM,
[build]   };
[build]   
[build]   /**
[build]    * Used with obs_source_process_filter to specify whether the filter should
[build]    * render the source directly with the specified effect, or whether it should
[build]    * render it to a texture
[build]    */
[build]   enum obs_allow_direct_render {
[build]   	OBS_NO_DIRECT_RENDERING,
[build]   	OBS_ALLOW_DIRECT_RENDERING,
[build]   };
[build]   
[build]   enum obs_scale_type {
[build]   	OBS_SCALE_DISABLE,
[build]   	OBS_SCALE_POINT,
[build]   	OBS_SCALE_BICUBIC,
[build]   	OBS_SCALE_BILINEAR,
[build]   	OBS_SCALE_LANCZOS,
[build]   	OBS_SCALE_AREA,
[build]   };
[build]   
[build]   /**
[build]    * Used with scene items to indicate the type of bounds to use for scene items.
[build]    * Mostly determines how the image will be scaled within those bounds, or
[build]    * whether to use bounds at all.
[build]    */
[build]   enum obs_bounds_type {
[build]   	OBS_BOUNDS_NONE,            /**< no bounds */
[build]   	OBS_BOUNDS_STRETCH,         /**< stretch (ignores base scale) */
[build]   	OBS_BOUNDS_SCALE_INNER,     /**< scales to inner rectangle */
[build]   	OBS_BOUNDS_SCALE_OUTER,     /**< scales to outer rectangle */
[build]   	OBS_BOUNDS_SCALE_TO_WIDTH,  /**< scales to the width  */
[build]   	OBS_BOUNDS_SCALE_TO_HEIGHT, /**< scales to the height */
[build]   	OBS_BOUNDS_MAX_ONLY,        /**< no scaling, maximum size only */
[build]   };
[build]   
[build]   struct obs_transform_info {
[build]   	struct vec2 pos;
[build]   	float rot;
[build]   	struct vec2 scale;
[build]   	uint32_t alignment;
[build]   
[build]   	enum obs_bounds_type bounds_type;
[build]   	uint32_t bounds_alignment;
[build]   	struct vec2 bounds;
[build]   };
[build]   
[build]   /**
[build]    * Video initialization structure
[build]    */
[build]   struct obs_video_info {
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   	uint32_t fps_num; /**< Output FPS numerator */
[build]   	uint32_t fps_den; /**< Output FPS denominator */
[build]   
[build]   	uint32_t base_width;  /**< Base compositing width */
[build]   	uint32_t base_height; /**< Base compositing height */
[build]   
[build]   	uint32_t output_width;           /**< Output width */
[build]   	uint32_t output_height;          /**< Output height */
[build]   	enum video_format output_format; /**< Output format */
[build]   
[build]   	/** Video adapter index to use (NOTE: avoid for optimus laptops) */
[build]   	uint32_t adapter;
[build]   
[build]   	/** Use shaders to convert to different color formats */
[build]   	bool gpu_conversion;
[build]   
[build]   	enum video_colorspace colorspace; /**< YUV type (if YUV) */
[build]   	enum video_range_type range;      /**< YUV range (if YUV) */
[build]   
[build]   	enum obs_scale_type scale_type; /**< How to scale if scaling */
[build]   };
[build]   
[build]   /**
[build]    * Audio initialization structure
[build]    */
[build]   struct obs_audio_info {
[build]   	uint32_t samples_per_sec;
[build]   	enum speaker_layout speakers;
[build]   };
[build]   
[build]   /**
[build]    * Sent to source filters via the filter_audio callback to allow filtering of
[build]    * audio data
[build]    */
[build]   struct obs_audio_data {
[build]   	uint8_t *data[MAX_AV_PLANES];
[build]   	uint32_t frames;
[build]   	uint64_t timestamp;
[build]   };
[build]   
[build]   /**
[build]    * Source audio output structure.  Used with obs_source_output_audio to output
[build]    * source audio.  Audio is automatically resampled and remixed as necessary.
[build]    */
[build]   struct obs_source_audio {
[build]   	const uint8_t *data[MAX_AV_PLANES];
[build]   	uint32_t frames;
[build]   
[build]   	enum speaker_layout speakers;
[build]   	enum audio_format format;
[build]   	uint32_t samples_per_sec;
[build]   
[build]   	uint64_t timestamp;
[build]   };
[build]   
[build]   struct obs_source_cea_708 {
[build]   	const uint8_t *data;
[build]   	uint32_t packets;
[build]   	uint64_t timestamp;
[build]   };
[build]   
[build]   /**
[build]    * Source asynchronous video output structure.  Used with
[build]    * obs_source_output_video to output asynchronous video.  Video is buffered as
[build]    * necessary to play according to timestamps.  When used with audio output,
[build]    * audio is synced to video as it is played.
[build]    *
[build]    * If a YUV format is specified, it will be automatically upsampled and
[build]    * converted to RGB via shader on the graphics processor.
[build]    *
[build]    * NOTE: Non-YUV formats will always be treated as full range with this
[build]    * structure!  Use obs_source_frame2 along with obs_source_output_video2
[build]    * instead if partial range support is desired for non-YUV video formats.
[build]    */
[build]   struct obs_source_frame {
[build]   	uint8_t *data[MAX_AV_PLANES];
[build]   	uint32_t linesize[MAX_AV_PLANES];
[build]   	uint32_t width;
[build]   	uint32_t height;
[build]   	uint64_t timestamp;
[build]   
[build]   	enum video_format format;
[build]   	float color_matrix[16];
[build]   	bool full_range;
[build]   	float color_range_min[3];
[build]   	float color_range_max[3];
[build]   	bool flip;
[build]   
[build]   	/* used internally by libobs */
[build]   	volatile long refs;
[build]   	bool prev_frame;
[build]   };
[build]   
[build]   struct obs_source_frame2 {
[build]   	uint8_t *data[MAX_AV_PLANES];
[build]   	uint32_t linesize[MAX_AV_PLANES];
[build]   	uint32_t width;
[build]   	uint32_t height;
[build]   	uint64_t timestamp;
[build]   
[build]   	enum video_format format;
[build]   	enum video_range_type range;
[build]   	float color_matrix[16];
[build]   	float color_range_min[3];
[build]   	float color_range_max[3];
[build]   	bool flip;
[build]   };
[build]   
[build]   /** Access to the argc/argv used to start OBS. What you see is what you get. */
[build]   struct obs_cmdline_args {
[build]   	int argc;
[build]   	char **argv;
[build]   };
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* OBS context */
[build]   
[build]   /**
[build]    * Find a core libobs data file
[build]    * @param path name of the base file
[build]    * @return A string containing the full path to the file.
[build]    *          Use bfree after use.
[build]    */
[build]    char *obs_find_data_file(const char *file);
[build]   
[build]   /**
[build]    * Add a path to search libobs data files in.
[build]    * @param path Full path to directory to look in.
[build]    *             The string is copied.
[build]    */
[build]    void obs_add_data_path(const char *path);
[build]   
[build]   /**
[build]    * Remove a path from libobs core data paths.
[build]    * @param path The path to compare to currently set paths.
[build]    *             It does not need to be the same pointer, but
[build]    *             the path string must match an entry fully.
[build]    * @return Whether or not the path was successfully removed.
[build]    *         If false, the path could not be found.
[build]    */
[build]    bool obs_remove_data_path(const char *path);
[build]   
[build]   /**
[build]    * Initializes OBS
[build]    *
[build]    * @param  locale              The locale to use for modules
[build]    * @param  module_config_path  Path to module config storage directory
[build]    *                             (or NULL if none)
[build]    * @param  store               The profiler name store for OBS to use or NULL
[build]    */
[build]    bool obs_startup(const char *locale, const char *module_config_path,
[build]   			profiler_name_store_t *store);
[build]   
[build]   /** Releases all data associated with OBS and terminates the OBS context */
[build]    void obs_shutdown(void);
[build]   
[build]   /** @return true if the main OBS context has been initialized */
[build]    bool obs_initialized(void);
[build]   
[build]   /** @return The current core version */
[build]    uint32_t obs_get_version(void);
[build]   
[build]   /** @return The current core version string */
[build]    const char *obs_get_version_string(void);
[build]   
[build]   /**
[build]    * Sets things up for calls to obs_get_cmdline_args. Called only once at startup
[build]    * and safely copies argv/argc from main(). Subsequent calls do nothing.
[build]    *
[build]    * @param  argc  The count of command line arguments, from main()
[build]    * @param  argv  An array of command line arguments, copied from main() and ends
[build]    *               with NULL.
[build]    */
[build]    void obs_set_cmdline_args(int argc, const char *const *argv);
[build]   
[build]   /**
[build]    * Get the argc/argv used to start OBS
[build]    *
[build]    * @return  The command line arguments used for main(). Don't modify this or
[build]    *          you'll mess things up for other callers.
[build]    */
[build]    struct obs_cmdline_args obs_get_cmdline_args(void);
[build]   
[build]   /**
[build]    * Sets a new locale to use for modules.  This will call obs_module_set_locale
[build]    * for each module with the new locale.
[build]    *
[build]    * @param  locale  The locale to use for modules
[build]    */
[build]    void obs_set_locale(const char *locale);
[build]   
[build]   /** @return the current locale */
[build]    const char *obs_get_locale(void);
[build]   
[build]   /** Initialize the Windows-specific crash handler */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /**
[build]    * Returns the profiler name store (see util/profiler.h) used by OBS, which is
[build]    * either a name store passed to obs_startup, an internal name store, or NULL
[build]    * in case obs_initialized() returns false.
[build]    */
[build]    profiler_name_store_t *obs_get_profiler_name_store(void);
[build]   
[build]   /**
[build]    * Sets base video output base resolution/fps/format.
[build]    *
[build]    * @note This data cannot be changed if an output is currently active.
[build]    * @note The graphics module cannot be changed without fully destroying the
[build]    *       OBS context.
[build]    *
[build]    * @param   ovi  Pointer to an obs_video_info structure containing the
[build]    *               specification of the graphics subsystem,
[build]    * @return       OBS_VIDEO_SUCCESS if successful
[build]    *               OBS_VIDEO_NOT_SUPPORTED if the adapter lacks capabilities
[build]    *               OBS_VIDEO_INVALID_PARAM if a parameter is invalid
[build]    *               OBS_VIDEO_CURRENTLY_ACTIVE if video is currently active
[build]    *               OBS_VIDEO_MODULE_NOT_FOUND if the graphics module is not found
[build]    *               OBS_VIDEO_FAIL for generic failure
[build]    */
[build]    int obs_reset_video(struct obs_video_info *ovi);
[build]   
[build]   /**
[build]    * Sets base audio output format/channels/samples/etc
[build]    *
[build]    * @note Cannot reset base audio if an output is currently active.
[build]    */
[build]    bool obs_reset_audio(const struct obs_audio_info *oai);
[build]   
[build]   /** Gets the current video settings, returns false if no video */
[build]    bool obs_get_video_info(struct obs_video_info *ovi);
[build]   
[build]   /** Gets the current audio settings, returns false if no audio */
[build]    bool obs_get_audio_info(struct obs_audio_info *oai);
[build]   
[build]   /**
[build]    * Opens a plugin module directly from a specific path.
[build]    *
[build]    * If the module already exists then the function will return successful, and
[build]    * the module parameter will be given the pointer to the existing module.
[build]    *
[build]    * This does not initialize the module, it only loads the module image.  To
[build]    * initialize the module, call obs_init_module.
[build]    *
[build]    * @param  module     The pointer to the created module.
[build]    * @param  path       Specifies the path to the module library file.  If the
[build]    *                    extension is not specified, it will use the extension
[build]    *                    appropriate to the operating system.
[build]    * @param  data_path  Specifies the path to the directory where the module's
[build]    *                    data files are stored.
[build]    * @returns           MODULE_SUCCESS if successful
[build]    *                    MODULE_ERROR if a generic error occurred
[build]    *                    MODULE_FILE_NOT_FOUND if the module was not found
[build]    *                    MODULE_MISSING_EXPORTS if required exports are missing
[build]    *                    MODULE_INCOMPATIBLE_VER if incompatible version
[build]    */
[build]    int obs_open_module(obs_module_t **module, const char *path,
[build]   			   const char *data_path);
[build]   
[build]   /**
[build]    * Initializes the module, which calls its obs_module_load export.  If the
[build]    * module is already loaded, then this function does nothing and returns
[build]    * successful.
[build]    */
[build]    bool obs_init_module(obs_module_t *module);
[build]   
[build]   /** Returns a module based upon its name, or NULL if not found */
[build]    obs_module_t *obs_get_module(const char *name);
[build]   
[build]   /** Returns locale text from a specific module */
[build]    bool obs_module_get_locale_string(const obs_module_t *mod,
[build]   					 const char *lookup_string,
[build]   					 const char **translated_string);
[build]   
[build]    const char *obs_module_get_locale_text(const obs_module_t *mod,
[build]   					      const char *text);
[build]   
[build]   /** Logs loaded modules */
[build]    void obs_log_loaded_modules(void);
[build]   
[build]   /** Returns the module file name */
[build]    const char *obs_get_module_file_name(obs_module_t *module);
[build]   
[build]   /** Returns the module full name */
[build]    const char *obs_get_module_name(obs_module_t *module);
[build]   
[build]   /** Returns the module author(s) */
[build]    const char *obs_get_module_author(obs_module_t *module);
[build]   
[build]   /** Returns the module description */
[build]    const char *obs_get_module_description(obs_module_t *module);
[build]   
[build]   /** Returns the module binary path */
[build]    const char *obs_get_module_binary_path(obs_module_t *module);
[build]   
[build]   /** Returns the module data path */
[build]    const char *obs_get_module_data_path(obs_module_t *module);
[build]   
[build]   /**
[build]    * Adds a module search path to be used with obs_find_modules.  If the search
[build]    * path strings contain %module%, that text will be replaced with the module
[build]    * name when used.
[build]    *
[build]    * @param  bin   Specifies the module's binary directory search path.
[build]    * @param  data  Specifies the module's data directory search path.
[build]    */
[build]    void obs_add_module_path(const char *bin, const char *data);
[build]   
[build]   /** Automatically loads all modules from module paths (convenience function) */
[build]    void obs_load_all_modules(void);
[build]   
[build]   /** Notifies modules that all modules have been loaded.  This function should
[build]    * be called after all modules have been loaded. */
[build]    void obs_post_load_modules(void);
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   typedef void (*obs_enum_module_callback_t)(void *param, obs_module_t *module);
[build]   
[build]   /** Enumerates all loaded modules */
[build]    void obs_enum_modules(obs_enum_module_callback_t callback, void *param);
[build]   
[build]   /** Helper function for using default module locale */
[build]    lookup_t *obs_module_load_locale(obs_module_t *module,
[build]   					const char *default_locale,
[build]   					const char *locale);
[build]   
[build]   /**
[build]    * Returns the location of a plugin module data file.
[build]    *
[build]    * @note   Modules should use obs_module_file function defined in obs-module.h
[build]    *         as a more elegant means of getting their files without having to
[build]    *         specify the module parameter.
[build]    *
[build]    * @param  module  The module associated with the file to locate
[build]    * @param  file    The file to locate
[build]    * @return         Path string, or NULL if not found.  Use bfree to free string.
[build]    */
[build]    char *obs_find_module_file(obs_module_t *module, const char *file);
[build]   
[build]   /**
[build]    * Returns the path of a plugin module config file (whether it exists or not)
[build]    *
[build]    * @note   Modules should use obs_module_config_path function defined in
[build]    *         obs-module.h as a more elegant means of getting their files without
[build]    *         having to specify the module parameter.
[build]    *
[build]    * @param  module  The module associated with the path
[build]    * @param  file    The file to get a path to
[build]    * @return         Path string, or NULL if not found.  Use bfree to free string.
[build]    */
[build]    char *obs_module_get_config_path(obs_module_t *module, const char *file);
[build]   
[build]   /** Enumerates all source types (inputs, filters, transitions, etc).  */
[build]    bool obs_enum_source_types(size_t idx, const char **id);
[build]   
[build]   /**
[build]    * Enumerates all available inputs source types.
[build]    *
[build]    *   Inputs are general source inputs (such as capture sources, device sources,
[build]    * etc).
[build]    */
[build]    bool obs_enum_input_types(size_t idx, const char **id);
[build]    bool obs_enum_input_types2(size_t idx, const char **id,
[build]   				  const char **unversioned_id);
[build]   
[build]    const char *obs_get_latest_input_type_id(const char *unversioned_id);
[build]   
[build]   /**
[build]    * Enumerates all available filter source types.
[build]    *
[build]    *   Filters are sources that are used to modify the video/audio output of
[build]    * other sources.
[build]    */
[build]    bool obs_enum_filter_types(size_t idx, const char **id);
[build]   
[build]   /**
[build]    * Enumerates all available transition source types.
[build]    *
[build]    *   Transitions are sources used to transition between two or more other
[build]    * sources.
[build]    */
[build]    bool obs_enum_transition_types(size_t idx, const char **id);
[build]   
[build]   /** Enumerates all available output types. */
[build]    bool obs_enum_output_types(size_t idx, const char **id);
[build]   
[build]   /** Enumerates all available encoder types. */
[build]    bool obs_enum_encoder_types(size_t idx, const char **id);
[build]   
[build]   /** Enumerates all available service types. */
[build]    bool obs_enum_service_types(size_t idx, const char **id);
[build]   
[build]   /** Helper function for entering the OBS graphics context */
[build]    void obs_enter_graphics(void);
[build]   
[build]   /** Helper function for leaving the OBS graphics context */
[build]    void obs_leave_graphics(void);
[build]   
[build]   /** Gets the main audio output handler for this OBS context */
[build]    audio_t *obs_get_audio(void);
[build]   
[build]   /** Gets the main video output handler for this OBS context */
[build]    video_t *obs_get_video(void);
[build]   
[build]   /** Returns true if video is active, false otherwise */
[build]    bool obs_video_active(void);
[build]   
[build]   /** Sets the primary output source for a channel. */
[build]    void obs_set_output_source(uint32_t channel, obs_source_t *source);
[build]   
[build]   /**
[build]    * Gets the primary output source for a channel and increments the reference
[build]    * counter for that source.  Use obs_source_release to release.
[build]    */
[build]    obs_source_t *obs_get_output_source(uint32_t channel);
[build]   
[build]   /**
[build]    * Enumerates all input sources
[build]    *
[build]    *   Callback function returns true to continue enumeration, or false to end
[build]    * enumeration.
[build]    *
[build]    *   Use obs_source_get_ref or obs_source_get_weak_source if you want to retain
[build]    * a reference after obs_enum_sources finishes
[build]    */
[build]    void obs_enum_sources(bool (*enum_proc)(void *, obs_source_t *),
[build]   			     void *param);
[build]   
[build]   /** Enumerates scenes */
[build]    void obs_enum_scenes(bool (*enum_proc)(void *, obs_source_t *),
[build]   			    void *param);
[build]   
[build]   /** Enumerates outputs */
[build]    void obs_enum_outputs(bool (*enum_proc)(void *, obs_output_t *),
[build]   			     void *param);
[build]   
[build]   /** Enumerates encoders */
[build]    void obs_enum_encoders(bool (*enum_proc)(void *, obs_encoder_t *),
[build]   			      void *param);
[build]   
[build]   /** Enumerates encoders */
[build]    void obs_enum_services(bool (*enum_proc)(void *, obs_service_t *),
[build]   			      void *param);
[build]   
[build]   /**
[build]    * Gets a source by its name.
[build]    *
[build]    *   Increments the source reference counter, use obs_source_release to
[build]    * release it when complete.
[build]    */
[build]    obs_source_t *obs_get_source_by_name(const char *name);
[build]   
[build]   /** Gets an output by its name. */
[build]    obs_output_t *obs_get_output_by_name(const char *name);
[build]   
[build]   /** Gets an encoder by its name. */
[build]    obs_encoder_t *obs_get_encoder_by_name(const char *name);
[build]   
[build]   /** Gets an service by its name. */
[build]    obs_service_t *obs_get_service_by_name(const char *name);
[build]   
[build]   enum obs_base_effect {
[build]   	OBS_EFFECT_DEFAULT,         /**< RGB/YUV */
[build]   	OBS_EFFECT_DEFAULT_RECT,    /**< RGB/YUV (using texture_rect) */
[build]   	OBS_EFFECT_OPAQUE,          /**< RGB/YUV (alpha set to 1.0) */
[build]   	OBS_EFFECT_SOLID,           /**< RGB/YUV (solid color only) */
[build]   	OBS_EFFECT_BICUBIC,         /**< Bicubic downscale */
[build]   	OBS_EFFECT_LANCZOS,         /**< Lanczos downscale */
[build]   	OBS_EFFECT_BILINEAR_LOWRES, /**< Bilinear low resolution downscale */
[build]   	OBS_EFFECT_PREMULTIPLIED_ALPHA, /**< Premultiplied alpha */
[build]   	OBS_EFFECT_REPEAT,              /**< RGB/YUV (repeating) */
[build]   	OBS_EFFECT_AREA,                /**< Area rescale */
[build]   };
[build]   
[build]   /** Returns a commonly used base effect */
[build]    gs_effect_t *obs_get_base_effect(enum obs_base_effect effect);
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /** Returns the primary obs signal handler */
[build]    signal_handler_t *obs_get_signal_handler(void);
[build]   
[build]   /** Returns the primary obs procedure handler */
[build]    proc_handler_t *obs_get_proc_handler(void);
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /** Renders the last main output texture */
[build]    void obs_render_main_texture(void);
[build]   
[build]   /** Renders the last main output texture ignoring background color */
[build]    void obs_render_main_texture_src_color_only(void);
[build]   
[build]   /** Returns the last main output texture.  This can return NULL if the texture
[build]    * is unavailable. */
[build]    gs_texture_t *obs_get_main_texture(void);
[build]   
[build]   /** Sets the master user volume */
[build]    void obs_set_master_volume(float volume);
[build]   
[build]   /** Gets the master user volume */
[build]    float obs_get_master_volume(void);
[build]   
[build]   /** Saves a source to settings data */
[build]    obs_data_t *obs_save_source(obs_source_t *source);
[build]   
[build]   /** Loads a source from settings data */
[build]    obs_source_t *obs_load_source(obs_data_t *data);
[build]   
[build]   /** Send a save signal to sources */
[build]    void obs_source_save(obs_source_t *source);
[build]   
[build]   /** Send a load signal to sources */
[build]    void obs_source_load(obs_source_t *source);
[build]   
[build]   typedef void (*obs_load_source_cb)(void *private_data, obs_source_t *source);
[build]   
[build]   /** Loads sources from a data array */
[build]    void obs_load_sources(obs_data_array_t *array, obs_load_source_cb cb,
[build]   			     void *private_data);
[build]   
[build]   /** Saves sources to a data array */
[build]    obs_data_array_t *obs_save_sources(void);
[build]   
[build]   typedef bool (*obs_save_source_filter_cb)(void *data, obs_source_t *source);
[build]    obs_data_array_t *obs_save_sources_filtered(obs_save_source_filter_cb cb,
[build]   						   void *data);
[build]   
[build]   enum obs_obj_type {
[build]   	OBS_OBJ_TYPE_INVALID,
[build]   	OBS_OBJ_TYPE_SOURCE,
[build]   	OBS_OBJ_TYPE_OUTPUT,
[build]   	OBS_OBJ_TYPE_ENCODER,
[build]   	OBS_OBJ_TYPE_SERVICE,
[build]   };
[build]   
[build]    enum obs_obj_type obs_obj_get_type(void *obj);
[build]    const char *obs_obj_get_id(void *obj);
[build]    bool obs_obj_invalid(void *obj);
[build]    void *obs_obj_get_data(void *obj);
[build]   
[build]   typedef bool (*obs_enum_audio_device_cb)(void *data, const char *name,
[build]   					 const char *id);
[build]   
[build]    void obs_enum_audio_monitoring_devices(obs_enum_audio_device_cb cb,
[build]   					      void *data);
[build]   
[build]    bool obs_set_audio_monitoring_device(const char *name, const char *id);
[build]    void obs_get_audio_monitoring_device(const char **name, const char **id);
[build]   
[build]    void obs_add_tick_callback(void (*tick)(void *param, float seconds),
[build]   				  void *param);
[build]    void obs_remove_tick_callback(void (*tick)(void *param, float seconds),
[build]   				     void *param);
[build]   
[build]    void obs_add_main_render_callback(void (*draw)(void *param, uint32_t cx,
[build]   						      uint32_t cy),
[build]   					 void *param);
[build]    void obs_remove_main_render_callback(
[build]   	void (*draw)(void *param, uint32_t cx, uint32_t cy), void *param);
[build]   
[build]    void obs_add_raw_video_callback(
[build]   	const struct video_scale_info *conversion,
[build]   	void (*callback)(void *param, struct video_data *frame), void *param);
[build]    void obs_remove_raw_video_callback(
[build]   	void (*callback)(void *param, struct video_data *frame), void *param);
[build]   
[build]    uint64_t obs_get_video_frame_time(void);
[build]   
[build]    double obs_get_active_fps(void);
[build]    uint64_t obs_get_average_frame_time_ns(void);
[build]    uint64_t obs_get_frame_interval_ns(void);
[build]   
[build]    uint32_t obs_get_total_frames(void);
[build]    uint32_t obs_get_lagged_frames(void);
[build]   
[build]    bool obs_nv12_tex_active(void);
[build]   
[build]    void obs_apply_private_data(obs_data_t *settings);
[build]    void obs_set_private_data(obs_data_t *settings);
[build]    obs_data_t *obs_get_private_data(void);
[build]   
[build]   typedef void (*obs_task_t)(void *param);
[build]   
[build]   enum obs_task_type {
[build]   	OBS_TASK_UI,
[build]   	OBS_TASK_GRAPHICS,
[build]   };
[build]   
[build]    void obs_queue_task(enum obs_task_type type, obs_task_t task,
[build]   			   void *param, bool wait);
[build]   
[build]   typedef void (*obs_task_handler_t)(obs_task_t task, void *param, bool wait);
[build]    void obs_set_ui_task_handler(obs_task_handler_t handler);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* View context */
[build]   
[build]   /**
[build]    * Creates a view context.
[build]    *
[build]    *   A view can be used for things like separate previews, or drawing
[build]    * sources separately.
[build]    */
[build]    obs_view_t *obs_view_create(void);
[build]   
[build]   /** Destroys this view context */
[build]    void obs_view_destroy(obs_view_t *view);
[build]   
[build]   /** Sets the source to be used for this view context. */
[build]    void obs_view_set_source(obs_view_t *view, uint32_t channel,
[build]   				obs_source_t *source);
[build]   
[build]   /** Gets the source currently in use for this view context */
[build]    obs_source_t *obs_view_get_source(obs_view_t *view, uint32_t channel);
[build]   
[build]   /** Renders the sources of this view context */
[build]    void obs_view_render(obs_view_t *view);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Display context */
[build]   
[build]   /**
[build]    * Adds a new window display linked to the main render pipeline.  This creates
[build]    * a new swap chain which updates every frame.
[build]    *
[build]    * @param  graphics_data  The swap chain initialization data.
[build]    * @return                The new display context, or NULL if failed.
[build]    */
[build]    obs_display_t *
[build]   obs_display_create(const struct gs_init_data *graphics_data,
[build]   		   uint32_t backround_color);
[build]   
[build]   /** Destroys a display context */
[build]    void obs_display_destroy(obs_display_t *display);
[build]   
[build]   /** Changes the size of this display */
[build]    void obs_display_resize(obs_display_t *display, uint32_t cx,
[build]   			       uint32_t cy);
[build]   
[build]   /**
[build]    * Adds a draw callback for this display context
[build]    *
[build]    * @param  display  The display context.
[build]    * @param  draw     The draw callback which is called each time a frame
[build]    *                  updates.
[build]    * @param  param    The user data to be associated with this draw callback.
[build]    */
[build]    void obs_display_add_draw_callback(obs_display_t *display,
[build]   					  void (*draw)(void *param, uint32_t cx,
[build]   						       uint32_t cy),
[build]   					  void *param);
[build]   
[build]   /** Removes a draw callback for this display context */
[build]    void obs_display_remove_draw_callback(
[build]   	obs_display_t *display,
[build]   	void (*draw)(void *param, uint32_t cx, uint32_t cy), void *param);
[build]   
[build]    void obs_display_set_enabled(obs_display_t *display, bool enable);
[build]    bool obs_display_enabled(obs_display_t *display);
[build]   
[build]    void obs_display_set_background_color(obs_display_t *display,
[build]   					     uint32_t color);
[build]   
[build]    void obs_display_size(obs_display_t *display, uint32_t *width,
[build]   			     uint32_t *height);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Sources */
[build]   
[build]   /** Returns the translated display name of a source */
[build]    const char *obs_source_get_display_name(const char *id);
[build]   
[build]   /**
[build]    * Creates a source of the specified type with the specified settings.
[build]    *
[build]    *   The "source" context is used for anything related to presenting
[build]    * or modifying video/audio.  Use obs_source_release to release it.
[build]    */
[build]    obs_source_t *obs_source_create(const char *id, const char *name,
[build]   				       obs_data_t *settings,
[build]   				       obs_data_t *hotkey_data);
[build]   
[build]    obs_source_t *obs_source_create_private(const char *id, const char *name,
[build]   					       obs_data_t *settings);
[build]   
[build]   /* if source has OBS_SOURCE_DO_NOT_DUPLICATE output flag set, only returns a
[build]    * reference */
[build]    obs_source_t *obs_source_duplicate(obs_source_t *source,
[build]   					  const char *desired_name,
[build]   					  bool create_private);
[build]   /**
[build]    * Adds/releases a reference to a source.  When the last reference is
[build]    * released, the source is destroyed.
[build]    */
[build]    void obs_source_addref(obs_source_t *source);
[build]    void obs_source_release(obs_source_t *source);
[build]   
[build]    void obs_weak_source_addref(obs_weak_source_t *weak);
[build]    void obs_weak_source_release(obs_weak_source_t *weak);
[build]   
[build]    obs_source_t *obs_source_get_ref(obs_source_t *source);
[build]    obs_weak_source_t *obs_source_get_weak_source(obs_source_t *source);
[build]    obs_source_t *obs_weak_source_get_source(obs_weak_source_t *weak);
[build]   
[build]    bool obs_weak_source_references_source(obs_weak_source_t *weak,
[build]   					      obs_source_t *source);
[build]   
[build]   /** Notifies all references that the source should be released */
[build]    void obs_source_remove(obs_source_t *source);
[build]   
[build]   /** Returns true if the source should be released */
[build]    bool obs_source_removed(const obs_source_t *source);
[build]   
[build]   /** Returns capability flags of a source */
[build]    uint32_t obs_source_get_output_flags(const obs_source_t *source);
[build]   
[build]   /** Returns capability flags of a source type */
[build]    uint32_t obs_get_source_output_flags(const char *id);
[build]   
[build]   /** Gets the default settings for a source type */
[build]    obs_data_t *obs_get_source_defaults(const char *id);
[build]   
[build]   /** Returns the property list, if any.  Free with obs_properties_destroy */
[build]    obs_properties_t *obs_get_source_properties(const char *id);
[build]   
[build]   /** Returns whether the source has custom properties or not */
[build]    bool obs_is_source_configurable(const char *id);
[build]   
[build]    bool obs_source_configurable(const obs_source_t *source);
[build]   
[build]   /**
[build]    * Returns the properties list for a specific existing source.  Free with
[build]    * obs_properties_destroy
[build]    */
[build]    obs_properties_t *obs_source_properties(const obs_source_t *source);
[build]   
[build]   /** Updates settings for this source */
[build]    void obs_source_update(obs_source_t *source, obs_data_t *settings);
[build]   
[build]   /** Renders a video source. */
[build]    void obs_source_video_render(obs_source_t *source);
[build]   
[build]   /** Gets the width of a source (if it has video) */
[build]    uint32_t obs_source_get_width(obs_source_t *source);
[build]   
[build]   /** Gets the height of a source (if it has video) */
[build]    uint32_t obs_source_get_height(obs_source_t *source);
[build]   
[build]   /**
[build]    * If the source is a filter, returns the parent source of the filter.  Only
[build]    * guaranteed to be valid inside of the video_render, filter_audio,
[build]    * filter_video, and filter_remove callbacks.
[build]    */
[build]    obs_source_t *obs_filter_get_parent(const obs_source_t *filter);
[build]   
[build]   /**
[build]    * If the source is a filter, returns the target source of the filter.  Only
[build]    * guaranteed to be valid inside of the video_render, filter_audio,
[build]    * filter_video, and filter_remove callbacks.
[build]    */
[build]    obs_source_t *obs_filter_get_target(const obs_source_t *filter);
[build]   
[build]   /** Used to directly render a non-async source without any filter processing */
[build]    void obs_source_default_render(obs_source_t *source);
[build]   
[build]   /** Adds a filter to the source (which is used whenever the source is used) */
[build]    void obs_source_filter_add(obs_source_t *source, obs_source_t *filter);
[build]   
[build]   /** Removes a filter from the source */
[build]    void obs_source_filter_remove(obs_source_t *source,
[build]   				     obs_source_t *filter);
[build]   
[build]   /** Modifies the order of a specific filter */
[build]    void obs_source_filter_set_order(obs_source_t *source,
[build]   					obs_source_t *filter,
[build]   					enum obs_order_movement movement);
[build]   
[build]   /** Gets the settings string for a source */
[build]    obs_data_t *obs_source_get_settings(const obs_source_t *source);
[build]   
[build]   /** Gets the name of a source */
[build]    const char *obs_source_get_name(const obs_source_t *source);
[build]   
[build]   /** Sets the name of a source */
[build]    void obs_source_set_name(obs_source_t *source, const char *name);
[build]   
[build]   /** Gets the source type */
[build]    enum obs_source_type obs_source_get_type(const obs_source_t *source);
[build]   
[build]   /** Gets the source identifier */
[build]    const char *obs_source_get_id(const obs_source_t *source);
[build]    const char *obs_source_get_unversioned_id(const obs_source_t *source);
[build]   
[build]   /** Returns the signal handler for a source */
[build]    signal_handler_t *
[build]   obs_source_get_signal_handler(const obs_source_t *source);
[build]   
[build]   /** Returns the procedure handler for a source */
[build]    proc_handler_t *obs_source_get_proc_handler(const obs_source_t *source);
[build]   
[build]   /** Sets the user volume for a source that has audio output */
[build]    void obs_source_set_volume(obs_source_t *source, float volume);
[build]   
[build]   /** Gets the user volume for a source that has audio output */
[build]    float obs_source_get_volume(const obs_source_t *source);
[build]   
[build]   /* Gets speaker layout of a source */
[build]    enum speaker_layout obs_source_get_speaker_layout(obs_source_t *source);
[build]   
[build]   /** Sets the balance value for a stereo audio source */
[build]    void obs_source_set_balance_value(obs_source_t *source, float balance);
[build]   
[build]   /** Gets the balance value for a stereo audio source */
[build]    float obs_source_get_balance_value(const obs_source_t *source);
[build]   
[build]   /** Sets the audio sync offset (in nanoseconds) for a source */
[build]    void obs_source_set_sync_offset(obs_source_t *source, int64_t offset);
[build]   
[build]   /** Gets the audio sync offset (in nanoseconds) for a source */
[build]    int64_t obs_source_get_sync_offset(const obs_source_t *source);
[build]   
[build]   /** Enumerates active child sources used by this source */
[build]    void obs_source_enum_active_sources(obs_source_t *source,
[build]   					   obs_source_enum_proc_t enum_callback,
[build]   					   void *param);
[build]   
[build]   /** Enumerates the entire active child source tree used by this source */
[build]    void obs_source_enum_active_tree(obs_source_t *source,
[build]   					obs_source_enum_proc_t enum_callback,
[build]   					void *param);
[build]   
[build]   /** Returns true if active, false if not */
[build]    bool obs_source_active(const obs_source_t *source);
[build]   
[build]   /**
[build]    * Returns true if currently displayed somewhere (active or not), false if not
[build]    */
[build]    bool obs_source_showing(const obs_source_t *source);
[build]   
[build]   /** Unused flag */
[build]   %constant OBS_SOURCE_FLAG_UNUSED_1 = (1 << 0);
[build]   /** Specifies to force audio to mono */
[build]   %constant OBS_SOURCE_FLAG_FORCE_MONO = (1 << 1);
[build]   
[build]   /**
[build]    * Sets source flags.  Note that these are different from the main output
[build]    * flags.  These are generally things that can be set by the source or user,
[build]    * while the output flags are more used to determine capabilities of a source.
[build]    */
[build]    void obs_source_set_flags(obs_source_t *source, uint32_t flags);
[build]   
[build]   /** Gets source flags. */
[build]    uint32_t obs_source_get_flags(const obs_source_t *source);
[build]   
[build]   /**
[build]    * Sets audio mixer flags.  These flags are used to specify which mixers
[build]    * the source's audio should be applied to.
[build]    */
[build]    void obs_source_set_audio_mixers(obs_source_t *source, uint32_t mixers);
[build]   
[build]   /** Gets audio mixer flags */
[build]    uint32_t obs_source_get_audio_mixers(const obs_source_t *source);
[build]   
[build]   /**
[build]    * Increments the 'showing' reference counter to indicate that the source is
[build]    * being shown somewhere.  If the reference counter was 0, will call the 'show'
[build]    * callback.
[build]    */
[build]    void obs_source_inc_showing(obs_source_t *source);
[build]   
[build]   /**
[build]    * Increments the 'active' reference counter to indicate that the source is
[build]    * fully active.  If the reference counter was 0, will call the 'activate'
[build]    * callback.
[build]    *
[build]    * Unlike obs_source_inc_showing, this will cause children of this source to be
[build]    * considered showing as well (currently used by transition previews to make
[build]    * the stinger transition show correctly).  obs_source_inc_showing should
[build]    * generally be used instead.
[build]    */
[build]    void obs_source_inc_active(obs_source_t *source);
[build]   
[build]   /**
[build]    * Decrements the 'showing' reference counter to indicate that the source is
[build]    * no longer being shown somewhere.  If the reference counter is set to 0,
[build]    * will call the 'hide' callback
[build]    */
[build]    void obs_source_dec_showing(obs_source_t *source);
[build]   
[build]   /**
[build]    * Decrements the 'active' reference counter to indicate that the source is no
[build]    * longer fully active.  If the reference counter is set to 0, will call the
[build]    * 'deactivate' callback
[build]    *
[build]    * Unlike obs_source_dec_showing, this will cause children of this source to be
[build]    * considered not showing as well.  obs_source_dec_showing should generally be
[build]    * used instead.
[build]    */
[build]    void obs_source_dec_active(obs_source_t *source);
[build]   
[build]   /** Enumerates filters assigned to the source */
[build]    void obs_source_enum_filters(obs_source_t *source,
[build]   				    obs_source_enum_proc_t callback,
[build]   				    void *param);
[build]   
[build]   /** Gets a filter of a source by its display name. */
[build]    obs_source_t *obs_source_get_filter_by_name(obs_source_t *source,
[build]   						   const char *name);
[build]   
[build]    void obs_source_copy_filters(obs_source_t *dst, obs_source_t *src);
[build]    void obs_source_copy_single_filter(obs_source_t *dst,
[build]   					  obs_source_t *filter);
[build]   
[build]    bool obs_source_enabled(const obs_source_t *source);
[build]    void obs_source_set_enabled(obs_source_t *source, bool enabled);
[build]   
[build]    bool obs_source_muted(const obs_source_t *source);
[build]    void obs_source_set_muted(obs_source_t *source, bool muted);
[build]   
[build]    bool obs_source_push_to_mute_enabled(obs_source_t *source);
[build]    void obs_source_enable_push_to_mute(obs_source_t *source, bool enabled);
[build]   
[build]    uint64_t obs_source_get_push_to_mute_delay(obs_source_t *source);
[build]    void obs_source_set_push_to_mute_delay(obs_source_t *source,
[build]   					      uint64_t delay);
[build]   
[build]    bool obs_source_push_to_talk_enabled(obs_source_t *source);
[build]    void obs_source_enable_push_to_talk(obs_source_t *source, bool enabled);
[build]   
[build]    uint64_t obs_source_get_push_to_talk_delay(obs_source_t *source);
[build]    void obs_source_set_push_to_talk_delay(obs_source_t *source,
[build]   					      uint64_t delay);
[build]   
[build]   typedef void (*obs_source_audio_capture_t)(void *param, obs_source_t *source,
[build]   					   const struct audio_data *audio_data,
[build]   					   bool muted);
[build]   
[build]    void obs_source_add_audio_capture_callback(
[build]   	obs_source_t *source, obs_source_audio_capture_t callback, void *param);
[build]    void obs_source_remove_audio_capture_callback(
[build]   	obs_source_t *source, obs_source_audio_capture_t callback, void *param);
[build]   
[build]   typedef void (*obs_source_caption_t)(void *param, obs_source_t *source,
[build]   				     const struct obs_source_cea_708 *captions);
[build]   
[build]    void obs_source_add_caption_callback(obs_source_t *source,
[build]   					    obs_source_caption_t callback,
[build]   					    void *param);
[build]    void obs_source_remove_caption_callback(obs_source_t *source,
[build]   					       obs_source_caption_t callback,
[build]   					       void *param);
[build]   
[build]   enum obs_deinterlace_mode {
[build]   	OBS_DEINTERLACE_MODE_DISABLE,
[build]   	OBS_DEINTERLACE_MODE_DISCARD,
[build]   	OBS_DEINTERLACE_MODE_RETRO,
[build]   	OBS_DEINTERLACE_MODE_BLEND,
[build]   	OBS_DEINTERLACE_MODE_BLEND_2X,
[build]   	OBS_DEINTERLACE_MODE_LINEAR,
[build]   	OBS_DEINTERLACE_MODE_LINEAR_2X,
[build]   	OBS_DEINTERLACE_MODE_YADIF,
[build]   	OBS_DEINTERLACE_MODE_YADIF_2X,
[build]   };
[build]   
[build]   enum obs_deinterlace_field_order {
[build]   	OBS_DEINTERLACE_FIELD_ORDER_TOP,
[build]   	OBS_DEINTERLACE_FIELD_ORDER_BOTTOM,
[build]   };
[build]   
[build]    void obs_source_set_deinterlace_mode(obs_source_t *source,
[build]   					    enum obs_deinterlace_mode mode);
[build]    enum obs_deinterlace_mode
[build]   obs_source_get_deinterlace_mode(const obs_source_t *source);
[build]    void obs_source_set_deinterlace_field_order(
[build]   	obs_source_t *source, enum obs_deinterlace_field_order field_order);
[build]    enum obs_deinterlace_field_order
[build]   obs_source_get_deinterlace_field_order(const obs_source_t *source);
[build]   
[build]   enum obs_monitoring_type {
[build]   	OBS_MONITORING_TYPE_NONE,
[build]   	OBS_MONITORING_TYPE_MONITOR_ONLY,
[build]   	OBS_MONITORING_TYPE_MONITOR_AND_OUTPUT,
[build]   };
[build]   
[build]    void obs_source_set_monitoring_type(obs_source_t *source,
[build]   					   enum obs_monitoring_type type);
[build]    enum obs_monitoring_type
[build]   obs_source_get_monitoring_type(const obs_source_t *source);
[build]   
[build]   /** Gets private front-end settings data.  This data is saved/loaded
[build]    * automatically.  Returns an incremented reference. */
[build]    obs_data_t *obs_source_get_private_settings(obs_source_t *item);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Functions used by sources */
[build]   
[build]    void *obs_source_get_type_data(obs_source_t *source);
[build]   
[build]   /**
[build]    * Helper function to set the color matrix information when drawing the source.
[build]    *
[build]    * @param  color_matrix     The color matrix.  Assigns to the 'color_matrix'
[build]    *                          effect variable.
[build]    * @param  color_range_min  The minimum color range.  Assigns to the
[build]    *                          'color_range_min' effect variable.  If NULL,
[build]    *                          {0.0f, 0.0f, 0.0f} is used.
[build]    * @param  color_range_max  The maximum color range.  Assigns to the
[build]    *                          'color_range_max' effect variable.  If NULL,
[build]    *                          {1.0f, 1.0f, 1.0f} is used.
[build]    */
[build]    void
[build]   obs_source_draw_set_color_matrix(const struct matrix4 *color_matrix,
[build]   				 const struct vec3 *color_range_min,
[build]   				 const struct vec3 *color_range_max);
[build]   
[build]   /**
[build]    * Helper function to draw sprites for a source (synchronous video).
[build]    *
[build]    * @param  image   The sprite texture to draw.  Assigns to the 'image' variable
[build]    *                 of the current effect.
[build]    * @param  x       X position of the sprite.
[build]    * @param  y       Y position of the sprite.
[build]    * @param  cx      Width of the sprite.  If 0, uses the texture width.
[build]    * @param  cy      Height of the sprite.  If 0, uses the texture height.
[build]    * @param  flip    Specifies whether to flip the image vertically.
[build]    */
[build]    void obs_source_draw(gs_texture_t *image, int x, int y, uint32_t cx,
[build]   			    uint32_t cy, bool flip);
[build]   
[build]   /**
[build]    * Outputs asynchronous video data.  Set to NULL to deactivate the texture
[build]    *
[build]    * NOTE: Non-YUV formats will always be treated as full range with this
[build]    * function!  Use obs_source_output_video2 instead if partial range support is
[build]    * desired for non-YUV video formats.
[build]    */
[build]    void obs_source_output_video(obs_source_t *source,
[build]   				    const struct obs_source_frame *frame);
[build]    void obs_source_output_video2(obs_source_t *source,
[build]   				     const struct obs_source_frame2 *frame);
[build]   
[build]    void obs_source_set_async_rotation(obs_source_t *source, long rotation);
[build]   
[build]    void obs_source_output_cea708(obs_source_t *source,
[build]   				     const struct obs_source_cea_708 *captions);
[build]   
[build]   /**
[build]    * Preloads asynchronous video data to allow instantaneous playback
[build]    *
[build]    * NOTE: Non-YUV formats will always be treated as full range with this
[build]    * function!  Use obs_source_preload_video2 instead if partial range support is
[build]    * desired for non-YUV video formats.
[build]    */
[build]    void obs_source_preload_video(obs_source_t *source,
[build]   				     const struct obs_source_frame *frame);
[build]    void obs_source_preload_video2(obs_source_t *source,
[build]   				      const struct obs_source_frame2 *frame);
[build]   
[build]   /** Shows any preloaded video data */
[build]    void obs_source_show_preloaded_video(obs_source_t *source);
[build]   
[build]   /**
[build]    * Sets current async video frame immediately
[build]    *
[build]    * NOTE: Non-YUV formats will always be treated as full range with this
[build]    * function!  Use obs_source_preload_video2 instead if partial range support is
[build]    * desired for non-YUV video formats.
[build]    */
[build]    void obs_source_set_video_frame(obs_source_t *source,
[build]   				       const struct obs_source_frame *frame);
[build]    void obs_source_set_video_frame2(obs_source_t *source,
[build]   					const struct obs_source_frame2 *frame);
[build]   
[build]   /** Outputs audio data (always asynchronous) */
[build]    void obs_source_output_audio(obs_source_t *source,
[build]   				    const struct obs_source_audio *audio);
[build]   
[build]   /** Signal an update to any currently used properties via 'update_properties' */
[build]    void obs_source_update_properties(obs_source_t *source);
[build]   
[build]   /** Gets the current async video frame */
[build]    struct obs_source_frame *obs_source_get_frame(obs_source_t *source);
[build]   
[build]   /** Releases the current async video frame */
[build]    void obs_source_release_frame(obs_source_t *source,
[build]   				     struct obs_source_frame *frame);
[build]   
[build]   /**
[build]    * Default RGB filter handler for generic effect filters.  Processes the
[build]    * filter chain and renders them to texture if needed, then the filter is
[build]    * drawn with
[build]    *
[build]    * After calling this, set your parameters for the effect, then call
[build]    * obs_source_process_filter_end to draw the filter.
[build]    *
[build]    * Returns true if filtering should continue, false if the filter is bypassed
[build]    * for whatever reason.
[build]    */
[build]    bool
[build]   obs_source_process_filter_begin(obs_source_t *filter,
[build]   				enum gs_color_format format,
[build]   				enum obs_allow_direct_render allow_direct);
[build]   
[build]   /**
[build]    * Draws the filter.
[build]    *
[build]    * Before calling this function, first call obs_source_process_filter_begin and
[build]    * then set the effect parameters, and then call this function to finalize the
[build]    * filter.
[build]    */
[build]    void obs_source_process_filter_end(obs_source_t *filter,
[build]   					  gs_effect_t *effect, uint32_t width,
[build]   					  uint32_t height);
[build]   
[build]   /**
[build]    * Draws the filter with a specific technique.
[build]    *
[build]    * Before calling this function, first call obs_source_process_filter_begin and
[build]    * then set the effect parameters, and then call this function to finalize the
[build]    * filter.
[build]    */
[build]    void obs_source_process_filter_tech_end(obs_source_t *filter,
[build]   					       gs_effect_t *effect,
[build]   					       uint32_t width, uint32_t height,
[build]   					       const char *tech_name);
[build]   
[build]   /** Skips the filter if the filter is invalid and cannot be rendered */
[build]    void obs_source_skip_video_filter(obs_source_t *filter);
[build]   
[build]   /**
[build]    * Adds an active child source.  Must be called by parent sources on child
[build]    * sources when the child is added and active.  This ensures that the source is
[build]    * properly activated if the parent is active.
[build]    *
[build]    * @returns true if source can be added, false if it causes recursion
[build]    */
[build]    bool obs_source_add_active_child(obs_source_t *parent,
[build]   					obs_source_t *child);
[build]   
[build]   /**
[build]    * Removes an active child source.  Must be called by parent sources on child
[build]    * sources when the child is removed or inactive.  This ensures that the source
[build]    * is properly deactivated if the parent is no longer active.
[build]    */
[build]    void obs_source_remove_active_child(obs_source_t *parent,
[build]   					   obs_source_t *child);
[build]   
[build]   /** Sends a mouse down/up event to a source */
[build]    void obs_source_send_mouse_click(obs_source_t *source,
[build]   					const struct obs_mouse_event *event,
[build]   					int32_t type, bool mouse_up,
[build]   					uint32_t click_count);
[build]   
[build]   /** Sends a mouse move event to a source. */
[build]    void obs_source_send_mouse_move(obs_source_t *source,
[build]   				       const struct obs_mouse_event *event,
[build]   				       bool mouse_leave);
[build]   
[build]   /** Sends a mouse wheel event to a source */
[build]    void obs_source_send_mouse_wheel(obs_source_t *source,
[build]   					const struct obs_mouse_event *event,
[build]   					int x_delta, int y_delta);
[build]   
[build]   /** Sends a got-focus or lost-focus event to a source */
[build]    void obs_source_send_focus(obs_source_t *source, bool focus);
[build]   
[build]   /** Sends a key up/down event to a source */
[build]    void obs_source_send_key_click(obs_source_t *source,
[build]   				      const struct obs_key_event *event,
[build]   				      bool key_up);
[build]   
[build]   /** Sets the default source flags. */
[build]    void obs_source_set_default_flags(obs_source_t *source, uint32_t flags);
[build]   
[build]   /** Gets the base width for a source (not taking in to account filtering) */
[build]    uint32_t obs_source_get_base_width(obs_source_t *source);
[build]   
[build]   /** Gets the base height for a source (not taking in to account filtering) */
[build]    uint32_t obs_source_get_base_height(obs_source_t *source);
[build]   
[build]    bool obs_source_audio_pending(const obs_source_t *source);
[build]    uint64_t obs_source_get_audio_timestamp(const obs_source_t *source);
[build]    void obs_source_get_audio_mix(const obs_source_t *source,
[build]   				     struct obs_source_audio_mix *audio);
[build]   
[build]    void obs_source_set_async_unbuffered(obs_source_t *source,
[build]   					    bool unbuffered);
[build]    bool obs_source_async_unbuffered(const obs_source_t *source);
[build]   
[build]   /** Used to decouple audio from video so that audio doesn't attempt to sync up
[build]    * with video.  I.E. Audio acts independently.  Only works when in unbuffered
[build]    * mode. */
[build]    void obs_source_set_async_decoupled(obs_source_t *source, bool decouple);
[build]    bool obs_source_async_decoupled(const obs_source_t *source);
[build]   
[build]    void obs_source_set_audio_active(obs_source_t *source, bool show);
[build]    bool obs_source_audio_active(const obs_source_t *source);
[build]   
[build]    uint32_t obs_source_get_last_obs_version(const obs_source_t *source);
[build]   
[build]   /** Media controls */
[build]    void obs_source_media_play_pause(obs_source_t *source, bool pause);
[build]    void obs_source_media_restart(obs_source_t *source);
[build]    void obs_source_media_stop(obs_source_t *source);
[build]    void obs_source_media_next(obs_source_t *source);
[build]    void obs_source_media_previous(obs_source_t *source);
[build]    int64_t obs_source_media_get_duration(obs_source_t *source);
[build]    int64_t obs_source_media_get_time(obs_source_t *source);
[build]    void obs_source_media_set_time(obs_source_t *source, int64_t ms);
[build]    enum obs_media_state obs_source_media_get_state(obs_source_t *source);
[build]    void obs_source_media_started(obs_source_t *source);
[build]    void obs_source_media_ended(obs_source_t *source);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Transition-specific functions */
[build]   enum obs_transition_target {
[build]   	OBS_TRANSITION_SOURCE_A,
[build]   	OBS_TRANSITION_SOURCE_B,
[build]   };
[build]   
[build]    obs_source_t *
[build]   obs_transition_get_source(obs_source_t *transition,
[build]   			  enum obs_transition_target target);
[build]    void obs_transition_clear(obs_source_t *transition);
[build]   
[build]    obs_source_t *obs_transition_get_active_source(obs_source_t *transition);
[build]   
[build]   enum obs_transition_mode {
[build]   	OBS_TRANSITION_MODE_AUTO,
[build]   	OBS_TRANSITION_MODE_MANUAL,
[build]   };
[build]   
[build]    bool obs_transition_start(obs_source_t *transition,
[build]   				 enum obs_transition_mode mode,
[build]   				 uint32_t duration_ms, obs_source_t *dest);
[build]   
[build]    void obs_transition_set(obs_source_t *transition, obs_source_t *source);
[build]   
[build]    void obs_transition_set_manual_time(obs_source_t *transition, float t);
[build]    void obs_transition_set_manual_torque(obs_source_t *transition,
[build]   					     float torque, float clamp);
[build]   
[build]   enum obs_transition_scale_type {
[build]   	OBS_TRANSITION_SCALE_MAX_ONLY,
[build]   	OBS_TRANSITION_SCALE_ASPECT,
[build]   	OBS_TRANSITION_SCALE_STRETCH,
[build]   };
[build]   
[build]    void obs_transition_set_scale_type(obs_source_t *transition,
[build]   					  enum obs_transition_scale_type type);
[build]    enum obs_transition_scale_type
[build]   obs_transition_get_scale_type(const obs_source_t *transition);
[build]   
[build]    void obs_transition_set_alignment(obs_source_t *transition,
[build]   					 uint32_t alignment);
[build]    uint32_t obs_transition_get_alignment(const obs_source_t *transition);
[build]   
[build]    void obs_transition_set_size(obs_source_t *transition, uint32_t cx,
[build]   				    uint32_t cy);
[build]    void obs_transition_get_size(const obs_source_t *transition,
[build]   				    uint32_t *cx, uint32_t *cy);
[build]   
[build]   /* function used by transitions */
[build]   
[build]   /**
[build]    * Enables fixed transitions (videos or specific types of transitions that
[build]    * are of fixed duration and linearly interpolated
[build]    */
[build]    void obs_transition_enable_fixed(obs_source_t *transition, bool enable,
[build]   					uint32_t duration_ms);
[build]    bool obs_transition_fixed(obs_source_t *transition);
[build]   
[build]   typedef void (*obs_transition_video_render_callback_t)(void *data,
[build]   						       gs_texture_t *a,
[build]   						       gs_texture_t *b, float t,
[build]   						       uint32_t cx,
[build]   						       uint32_t cy);
[build]   typedef float (*obs_transition_audio_mix_callback_t)(void *data, float t);
[build]   
[build]    float obs_transition_get_time(obs_source_t *transition);
[build]   
[build]    void obs_transition_force_stop(obs_source_t *transition);
[build]   
[build]    void
[build]   obs_transition_video_render(obs_source_t *transition,
[build]   			    obs_transition_video_render_callback_t callback);
[build]   
[build]   /** Directly renders its sub-source instead of to texture.  Returns false if no
[build]    * longer transitioning */
[build]    bool
[build]   obs_transition_video_render_direct(obs_source_t *transition,
[build]   				   enum obs_transition_target target);
[build]   
[build]    bool
[build]   obs_transition_audio_render(obs_source_t *transition, uint64_t *ts_out,
[build]   			    struct obs_source_audio_mix *audio, uint32_t mixers,
[build]   			    size_t channels, size_t sample_rate,
[build]   			    obs_transition_audio_mix_callback_t mix_a_callback,
[build]   			    obs_transition_audio_mix_callback_t mix_b_callback);
[build]   
[build]   /* swaps transition sources and textures as an optimization and to reduce
[build]    * memory usage when switching between transitions */
[build]    void obs_transition_swap_begin(obs_source_t *tr_dest,
[build]   				      obs_source_t *tr_source);
[build]    void obs_transition_swap_end(obs_source_t *tr_dest,
[build]   				    obs_source_t *tr_source);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Scenes */
[build]   
[build]   /**
[build]    * Creates a scene.
[build]    *
[build]    *   A scene is a source which is a container of other sources with specific
[build]    * display orientations.  Scenes can also be used like any other source.
[build]    */
[build]    obs_scene_t *obs_scene_create(const char *name);
[build]   
[build]    obs_scene_t *obs_scene_create_private(const char *name);
[build]   
[build]   enum obs_scene_duplicate_type {
[build]   	OBS_SCENE_DUP_REFS,         /**< Source refs only */
[build]   	OBS_SCENE_DUP_COPY,         /**< Fully duplicate */
[build]   	OBS_SCENE_DUP_PRIVATE_REFS, /**< Source refs only (as private) */
[build]   	OBS_SCENE_DUP_PRIVATE_COPY, /**< Fully duplicate (as private) */
[build]   };
[build]   
[build]   /**
[build]    * Duplicates a scene.
[build]    */
[build]    obs_scene_t *obs_scene_duplicate(obs_scene_t *scene, const char *name,
[build]   					enum obs_scene_duplicate_type type);
[build]   
[build]    void obs_scene_addref(obs_scene_t *scene);
[build]    void obs_scene_release(obs_scene_t *scene);
[build]   
[build]   /** Gets the scene's source context */
[build]    obs_source_t *obs_scene_get_source(const obs_scene_t *scene);
[build]   
[build]   /** Gets the scene from its source, or NULL if not a scene */
[build]    obs_scene_t *obs_scene_from_source(const obs_source_t *source);
[build]   
[build]   /** Determines whether a source is within a scene */
[build]    obs_sceneitem_t *obs_scene_find_source(obs_scene_t *scene,
[build]   					      const char *name);
[build]   
[build]    obs_sceneitem_t *obs_scene_find_source_recursive(obs_scene_t *scene,
[build]   							const char *name);
[build]   
[build]    obs_sceneitem_t *obs_scene_find_sceneitem_by_id(obs_scene_t *scene,
[build]   						       int64_t id);
[build]   
[build]   /** Enumerates sources within a scene */
[build]    void obs_scene_enum_items(obs_scene_t *scene,
[build]   				 bool (*callback)(obs_scene_t *,
[build]   						  obs_sceneitem_t *, void *),
[build]   				 void *param);
[build]   
[build]    bool obs_scene_reorder_items(obs_scene_t *scene,
[build]   				    obs_sceneitem_t *const *item_order,
[build]   				    size_t item_order_size);
[build]   
[build]   struct obs_sceneitem_order_info {
[build]   	obs_sceneitem_t *group;
[build]   	obs_sceneitem_t *item;
[build]   };
[build]   
[build]    bool
[build]   obs_scene_reorder_items2(obs_scene_t *scene,
[build]   			 struct obs_sceneitem_order_info *item_order,
[build]   			 size_t item_order_size);
[build]   
[build]   /** Adds/creates a new scene item for a source */
[build]    obs_sceneitem_t *obs_scene_add(obs_scene_t *scene, obs_source_t *source);
[build]   
[build]   typedef void (*obs_scene_atomic_update_func)(void *, obs_scene_t *scene);
[build]    void obs_scene_atomic_update(obs_scene_t *scene,
[build]   				    obs_scene_atomic_update_func func,
[build]   				    void *data);
[build]   
[build]    void obs_sceneitem_addref(obs_sceneitem_t *item);
[build]    void obs_sceneitem_release(obs_sceneitem_t *item);
[build]   
[build]   /** Removes a scene item. */
[build]    void obs_sceneitem_remove(obs_sceneitem_t *item);
[build]   
[build]   /** Gets the scene parent associated with the scene item. */
[build]    obs_scene_t *obs_sceneitem_get_scene(const obs_sceneitem_t *item);
[build]   
[build]   /** Gets the source of a scene item. */
[build]    obs_source_t *obs_sceneitem_get_source(const obs_sceneitem_t *item);
[build]   
[build]   /* FIXME: The following functions should be deprecated and replaced with a way
[build]    * to specify saveable private user data. -Jim */
[build]    void obs_sceneitem_select(obs_sceneitem_t *item, bool select);
[build]    bool obs_sceneitem_selected(const obs_sceneitem_t *item);
[build]    bool obs_sceneitem_locked(const obs_sceneitem_t *item);
[build]    bool obs_sceneitem_set_locked(obs_sceneitem_t *item, bool lock);
[build]   
[build]   /* Functions for getting/setting specific orientation of a scene item */
[build]    void obs_sceneitem_set_pos(obs_sceneitem_t *item,
[build]   				  const struct vec2 *pos);
[build]    void obs_sceneitem_set_rot(obs_sceneitem_t *item, float rot_deg);
[build]    void obs_sceneitem_set_scale(obs_sceneitem_t *item,
[build]   				    const struct vec2 *scale);
[build]    void obs_sceneitem_set_alignment(obs_sceneitem_t *item,
[build]   					uint32_t alignment);
[build]    void obs_sceneitem_set_order(obs_sceneitem_t *item,
[build]   				    enum obs_order_movement movement);
[build]    void obs_sceneitem_set_order_position(obs_sceneitem_t *item,
[build]   					     int position);
[build]    void obs_sceneitem_set_bounds_type(obs_sceneitem_t *item,
[build]   					  enum obs_bounds_type type);
[build]    void obs_sceneitem_set_bounds_alignment(obs_sceneitem_t *item,
[build]   					       uint32_t alignment);
[build]    void obs_sceneitem_set_bounds(obs_sceneitem_t *item,
[build]   				     const struct vec2 *bounds);
[build]   
[build]    int64_t obs_sceneitem_get_id(const obs_sceneitem_t *item);
[build]   
[build]    void obs_sceneitem_get_pos(const obs_sceneitem_t *item,
[build]   				  struct vec2 *pos);
[build]    float obs_sceneitem_get_rot(const obs_sceneitem_t *item);
[build]    void obs_sceneitem_get_scale(const obs_sceneitem_t *item,
[build]   				    struct vec2 *scale);
[build]    uint32_t obs_sceneitem_get_alignment(const obs_sceneitem_t *item);
[build]   
[build]    enum obs_bounds_type
[build]   obs_sceneitem_get_bounds_type(const obs_sceneitem_t *item);
[build]    uint32_t obs_sceneitem_get_bounds_alignment(const obs_sceneitem_t *item);
[build]    void obs_sceneitem_get_bounds(const obs_sceneitem_t *item,
[build]   				     struct vec2 *bounds);
[build]   
[build]    void obs_sceneitem_get_info(const obs_sceneitem_t *item,
[build]   				   struct obs_transform_info *info);
[build]    void obs_sceneitem_set_info(obs_sceneitem_t *item,
[build]   				   const struct obs_transform_info *info);
[build]   
[build]    void obs_sceneitem_get_draw_transform(const obs_sceneitem_t *item,
[build]   					     struct matrix4 *transform);
[build]    void obs_sceneitem_get_box_transform(const obs_sceneitem_t *item,
[build]   					    struct matrix4 *transform);
[build]    void obs_sceneitem_get_box_scale(const obs_sceneitem_t *item,
[build]   					struct vec2 *scale);
[build]   
[build]    bool obs_sceneitem_visible(const obs_sceneitem_t *item);
[build]    bool obs_sceneitem_set_visible(obs_sceneitem_t *item, bool visible);
[build]   
[build]   struct obs_sceneitem_crop {
[build]   	int left;
[build]   	int top;
[build]   	int right;
[build]   	int bottom;
[build]   };
[build]   
[build]    void obs_sceneitem_set_crop(obs_sceneitem_t *item,
[build]   				   const struct obs_sceneitem_crop *crop);
[build]    void obs_sceneitem_get_crop(const obs_sceneitem_t *item,
[build]   				   struct obs_sceneitem_crop *crop);
[build]   
[build]    void obs_sceneitem_set_scale_filter(obs_sceneitem_t *item,
[build]   					   enum obs_scale_type filter);
[build]    enum obs_scale_type
[build]   obs_sceneitem_get_scale_filter(obs_sceneitem_t *item);
[build]   
[build]    void obs_sceneitem_force_update_transform(obs_sceneitem_t *item);
[build]   
[build]    void obs_sceneitem_defer_update_begin(obs_sceneitem_t *item);
[build]    void obs_sceneitem_defer_update_end(obs_sceneitem_t *item);
[build]   
[build]   /** Gets private front-end settings data.  This data is saved/loaded
[build]    * automatically.  Returns an incremented reference. */
[build]    obs_data_t *obs_sceneitem_get_private_settings(obs_sceneitem_t *item);
[build]   
[build]    obs_sceneitem_t *obs_scene_add_group(obs_scene_t *scene,
[build]   					    const char *name);
[build]    obs_sceneitem_t *obs_scene_insert_group(obs_scene_t *scene,
[build]   					       const char *name,
[build]   					       obs_sceneitem_t **items,
[build]   					       size_t count);
[build]   
[build]    obs_sceneitem_t *obs_scene_add_group2(obs_scene_t *scene,
[build]   					     const char *name, bool signal);
[build]    obs_sceneitem_t *obs_scene_insert_group2(obs_scene_t *scene,
[build]   						const char *name,
[build]   						obs_sceneitem_t **items,
[build]   						size_t count, bool signal);
[build]   
[build]    obs_sceneitem_t *obs_scene_get_group(obs_scene_t *scene,
[build]   					    const char *name);
[build]   
[build]    bool obs_sceneitem_is_group(obs_sceneitem_t *item);
[build]   
[build]    obs_scene_t *obs_sceneitem_group_get_scene(const obs_sceneitem_t *group);
[build]   
[build]    void obs_sceneitem_group_ungroup(obs_sceneitem_t *group);
[build]    void obs_sceneitem_group_ungroup2(obs_sceneitem_t *group, bool signal);
[build]   
[build]    void obs_sceneitem_group_add_item(obs_sceneitem_t *group,
[build]   					 obs_sceneitem_t *item);
[build]    void obs_sceneitem_group_remove_item(obs_sceneitem_t *group,
[build]   					    obs_sceneitem_t *item);
[build]   
[build]    obs_sceneitem_t *obs_sceneitem_get_group(obs_scene_t *scene,
[build]   						obs_sceneitem_t *item);
[build]   
[build]    bool obs_source_is_group(const obs_source_t *source);
[build]    bool obs_scene_is_group(const obs_scene_t *scene);
[build]   
[build]    void obs_sceneitem_group_enum_items(obs_sceneitem_t *group,
[build]   					   bool (*callback)(obs_scene_t *,
[build]   							    obs_sceneitem_t *,
[build]   							    void *),
[build]   					   void *param);
[build]   
[build]   /** Gets the group from its source, or NULL if not a group */
[build]    obs_scene_t *obs_group_from_source(const obs_source_t *source);
[build]   
[build]    void obs_sceneitem_defer_group_resize_begin(obs_sceneitem_t *item);
[build]    void obs_sceneitem_defer_group_resize_end(obs_sceneitem_t *item);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Outputs */
[build]   
[build]    const char *obs_output_get_display_name(const char *id);
[build]   
[build]   /**
[build]    * Creates an output.
[build]    *
[build]    *   Outputs allow outputting to file, outputting to network, outputting to
[build]    * directshow, or other custom outputs.
[build]    */
[build]    obs_output_t *obs_output_create(const char *id, const char *name,
[build]   				       obs_data_t *settings,
[build]   				       obs_data_t *hotkey_data);
[build]   
[build]   /**
[build]    * Adds/releases a reference to an output.  When the last reference is
[build]    * released, the output is destroyed.
[build]    */
[build]    void obs_output_addref(obs_output_t *output);
[build]    void obs_output_release(obs_output_t *output);
[build]   
[build]    void obs_weak_output_addref(obs_weak_output_t *weak);
[build]    void obs_weak_output_release(obs_weak_output_t *weak);
[build]   
[build]    obs_output_t *obs_output_get_ref(obs_output_t *output);
[build]    obs_weak_output_t *obs_output_get_weak_output(obs_output_t *output);
[build]    obs_output_t *obs_weak_output_get_output(obs_weak_output_t *weak);
[build]   
[build]    bool obs_weak_output_references_output(obs_weak_output_t *weak,
[build]   					      obs_output_t *output);
[build]   
[build]    const char *obs_output_get_name(const obs_output_t *output);
[build]   
[build]   /** Starts the output. */
[build]    bool obs_output_start(obs_output_t *output);
[build]   
[build]   /** Stops the output. */
[build]    void obs_output_stop(obs_output_t *output);
[build]   
[build]   /**
[build]    * On reconnection, start where it left of on reconnection.  Note however that
[build]    * this option will consume extra memory to continually increase delay while
[build]    * waiting to reconnect.
[build]    */
[build]   %constant OBS_OUTPUT_DELAY_PRESERVE = (1 << 0);
[build]   
[build]   /**
[build]    * Sets the current output delay, in seconds (if the output supports delay).
[build]    *
[build]    * If delay is currently active, it will set the delay value, but will not
[build]    * affect the current delay, it will only affect the next time the output is
[build]    * activated.
[build]    */
[build]    void obs_output_set_delay(obs_output_t *output, uint32_t delay_sec,
[build]   				 uint32_t flags);
[build]   
[build]   /** Gets the currently set delay value, in seconds. */
[build]    uint32_t obs_output_get_delay(const obs_output_t *output);
[build]   
[build]   /** If delay is active, gets the currently active delay value, in seconds. */
[build]    uint32_t obs_output_get_active_delay(const obs_output_t *output);
[build]   
[build]   /** Forces the output to stop.  Usually only used with delay. */
[build]    void obs_output_force_stop(obs_output_t *output);
[build]   
[build]   /** Returns whether the output is active */
[build]    bool obs_output_active(const obs_output_t *output);
[build]   
[build]   /** Returns output capability flags */
[build]    uint32_t obs_output_get_flags(const obs_output_t *output);
[build]   
[build]   /** Returns output capability flags */
[build]    uint32_t obs_get_output_flags(const char *id);
[build]   
[build]   /** Gets the default settings for an output type */
[build]    obs_data_t *obs_output_defaults(const char *id);
[build]   
[build]   /** Returns the property list, if any.  Free with obs_properties_destroy */
[build]    obs_properties_t *obs_get_output_properties(const char *id);
[build]   
[build]   /**
[build]    * Returns the property list of an existing output, if any.  Free with
[build]    * obs_properties_destroy
[build]    */
[build]    obs_properties_t *obs_output_properties(const obs_output_t *output);
[build]   
[build]   /** Updates the settings for this output context */
[build]    void obs_output_update(obs_output_t *output, obs_data_t *settings);
[build]   
[build]   /** Specifies whether the output can be paused */
[build]    bool obs_output_can_pause(const obs_output_t *output);
[build]   
[build]   /** Pauses the output (if the functionality is allowed by the output */
[build]    bool obs_output_pause(obs_output_t *output, bool pause);
[build]   
[build]   /** Returns whether output is paused */
[build]    bool obs_output_paused(const obs_output_t *output);
[build]   
[build]   /* Gets the current output settings string */
[build]    obs_data_t *obs_output_get_settings(const obs_output_t *output);
[build]   
[build]   /** Returns the signal handler for an output  */
[build]    signal_handler_t *
[build]   obs_output_get_signal_handler(const obs_output_t *output);
[build]   
[build]   /** Returns the procedure handler for an output */
[build]    proc_handler_t *obs_output_get_proc_handler(const obs_output_t *output);
[build]   
[build]   /**
[build]    * Sets the current audio/video media contexts associated with this output,
[build]    * required for non-encoded outputs.  Can be null.
[build]    */
[build]    void obs_output_set_media(obs_output_t *output, video_t *video,
[build]   				 audio_t *audio);
[build]   
[build]   /** Returns the video media context associated with this output */
[build]    video_t *obs_output_video(const obs_output_t *output);
[build]   
[build]   /** Returns the audio media context associated with this output */
[build]    audio_t *obs_output_audio(const obs_output_t *output);
[build]   
[build]   /** Sets the current audio mixer for non-encoded outputs */
[build]    void obs_output_set_mixer(obs_output_t *output, size_t mixer_idx);
[build]   
[build]   /** Gets the current audio mixer for non-encoded outputs */
[build]    size_t obs_output_get_mixer(const obs_output_t *output);
[build]   
[build]   /** Sets the current audio mixes (mask) for a non-encoded multi-track output */
[build]    void obs_output_set_mixers(obs_output_t *output, size_t mixers);
[build]   
[build]   /** Gets the current audio mixes (mask) for a non-encoded multi-track output */
[build]    size_t obs_output_get_mixers(const obs_output_t *output);
[build]   
[build]   /**
[build]    * Sets the current video encoder associated with this output,
[build]    * required for encoded outputs
[build]    */
[build]    void obs_output_set_video_encoder(obs_output_t *output,
[build]   					 obs_encoder_t *encoder);
[build]   
[build]   /**
[build]    * Sets the current audio encoder associated with this output,
[build]    * required for encoded outputs.
[build]    *
[build]    * The idx parameter specifies the audio encoder index to set the encoder to.
[build]    * Only used with outputs that have multiple audio outputs (RTMP typically),
[build]    * otherwise the parameter is ignored.
[build]    */
[build]    void obs_output_set_audio_encoder(obs_output_t *output,
[build]   					 obs_encoder_t *encoder, size_t idx);
[build]   
[build]   /** Returns the current video encoder associated with this output */
[build]    obs_encoder_t *obs_output_get_video_encoder(const obs_output_t *output);
[build]   
[build]   /**
[build]    * Returns the current audio encoder associated with this output
[build]    *
[build]    * The idx parameter specifies the audio encoder index.  Only used with
[build]    * outputs that have multiple audio outputs, otherwise the parameter is
[build]    * ignored.
[build]    */
[build]    obs_encoder_t *obs_output_get_audio_encoder(const obs_output_t *output,
[build]   						   size_t idx);
[build]   
[build]   /** Sets the current service associated with this output. */
[build]    void obs_output_set_service(obs_output_t *output,
[build]   				   obs_service_t *service);
[build]   
[build]   /** Gets the current service associated with this output. */
[build]    obs_service_t *obs_output_get_service(const obs_output_t *output);
[build]   
[build]   /**
[build]    * Sets the reconnect settings.  Set retry_count to 0 to disable reconnecting.
[build]    */
[build]    void obs_output_set_reconnect_settings(obs_output_t *output,
[build]   					      int retry_count, int retry_sec);
[build]   
[build]    uint64_t obs_output_get_total_bytes(const obs_output_t *output);
[build]    int obs_output_get_frames_dropped(const obs_output_t *output);
[build]    int obs_output_get_total_frames(const obs_output_t *output);
[build]   
[build]   /**
[build]    * Sets the preferred scaled resolution for this output.  Set width and height
[build]    * to 0 to disable scaling.
[build]    *
[build]    * If this output uses an encoder, it will call obs_encoder_set_scaled_size on
[build]    * the encoder before the stream is started.  If the encoder is already active,
[build]    * then this function will trigger a warning and do nothing.
[build]    */
[build]    void obs_output_set_preferred_size(obs_output_t *output, uint32_t width,
[build]   					  uint32_t height);
[build]   
[build]   /** For video outputs, returns the width of the encoded image */
[build]    uint32_t obs_output_get_width(const obs_output_t *output);
[build]   
[build]   /** For video outputs, returns the height of the encoded image */
[build]    uint32_t obs_output_get_height(const obs_output_t *output);
[build]   
[build]    const char *obs_output_get_id(const obs_output_t *output);
[build]   
[build]    void obs_output_caption(obs_output_t *output,
[build]   			       const struct obs_source_cea_708 *captions);
[build]   
[build]    void obs_output_output_caption_text1(obs_output_t *output,
[build]   					    const char *text);
[build]    void obs_output_output_caption_text2(obs_output_t *output,
[build]   					    const char *text,
[build]   					    double display_duration);
[build]   
[build]    float obs_output_get_congestion(obs_output_t *output);
[build]    int obs_output_get_connect_time_ms(obs_output_t *output);
[build]   
[build]    bool obs_output_reconnecting(const obs_output_t *output);
[build]   
[build]   /** Pass a string of the last output error, for UI use */
[build]    void obs_output_set_last_error(obs_output_t *output,
[build]   				      const char *message);
[build]    const char *obs_output_get_last_error(obs_output_t *output);
[build]   
[build]    const char *
[build]   obs_output_get_supported_video_codecs(const obs_output_t *output);
[build]    const char *
[build]   obs_output_get_supported_audio_codecs(const obs_output_t *output);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Functions used by outputs */
[build]   
[build]    void *obs_output_get_type_data(obs_output_t *output);
[build]   
[build]   /** Optionally sets the video conversion info.  Used only for raw output */
[build]    void
[build]   obs_output_set_video_conversion(obs_output_t *output,
[build]   				const struct video_scale_info *conversion);
[build]   
[build]   /** Optionally sets the audio conversion info.  Used only for raw output */
[build]    void
[build]   obs_output_set_audio_conversion(obs_output_t *output,
[build]   				const struct audio_convert_info *conversion);
[build]   
[build]   /** Returns whether data capture can begin with the specified flags */
[build]    bool obs_output_can_begin_data_capture(const obs_output_t *output,
[build]   					      uint32_t flags);
[build]   
[build]   /** Initializes encoders (if any) */
[build]    bool obs_output_initialize_encoders(obs_output_t *output,
[build]   					   uint32_t flags);
[build]   
[build]   /**
[build]    * Begins data capture from media/encoders.
[build]    *
[build]    * @param  output  Output context
[build]    * @param  flags   Set this to 0 to use default output flags set in the
[build]    *                 obs_output_info structure, otherwise set to a either
[build]    *                 OBS_OUTPUT_VIDEO or OBS_OUTPUT_AUDIO to specify whether to
[build]    *                 connect audio or video.  This is useful for things like
[build]    *                 ffmpeg which may or may not always want to use both audio
[build]    *                 and video.
[build]    * @return         true if successful, false otherwise.
[build]    */
[build]    bool obs_output_begin_data_capture(obs_output_t *output, uint32_t flags);
[build]   
[build]   /** Ends data capture from media/encoders */
[build]    void obs_output_end_data_capture(obs_output_t *output);
[build]   
[build]   /**
[build]    * Signals that the output has stopped itself.
[build]    *
[build]    * @param  output  Output context
[build]    * @param  code    Error code (or OBS_OUTPUT_SUCCESS if not an error)
[build]    */
[build]    void obs_output_signal_stop(obs_output_t *output, int code);
[build]   
[build]    uint64_t obs_output_get_pause_offset(obs_output_t *output);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Encoders */
[build]   
[build]    const char *obs_encoder_get_display_name(const char *id);
[build]   
[build]   /**
[build]    * Creates a video encoder context
[build]    *
[build]    * @param  id        Video encoder ID
[build]    * @param  name      Name to assign to this context
[build]    * @param  settings  Settings
[build]    * @return           The video encoder context, or NULL if failed or not found.
[build]    */
[build]    obs_encoder_t *obs_video_encoder_create(const char *id, const char *name,
[build]   					       obs_data_t *settings,
[build]   					       obs_data_t *hotkey_data);
[build]   
[build]   /**
[build]    * Creates an audio encoder context
[build]    *
[build]    * @param  id        Audio Encoder ID
[build]    * @param  name      Name to assign to this context
[build]    * @param  settings  Settings
[build]    * @param  mixer_idx Index of the mixer to use for this audio encoder
[build]    * @return           The video encoder context, or NULL if failed or not found.
[build]    */
[build]    obs_encoder_t *obs_audio_encoder_create(const char *id, const char *name,
[build]   					       obs_data_t *settings,
[build]   					       size_t mixer_idx,
[build]   					       obs_data_t *hotkey_data);
[build]   
[build]   /**
[build]    * Adds/releases a reference to an encoder.  When the last reference is
[build]    * released, the encoder is destroyed.
[build]    */
[build]    void obs_encoder_addref(obs_encoder_t *encoder);
[build]    void obs_encoder_release(obs_encoder_t *encoder);
[build]   
[build]    void obs_weak_encoder_addref(obs_weak_encoder_t *weak);
[build]    void obs_weak_encoder_release(obs_weak_encoder_t *weak);
[build]   
[build]    obs_encoder_t *obs_encoder_get_ref(obs_encoder_t *encoder);
[build]    obs_weak_encoder_t *obs_encoder_get_weak_encoder(obs_encoder_t *encoder);
[build]    obs_encoder_t *obs_weak_encoder_get_encoder(obs_weak_encoder_t *weak);
[build]   
[build]    bool obs_weak_encoder_references_encoder(obs_weak_encoder_t *weak,
[build]   						obs_encoder_t *encoder);
[build]   
[build]    void obs_encoder_set_name(obs_encoder_t *encoder, const char *name);
[build]    const char *obs_encoder_get_name(const obs_encoder_t *encoder);
[build]   
[build]   /** Returns the codec of an encoder by the id */
[build]    const char *obs_get_encoder_codec(const char *id);
[build]   
[build]   /** Returns the type of an encoder by the id */
[build]    enum obs_encoder_type obs_get_encoder_type(const char *id);
[build]   
[build]   /** Returns the codec of the encoder */
[build]    const char *obs_encoder_get_codec(const obs_encoder_t *encoder);
[build]   
[build]   /** Returns the type of an encoder */
[build]    enum obs_encoder_type obs_encoder_get_type(const obs_encoder_t *encoder);
[build]   
[build]   /**
[build]    * Sets the scaled resolution for a video encoder.  Set width and height to 0
[build]    * to disable scaling.  If the encoder is active, this function will trigger
[build]    * a warning, and do nothing.
[build]    */
[build]    void obs_encoder_set_scaled_size(obs_encoder_t *encoder, uint32_t width,
[build]   					uint32_t height);
[build]   
[build]   /** For video encoders, returns true if pre-encode scaling is enabled */
[build]    bool obs_encoder_scaling_enabled(const obs_encoder_t *encoder);
[build]   
[build]   /** For video encoders, returns the width of the encoded image */
[build]    uint32_t obs_encoder_get_width(const obs_encoder_t *encoder);
[build]   
[build]   /** For video encoders, returns the height of the encoded image */
[build]    uint32_t obs_encoder_get_height(const obs_encoder_t *encoder);
[build]   
[build]   /** For audio encoders, returns the sample rate of the audio */
[build]    uint32_t obs_encoder_get_sample_rate(const obs_encoder_t *encoder);
[build]   
[build]   /**
[build]    * Sets the preferred video format for a video encoder.  If the encoder can use
[build]    * the format specified, it will force a conversion to that format if the
[build]    * obs output format does not match the preferred format.
[build]    *
[build]    * If the format is set to VIDEO_FORMAT_NONE, will revert to the default
[build]    * functionality of converting only when absolutely necessary.
[build]    */
[build]    void obs_encoder_set_preferred_video_format(obs_encoder_t *encoder,
[build]   						   enum video_format format);
[build]    enum video_format
[build]   obs_encoder_get_preferred_video_format(const obs_encoder_t *encoder);
[build]   
[build]   /** Gets the default settings for an encoder type */
[build]    obs_data_t *obs_encoder_defaults(const char *id);
[build]    obs_data_t *obs_encoder_get_defaults(const obs_encoder_t *encoder);
[build]   
[build]   /** Returns the property list, if any.  Free with obs_properties_destroy */
[build]    obs_properties_t *obs_get_encoder_properties(const char *id);
[build]   
[build]   /**
[build]    * Returns the property list of an existing encoder, if any.  Free with
[build]    * obs_properties_destroy
[build]    */
[build]    obs_properties_t *obs_encoder_properties(const obs_encoder_t *encoder);
[build]   
[build]   /**
[build]    * Updates the settings of the encoder context.  Usually used for changing
[build]    * bitrate while active
[build]    */
[build]    void obs_encoder_update(obs_encoder_t *encoder, obs_data_t *settings);
[build]   
[build]   /** Gets extra data (headers) associated with this context */
[build]    bool obs_encoder_get_extra_data(const obs_encoder_t *encoder,
[build]   				       uint8_t **extra_data, size_t *size);
[build]   
[build]   /** Returns the current settings for this encoder */
[build]    obs_data_t *obs_encoder_get_settings(const obs_encoder_t *encoder);
[build]   
[build]   /** Sets the video output context to be used with this encoder */
[build]    void obs_encoder_set_video(obs_encoder_t *encoder, video_t *video);
[build]   
[build]   /** Sets the audio output context to be used with this encoder */
[build]    void obs_encoder_set_audio(obs_encoder_t *encoder, audio_t *audio);
[build]   
[build]   /**
[build]    * Returns the video output context used with this encoder, or NULL if not
[build]    * a video context
[build]    */
[build]    video_t *obs_encoder_video(const obs_encoder_t *encoder);
[build]   
[build]   /**
[build]    * Returns the audio output context used with this encoder, or NULL if not
[build]    * a audio context
[build]    */
[build]    audio_t *obs_encoder_audio(const obs_encoder_t *encoder);
[build]   
[build]   /** Returns true if encoder is active, false otherwise */
[build]    bool obs_encoder_active(const obs_encoder_t *encoder);
[build]   
[build]    void *obs_encoder_get_type_data(obs_encoder_t *encoder);
[build]   
[build]    const char *obs_encoder_get_id(const obs_encoder_t *encoder);
[build]   
[build]    uint32_t obs_get_encoder_caps(const char *encoder_id);
[build]    uint32_t obs_encoder_get_caps(const obs_encoder_t *encoder);
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]    void obs_encoder_packet_ref(struct encoder_packet *dst,
[build]   				   struct encoder_packet *src);
[build]    void obs_encoder_packet_release(struct encoder_packet *packet);
[build]   
[build]    void *obs_encoder_create_rerouted(obs_encoder_t *encoder,
[build]   					 const char *reroute_id);
[build]   
[build]   /** Returns whether encoder is paused */
[build]    bool obs_encoder_paused(const obs_encoder_t *output);
[build]   
[build]    const char *obs_encoder_get_last_error(obs_encoder_t *encoder);
[build]    void obs_encoder_set_last_error(obs_encoder_t *encoder,
[build]   				       const char *message);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Stream Services */
[build]   
[build]    const char *obs_service_get_display_name(const char *id);
[build]   
[build]    obs_service_t *obs_service_create(const char *id, const char *name,
[build]   					 obs_data_t *settings,
[build]   					 obs_data_t *hotkey_data);
[build]   
[build]    obs_service_t *obs_service_create_private(const char *id,
[build]   						 const char *name,
[build]   						 obs_data_t *settings);
[build]   
[build]   /**
[build]    * Adds/releases a reference to a service.  When the last reference is
[build]    * released, the service is destroyed.
[build]    */
[build]    void obs_service_addref(obs_service_t *service);
[build]    void obs_service_release(obs_service_t *service);
[build]   
[build]    void obs_weak_service_addref(obs_weak_service_t *weak);
[build]    void obs_weak_service_release(obs_weak_service_t *weak);
[build]   
[build]    obs_service_t *obs_service_get_ref(obs_service_t *service);
[build]    obs_weak_service_t *obs_service_get_weak_service(obs_service_t *service);
[build]    obs_service_t *obs_weak_service_get_service(obs_weak_service_t *weak);
[build]   
[build]    bool obs_weak_service_references_service(obs_weak_service_t *weak,
[build]   						obs_service_t *service);
[build]   
[build]    const char *obs_service_get_name(const obs_service_t *service);
[build]   
[build]   /** Gets the default settings for a service */
[build]    obs_data_t *obs_service_defaults(const char *id);
[build]   
[build]   /** Returns the property list, if any.  Free with obs_properties_destroy */
[build]    obs_properties_t *obs_get_service_properties(const char *id);
[build]   
[build]   /**
[build]    * Returns the property list of an existing service context, if any.  Free with
[build]    * obs_properties_destroy
[build]    */
[build]    obs_properties_t *obs_service_properties(const obs_service_t *service);
[build]   
[build]   /** Gets the service type */
[build]    const char *obs_service_get_type(const obs_service_t *service);
[build]   
[build]   /** Updates the settings of the service context */
[build]    void obs_service_update(obs_service_t *service, obs_data_t *settings);
[build]   
[build]   /** Returns the current settings for this service */
[build]    obs_data_t *obs_service_get_settings(const obs_service_t *service);
[build]   
[build]   /** Returns the URL for this service context */
[build]    const char *obs_service_get_url(const obs_service_t *service);
[build]   
[build]   /** Returns the stream key (if any) for this service context */
[build]    const char *obs_service_get_key(const obs_service_t *service);
[build]   
[build]   /** Returns the username (if any) for this service context */
[build]    const char *obs_service_get_username(const obs_service_t *service);
[build]   
[build]   /** Returns the password (if any) for this service context */
[build]    const char *obs_service_get_password(const obs_service_t *service);
[build]   
[build]   /**
[build]    * Applies service-specific video encoder settings.
[build]    *
[build]    * @param  video_encoder_settings  Video encoder settings.  Optional.
[build]    * @param  audio_encoder_settings  Audio encoder settings.  Optional.
[build]    */
[build]    void
[build]   obs_service_apply_encoder_settings(obs_service_t *service,
[build]   				   obs_data_t *video_encoder_settings,
[build]   				   obs_data_t *audio_encoder_settings);
[build]   
[build]    void *obs_service_get_type_data(obs_service_t *service);
[build]   
[build]    const char *obs_service_get_id(const obs_service_t *service);
[build]   
[build]    void obs_service_get_supported_resolutions(
[build]   	const obs_service_t *service,
[build]   	struct obs_service_resolution **resolutions, size_t *count);
[build]    void obs_service_get_max_fps(const obs_service_t *service, int *fps);
[build]   
[build]    void obs_service_get_max_bitrate(const obs_service_t *service,
[build]   					int *video_bitrate, int *audio_bitrate);
[build]   
[build]   /* NOTE: This function is temporary and should be removed/replaced at a later
[build]    * date. */
[build]    const char *obs_service_get_output_type(const obs_service_t *service);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Source frame allocation functions */
[build]    void obs_source_frame_init(struct obs_source_frame *frame,
[build]   				  enum video_format format, uint32_t width,
[build]   				  uint32_t height);
[build]   
[build]   static inline void obs_source_frame_free(struct obs_source_frame *frame)
[build]   {
[build]   	if (frame) {
[build]   		bfree(frame->data[0]);
[build]   		memset(frame, 0, sizeof(*frame));
[build]   	}
[build]   }
[build]   
[build]   static inline struct obs_source_frame *
[build]   obs_source_frame_create(enum video_format format, uint32_t width,
[build]   			uint32_t height)
[build]   {
[build]   	struct obs_source_frame *frame;
[build]   
[build]   	frame = (struct obs_source_frame *)bzalloc(sizeof(*frame));
[build]   	obs_source_frame_init(frame, format, width, height);
[build]   	return frame;
[build]   }
[build]   
[build]   static inline void obs_source_frame_destroy(struct obs_source_frame *frame)
[build]   {
[build]   	if (frame) {
[build]   		bfree(frame->data[0]);
[build]   		bfree(frame);
[build]   	}
[build]   }
[build]   
[build]    void obs_source_frame_copy(struct obs_source_frame *dst,
[build]   				  const struct obs_source_frame *src);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* Get source icon type */
[build]    enum obs_icon_type obs_source_get_icon_type(const char *id);
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\callback\\calldata.h" %beginfile
[build]   /*
[build]    * Copyright (c) 2013 Hugh Bailey <obs.jim@gmail.com>
[build]    *
[build]    * Permission to use, copy, modify, and distribute this software for any
[build]    * purpose with or without fee is hereby granted, provided that the above
[build]    * copyright notice and this permission notice appear in all copies.
[build]    *
[build]    * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
[build]    * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
[build]    * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
[build]    * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
[build]    * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
[build]    * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
[build]    * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
[build]    */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*
[build]    * Procedure call data structure
[build]    *
[build]    *   This is used to store parameters (and return value) sent to/from signals,
[build]    * procedures, and callbacks.
[build]    */
[build]   
[build]   enum call_param_type {
[build]   	CALL_PARAM_TYPE_VOID,
[build]   	CALL_PARAM_TYPE_INT,
[build]   	CALL_PARAM_TYPE_FLOAT,
[build]   	CALL_PARAM_TYPE_BOOL,
[build]   	CALL_PARAM_TYPE_PTR,
[build]   	CALL_PARAM_TYPE_STRING
[build]   };
[build]   
[build]   %constant CALL_PARAM_IN = (1 << 0);
[build]   %constant CALL_PARAM_OUT = (1 << 1);
[build]   
[build]   struct calldata {
[build]   	uint8_t *stack;
[build]   	size_t size;     /* size of the stack, in bytes */
[build]   	size_t capacity; /* capacity of the stack, in bytes */
[build]   	bool fixed;      /* fixed size (using call stack) */
[build]   };
[build]   
[build]   typedef struct calldata calldata_t;
[build]   
[build]   static inline void calldata_init(struct calldata *data)
[build]   {
[build]   	memset(data, 0, sizeof(struct calldata));
[build]   }
[build]   
[build]   static inline void calldata_clear(struct calldata *data);
[build]   
[build]   static inline void calldata_init_fixed(struct calldata *data, uint8_t *stack,
[build]   				       size_t size)
[build]   {
[build]   	data->stack = stack;
[build]   	data->capacity = size;
[build]   	data->fixed = true;
[build]   	data->size = 0;
[build]   	calldata_clear(data);
[build]   }
[build]   
[build]   static inline void calldata_free(struct calldata *data)
[build]   {
[build]   	if (!data->fixed)
[build]   		bfree(data->stack);
[build]   }
[build]   
[build]    bool calldata_get_data(const calldata_t *data, const char *name,
[build]   			      void *out, size_t size);
[build]    void calldata_set_data(calldata_t *data, const char *name,
[build]   			      const void *in, size_t new_size);
[build]   
[build]   static inline void calldata_clear(struct calldata *data)
[build]   {
[build]   	if (data->stack) {
[build]   		data->size = sizeof(size_t);
[build]   		memset(data->stack, 0, sizeof(size_t));
[build]   	}
[build]   }
[build]   
[build]   static inline calldata_t *calldata_create(void)
[build]   {
[build]   	return (calldata_t *)bzalloc(sizeof(struct calldata));
[build]   }
[build]   
[build]   static inline void calldata_destroy(calldata_t *cd)
[build]   {
[build]   	calldata_free(cd);
[build]   	bfree(cd);
[build]   }
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* NOTE: 'get' functions return true only if parameter exists, and is the
[build]    *       same type.  They return false otherwise. */
[build]   
[build]   static inline bool calldata_get_int(const calldata_t *data, const char *name,
[build]   				    long long *val)
[build]   {
[build]   	return calldata_get_data(data, name, val, sizeof(*val));
[build]   }
[build]   
[build]   static inline bool calldata_get_float(const calldata_t *data, const char *name,
[build]   				      double *val)
[build]   {
[build]   	return calldata_get_data(data, name, val, sizeof(*val));
[build]   }
[build]   
[build]   static inline bool calldata_get_bool(const calldata_t *data, const char *name,
[build]   				     bool *val)
[build]   {
[build]   	return calldata_get_data(data, name, val, sizeof(*val));
[build]   }
[build]   
[build]   static inline bool calldata_get_ptr(const calldata_t *data, const char *name,
[build]   				    void *p_ptr)
[build]   {
[build]   	return calldata_get_data(data, name, p_ptr, sizeof(p_ptr));
[build]   }
[build]   
[build]    bool calldata_get_string(const calldata_t *data, const char *name,
[build]   				const char **str);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   /* call if you know your data is valid */
[build]   
[build]   static inline long long calldata_int(const calldata_t *data, const char *name)
[build]   {
[build]   	long long val = 0;
[build]   	calldata_get_int(data, name, &val);
[build]   	return val;
[build]   }
[build]   
[build]   static inline double calldata_float(const calldata_t *data, const char *name)
[build]   {
[build]   	double val = 0.0;
[build]   	calldata_get_float(data, name, &val);
[build]   	return val;
[build]   }
[build]   
[build]   static inline bool calldata_bool(const calldata_t *data, const char *name)
[build]   {
[build]   	bool val = false;
[build]   	calldata_get_bool(data, name, &val);
[build]   	return val;
[build]   }
[build]   
[build]   static inline void *calldata_ptr(const calldata_t *data, const char *name)
[build]   {
[build]   	void *val = NULL;
[build]   	calldata_get_ptr(data, name, &val);
[build]   	return val;
[build]   }
[build]   
[build]   static inline const char *calldata_string(const calldata_t *data,
[build]   					  const char *name)
[build]   {
[build]   	const char *val = NULL;
[build]   	calldata_get_string(data, name, &val);
[build]   	return val;
[build]   }
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   
[build]   static inline void calldata_set_int(calldata_t *data, const char *name,
[build]   				    long long val)
[build]   {
[build]   	calldata_set_data(data, name, &val, sizeof(val));
[build]   }
[build]   
[build]   static inline void calldata_set_float(calldata_t *data, const char *name,
[build]   				      double val)
[build]   {
[build]   	calldata_set_data(data, name, &val, sizeof(val));
[build]   }
[build]   
[build]   static inline void calldata_set_bool(calldata_t *data, const char *name,
[build]   				     bool val)
[build]   {
[build]   	calldata_set_data(data, name, &val, sizeof(val));
[build]   }
[build]   
[build]   static inline void calldata_set_ptr(calldata_t *data, const char *name,
[build]   				    void *ptr)
[build]   {
[build]   	calldata_set_data(data, name, &ptr, sizeof(ptr));
[build]   }
[build]   
[build]   static inline void calldata_set_string(calldata_t *data, const char *name,
[build]   				       const char *str)
[build]   {
[build]   	if (str)
[build]   		calldata_set_data(data, name, str, strlen(str) + 1);
[build]   	else
[build]   		calldata_set_data(data, name, NULL, 0);
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\callback\\proc.h" %beginfile
[build]   /*
[build]    * Copyright (c) 2013 Hugh Bailey <obs.jim@gmail.com>
[build]    *
[build]    * Permission to use, copy, modify, and distribute this software for any
[build]    * purpose with or without fee is hereby granted, provided that the above
[build]    * copyright notice and this permission notice appear in all copies.
[build]    *
[build]    * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
[build]    * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
[build]    * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
[build]    * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
[build]    * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
[build]    * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
[build]    * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
[build]    */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*
[build]    * Procedure handler
[build]    *
[build]    *   This handler is used to allow access to one or more procedures that can be
[build]    *   added and called without having to have direct access to declarations or
[build]    *   procedure callback pointers.
[build]    */
[build]   
[build]   struct proc_handler;
[build]   typedef struct proc_handler proc_handler_t;
[build]   typedef void (*proc_handler_proc_t)(void *, calldata_t *);
[build]   
[build]    proc_handler_t *proc_handler_create(void);
[build]    void proc_handler_destroy(proc_handler_t *handler);
[build]   
[build]    void proc_handler_add(proc_handler_t *handler, const char *decl_string,
[build]   			     proc_handler_proc_t proc, void *data);
[build]   
[build]   /**
[build]    * Calls a function in a procedure handler.  Returns false if the named
[build]    * procedure is not found.
[build]    */
[build]    bool proc_handler_call(proc_handler_t *handler, const char *name,
[build]   			      calldata_t *params);
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\callback\\signal.h" %beginfile
[build]   /*
[build]    * Copyright (c) 2013 Hugh Bailey <obs.jim@gmail.com>
[build]    *
[build]    * Permission to use, copy, modify, and distribute this software for any
[build]    * purpose with or without fee is hereby granted, provided that the above
[build]    * copyright notice and this permission notice appear in all copies.
[build]    *
[build]    * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
[build]    * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
[build]    * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
[build]    * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
[build]    * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
[build]    * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
[build]    * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
[build]    */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*
[build]    * Signal handler
[build]    *
[build]    *   This is used to create a signal handler which can broadcast events
[build]    * to one or more callbacks connected to a signal.
[build]    */
[build]   
[build]   struct signal_handler;
[build]   typedef struct signal_handler signal_handler_t;
[build]   typedef void (*global_signal_callback_t)(void *, const char *, calldata_t *);
[build]   typedef void (*signal_callback_t)(void *, calldata_t *);
[build]   
[build]    signal_handler_t *signal_handler_create(void);
[build]    void signal_handler_destroy(signal_handler_t *handler);
[build]   
[build]    bool signal_handler_add(signal_handler_t *handler,
[build]   			       const char *signal_decl);
[build]   
[build]   static inline bool signal_handler_add_array(signal_handler_t *handler,
[build]   					    const char **signal_decls)
[build]   {
[build]   	bool success = true;
[build]   	if (!signal_decls)
[build]   		return false;
[build]   
[build]   	while (*signal_decls)
[build]   		if (!signal_handler_add(handler, *(signal_decls++)))
[build]   			success = false;
[build]   
[build]   	return success;
[build]   }
[build]   
[build]    void signal_handler_connect(signal_handler_t *handler,
[build]   				   const char *signal,
[build]   				   signal_callback_t callback, void *data);
[build]    void signal_handler_connect_ref(signal_handler_t *handler,
[build]   				       const char *signal,
[build]   				       signal_callback_t callback, void *data);
[build]    void signal_handler_disconnect(signal_handler_t *handler,
[build]   				      const char *signal,
[build]   				      signal_callback_t callback, void *data);
[build]   
[build]    void signal_handler_connect_global(signal_handler_t *handler,
[build]   					  global_signal_callback_t callback,
[build]   					  void *data);
[build]    void signal_handler_disconnect_global(signal_handler_t *handler,
[build]   					     global_signal_callback_t callback,
[build]   					     void *data);
[build]   
[build]    void signal_handler_remove_current(void);
[build]   
[build]    void signal_handler_signal(signal_handler_t *handler, const char *signal,
[build]   				  calldata_t *params);
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\util\\bmem.h" %beginfile
[build]   /*
[build]    * Copyright (c) 2013 Hugh Bailey <obs.jim@gmail.com>
[build]    *
[build]    * Permission to use, copy, modify, and distribute this software for any
[build]    * purpose with or without fee is hereby granted, provided that the above
[build]    * copyright notice and this permission notice appear in all copies.
[build]    *
[build]    * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
[build]    * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
[build]    * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
[build]    * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
[build]    * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
[build]    * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
[build]    * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
[build]    */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   struct base_allocator {
[build]   	void *(*malloc)(size_t);
[build]   	void *(*realloc)(void *, size_t);
[build]   	void (*free)(void *);
[build]   };
[build]   
[build]    void base_set_allocator(struct base_allocator *defs);
[build]   
[build]    void *bmalloc(size_t size);
[build]    void *brealloc(void *ptr, size_t size);
[build]    void bfree(void *ptr);
[build]   
[build]    int base_get_alignment(void);
[build]   
[build]    long bnum_allocs(void);
[build]   
[build]    void *bmemdup(const void *ptr, size_t size);
[build]   
[build]   static inline void *bzalloc(size_t size)
[build]   {
[build]   	void *mem = bmalloc(size);
[build]   	if (mem)
[build]   		memset(mem, 0, size);
[build]   	return mem;
[build]   }
[build]   
[build]   static inline char *bstrdup_n(const char *str, size_t n)
[build]   {
[build]   	char *dup;
[build]   	if (!str)
[build]   		return NULL;
[build]   
[build]   	dup = (char *)bmemdup(str, n + 1);
[build]   	dup[n] = 0;
[build]   
[build]   	return dup;
[build]   }
[build]   
[build]   static inline wchar_t *bwstrdup_n(const wchar_t *str, size_t n)
[build]   {
[build]   	wchar_t *dup;
[build]   	if (!str)
[build]   		return NULL;
[build]   
[build]   	dup = (wchar_t *)bmemdup(str, (n + 1) * sizeof(wchar_t));
[build]   	dup[n] = 0;
[build]   
[build]   	return dup;
[build]   }
[build]   
[build]   static inline char *bstrdup(const char *str)
[build]   {
[build]   	if (!str)
[build]   		return NULL;
[build]   
[build]   	return bstrdup_n(str, strlen(str));
[build]   }
[build]   
[build]   static inline wchar_t *bwstrdup(const wchar_t *str)
[build]   {
[build]   	if (!str)
[build]   		return NULL;
[build]   
[build]   	return bwstrdup_n(str, wcslen(str));
[build]   }
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\util\\base.h" %beginfile
[build]   /*
[build]    * Copyright (c) 2013 Hugh Bailey <obs.jim@gmail.com>
[build]    *
[build]    * Permission to use, copy, modify, and distribute this software for any
[build]    * purpose with or without fee is hereby granted, provided that the above
[build]    * copyright notice and this permission notice appear in all copies.
[build]    *
[build]    * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
[build]    * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
[build]    * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
[build]    * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
[build]    * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
[build]    * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
[build]    * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
[build]    */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*
[build]    * Just contains logging/crash related stuff
[build]    */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %constant S__LINE__ = "33";
[build]   
[build]   %constant INT_CUR_LINE = 35;
[build]   %constant FILE_LINE = "D:/bfxdev/obs-studio/libobs\\util\\base.h" " (" "36" "): ";
[build]   
[build]   enum {
[build]   	/**
[build]   	 * Use if there's a problem that can potentially affect the program,
[build]   	 * but isn't enough to require termination of the program.
[build]   	 *
[build]   	 * Use in creation functions and core subsystem functions.  Places that
[build]   	 * should definitely not fail.
[build]   	 */
[build]   	LOG_ERROR = 100,
[build]   
[build]   	/**
[build]   	 * Use if a problem occurs that doesn't affect the program and is
[build]   	 * recoverable.
[build]   	 *
[build]   	 * Use in places where failure isn't entirely unexpected, and can
[build]   	 * be handled safely.
[build]   	 */
[build]   	LOG_WARNING = 200,
[build]   
[build]   	/**
[build]   	 * Informative message to be displayed in the log.
[build]   	 */
[build]   	LOG_INFO = 300,
[build]   
[build]   	/**
[build]   	 * Debug message to be used mostly by developers.
[build]   	 */
[build]   	LOG_DEBUG = 400
[build]   };
[build]   
[build]   typedef void (*log_handler_t)(int lvl, const char *msg, va_list args, void *p);
[build]   
[build]    void base_get_log_handler(log_handler_t *handler, void **param);
[build]    void base_set_log_handler(log_handler_t handler, void *param);
[build]   
[build]    void base_set_crash_handler(void (*handler)(const char *, va_list,
[build]   						   void *),
[build]   				   void *param);
[build]   
[build]    void blogva(int log_level, const char *format, va_list args);
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]    void blog(int log_level, const char *format, ...);
[build]   
[build]    void bcrash(const char *format, ...);
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   %includefile "D:\\bfxdev\\obs-studio\\libobs\\util\\platform.h" %beginfile
[build]   /*
[build]    * Copyright (c) 2013 Hugh Bailey <obs.jim@gmail.com>
[build]    *
[build]    * Permission to use, copy, modify, and distribute this software for any
[build]    * purpose with or without fee is hereby granted, provided that the above
[build]    * copyright notice and this permission notice appear in all copies.
[build]    *
[build]    * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
[build]    * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
[build]    * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
[build]    * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
[build]    * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
[build]    * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
[build]    * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
[build]    */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /*
[build]    * Platform-independent functions for Accessing files, encoding, DLLs,
[build]    * sleep, timer, and timing.
[build]    */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]    FILE *os_wfopen(const wchar_t *path, const char *mode);
[build]    FILE *os_fopen(const char *path, const char *mode);
[build]    int64_t os_fgetsize(FILE *file);
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]    int os_fseeki64(FILE *file, int64_t offset, int origin);
[build]    int64_t os_ftelli64(FILE *file);
[build]   
[build]    size_t os_fread_mbs(FILE *file, char **pstr);
[build]    size_t os_fread_utf8(FILE *file, char **pstr);
[build]   
[build]   /* functions purely for convenience */
[build]    char *os_quick_read_utf8_file(const char *path);
[build]    bool os_quick_write_utf8_file(const char *path, const char *str,
[build]   				     size_t len, bool marker);
[build]    bool os_quick_write_utf8_file_safe(const char *path, const char *str,
[build]   					  size_t len, bool marker,
[build]   					  const char *temp_ext,
[build]   					  const char *backup_ext);
[build]    char *os_quick_read_mbs_file(const char *path);
[build]    bool os_quick_write_mbs_file(const char *path, const char *str,
[build]   				    size_t len);
[build]   
[build]    int64_t os_get_file_size(const char *path);
[build]    int64_t os_get_free_space(const char *path);
[build]   
[build]    size_t os_mbs_to_wcs(const char *str, size_t str_len, wchar_t *dst,
[build]   			    size_t dst_size);
[build]    size_t os_utf8_to_wcs(const char *str, size_t len, wchar_t *dst,
[build]   			     size_t dst_size);
[build]    size_t os_wcs_to_mbs(const wchar_t *str, size_t len, char *dst,
[build]   			    size_t dst_size);
[build]    size_t os_wcs_to_utf8(const wchar_t *str, size_t len, char *dst,
[build]   			     size_t dst_size);
[build]   
[build]    size_t os_mbs_to_wcs_ptr(const char *str, size_t len, wchar_t **pstr);
[build]    size_t os_utf8_to_wcs_ptr(const char *str, size_t len, wchar_t **pstr);
[build]    size_t os_wcs_to_mbs_ptr(const wchar_t *str, size_t len, char **pstr);
[build]    size_t os_wcs_to_utf8_ptr(const wchar_t *str, size_t len, char **pstr);
[build]   
[build]    size_t os_utf8_to_mbs_ptr(const char *str, size_t len, char **pstr);
[build]    size_t os_mbs_to_utf8_ptr(const char *str, size_t len, char **pstr);
[build]   
[build]    double os_strtod(const char *str);
[build]    int os_dtostr(double value, char *dst, size_t size);
[build]   
[build]    void *os_dlopen(const char *path);
[build]    void *os_dlsym(void *module, const char *func);
[build]    void os_dlclose(void *module);
[build]   
[build]   struct os_cpu_usage_info;
[build]   typedef struct os_cpu_usage_info os_cpu_usage_info_t;
[build]   
[build]    os_cpu_usage_info_t *os_cpu_usage_info_start(void);
[build]    double os_cpu_usage_info_query(os_cpu_usage_info_t *info);
[build]    void os_cpu_usage_info_destroy(os_cpu_usage_info_t *info);
[build]   
[build]   typedef const void os_performance_token_t;
[build]    os_performance_token_t *os_request_high_performance(const char *reason);
[build]    void os_end_high_performance(os_performance_token_t *);
[build]   
[build]   /**
[build]    * Sleeps to a specific time (in nanoseconds).  Doesn't have to be super
[build]    * accurate in terms of actual slept time because the target time is ensured.
[build]    * Returns false if already at or past target time.
[build]    */
[build]    bool os_sleepto_ns(uint64_t time_target);
[build]    void os_sleep_ms(uint32_t duration);
[build]   
[build]    uint64_t os_gettime_ns(void);
[build]   
[build]    int os_get_config_path(char *dst, size_t size, const char *name);
[build]    char *os_get_config_path_ptr(const char *name);
[build]   
[build]    int os_get_program_data_path(char *dst, size_t size, const char *name);
[build]    char *os_get_program_data_path_ptr(const char *name);
[build]   
[build]    char *os_get_executable_path_ptr(const char *name);
[build]   
[build]    bool os_file_exists(const char *path);
[build]   
[build]    size_t os_get_abs_path(const char *path, char *abspath, size_t size);
[build]    char *os_get_abs_path_ptr(const char *path);
[build]   
[build]    const char *os_get_path_extension(const char *path);
[build]   
[build]   struct os_dir;
[build]   typedef struct os_dir os_dir_t;
[build]   
[build]   struct os_dirent {
[build]   	char d_name[256];
[build]   	bool directory;
[build]   };
[build]   
[build]    os_dir_t *os_opendir(const char *path);
[build]    struct os_dirent *os_readdir(os_dir_t *dir);
[build]    void os_closedir(os_dir_t *dir);
[build]   
[build]   struct os_globent {
[build]   	char *path;
[build]   	bool directory;
[build]   };
[build]   
[build]   struct os_glob_info {
[build]   	size_t gl_pathc;
[build]   	struct os_globent *gl_pathv;
[build]   };
[build]   
[build]   typedef struct os_glob_info os_glob_t;
[build]   
[build]   /* currently no flags available */
[build]   
[build]    int os_glob(const char *pattern, int flags, os_glob_t **pglob);
[build]    void os_globfree(os_glob_t *pglob);
[build]   
[build]    int os_unlink(const char *path);
[build]    int os_rmdir(const char *path);
[build]   
[build]    char *os_getcwd(char *path, size_t size);
[build]    int os_chdir(const char *path);
[build]   
[build]    uint64_t os_get_free_disk_space(const char *dir);
[build]   
[build]   %constant MKDIR_EXISTS = 1;
[build]   %constant MKDIR_SUCCESS = 0;
[build]   %constant MKDIR_ERROR = -1;
[build]   
[build]    int os_mkdir(const char *path);
[build]    int os_mkdirs(const char *path);
[build]    int os_rename(const char *old_path, const char *new_path);
[build]    int os_copyfile(const char *file_in, const char *file_out);
[build]    int os_safe_replace(const char *target_path, const char *from_path,
[build]   			   const char *backup_path);
[build]   
[build]    char *os_generate_formatted_filename(const char *extension, bool space,
[build]   					    const char *format);
[build]   
[build]   struct os_inhibit_info;
[build]   typedef struct os_inhibit_info os_inhibit_t;
[build]   
[build]    os_inhibit_t *os_inhibit_sleep_create(const char *reason);
[build]    bool os_inhibit_sleep_set_active(os_inhibit_t *info, bool active);
[build]    void os_inhibit_sleep_destroy(os_inhibit_t *info);
[build]   
[build]    void os_breakpoint(void);
[build]   
[build]    int os_get_physical_cores(void);
[build]    int os_get_logical_cores(void);
[build]   
[build]    uint64_t os_get_sys_free_size(void);
[build]   
[build]   struct os_proc_memory_usage {
[build]   	uint64_t resident_size;
[build]   	uint64_t virtual_size;
[build]   };
[build]   typedef struct os_proc_memory_usage os_proc_memory_usage_t;
[build]   
[build]    bool os_get_proc_memory_usage(os_proc_memory_usage_t *usage);
[build]    uint64_t os_get_proc_resident_size(void);
[build]    uint64_t os_get_proc_virtual_size(void);
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* clang-format off */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   %constant ARCH_BITS = 32;
[build]   
[build]   
[build]   
[build]   /* clang-format on */
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   
[build]   
[build]   %includefile "D:\\bfxdev\\obs-studio\\UI\\obs-frontend-api\\obs-frontend-api.h" %beginfile
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   struct config_data;
[build]   typedef struct config_data config_t;
[build]   
[build]   struct obs_data;
[build]   typedef struct obs_data obs_data_t;
[build]   
[build]   enum obs_frontend_event {
[build]   	OBS_FRONTEND_EVENT_STREAMING_STARTING,
[build]   	OBS_FRONTEND_EVENT_STREAMING_STARTED,
[build]   	OBS_FRONTEND_EVENT_STREAMING_STOPPING,
[build]   	OBS_FRONTEND_EVENT_STREAMING_STOPPED,
[build]   	OBS_FRONTEND_EVENT_RECORDING_STARTING,
[build]   	OBS_FRONTEND_EVENT_RECORDING_STARTED,
[build]   	OBS_FRONTEND_EVENT_RECORDING_STOPPING,
[build]   	OBS_FRONTEND_EVENT_RECORDING_STOPPED,
[build]   	OBS_FRONTEND_EVENT_SCENE_CHANGED,
[build]   	OBS_FRONTEND_EVENT_SCENE_LIST_CHANGED,
[build]   	OBS_FRONTEND_EVENT_TRANSITION_CHANGED,
[build]   	OBS_FRONTEND_EVENT_TRANSITION_STOPPED,
[build]   	OBS_FRONTEND_EVENT_TRANSITION_LIST_CHANGED,
[build]   	OBS_FRONTEND_EVENT_SCENE_COLLECTION_CHANGED,
[build]   	OBS_FRONTEND_EVENT_SCENE_COLLECTION_LIST_CHANGED,
[build]   	OBS_FRONTEND_EVENT_PROFILE_CHANGED,
[build]   	OBS_FRONTEND_EVENT_PROFILE_LIST_CHANGED,
[build]   	OBS_FRONTEND_EVENT_EXIT,
[build]   
[build]   	OBS_FRONTEND_EVENT_REPLAY_BUFFER_STARTING,
[build]   	OBS_FRONTEND_EVENT_REPLAY_BUFFER_STARTED,
[build]   	OBS_FRONTEND_EVENT_REPLAY_BUFFER_STOPPING,
[build]   	OBS_FRONTEND_EVENT_REPLAY_BUFFER_STOPPED,
[build]   
[build]   	OBS_FRONTEND_EVENT_STUDIO_MODE_ENABLED,
[build]   	OBS_FRONTEND_EVENT_STUDIO_MODE_DISABLED,
[build]   	OBS_FRONTEND_EVENT_PREVIEW_SCENE_CHANGED,
[build]   
[build]   	OBS_FRONTEND_EVENT_SCENE_COLLECTION_CLEANUP,
[build]   	OBS_FRONTEND_EVENT_FINISHED_LOADING,
[build]   
[build]   	OBS_FRONTEND_EVENT_RECORDING_PAUSED,
[build]   	OBS_FRONTEND_EVENT_RECORDING_UNPAUSED,
[build]   
[build]   	OBS_FRONTEND_EVENT_TRANSITION_DURATION_CHANGED,
[build]   	OBS_FRONTEND_EVENT_REPLAY_BUFFER_SAVED,
[build]   };
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   
[build]   /* NOTE: Functions that return char** string lists are a single allocation of
[build]    * memory with pointers to itself.  Free with a single call to bfree on the
[build]    * base char** pointer. */
[build]   
[build]   /* NOTE: User interface should not use typical Qt locale translation methods,
[build]    * as the OBS UI bypasses it to use a custom translation implementation.  Use
[build]    * standard module translation methods, obs_module_text.  For text in a Qt
[build]    * window, use obs_frontend_push_ui_translation when the text is about to be
[build]    * translated, and obs_frontend_pop_ui_translation when translation is
[build]    * complete. */
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]   
[build]    void obs_frontend_streaming_start(void);
[build]    void obs_frontend_streaming_stop(void);
[build]    bool obs_frontend_streaming_active(void);
[build]   
[build]    void obs_frontend_recording_start(void);
[build]    void obs_frontend_recording_stop(void);
[build]    bool obs_frontend_recording_active(void);
[build]    void obs_frontend_recording_pause(bool pause);
[build]    bool obs_frontend_recording_paused(void);
[build]   
[build]    void obs_frontend_replay_buffer_start(void);
[build]    void obs_frontend_replay_buffer_save(void);
[build]    void obs_frontend_replay_buffer_stop(void);
[build]    bool obs_frontend_replay_buffer_active(void);
[build]   
[build]    void obs_frontend_open_projector(const char *type, int monitor,
[build]   					const char *geometry, const char *name);
[build]    void obs_frontend_save(void);
[build]    void obs_frontend_defer_save_begin(void);
[build]    void obs_frontend_defer_save_end(void);
[build]   
[build]    obs_output_t *obs_frontend_get_streaming_output(void);
[build]    obs_output_t *obs_frontend_get_recording_output(void);
[build]    obs_output_t *obs_frontend_get_replay_buffer_output(void);
[build]   
[build]    config_t *obs_frontend_get_profile_config(void);
[build]    config_t *obs_frontend_get_global_config(void);
[build]   
[build]    void obs_frontend_set_streaming_service(obs_service_t *service);
[build]    obs_service_t *obs_frontend_get_streaming_service(void);
[build]    void obs_frontend_save_streaming_service(void);
[build]   
[build]    bool obs_frontend_preview_program_mode_active(void);
[build]    void obs_frontend_set_preview_program_mode(bool enable);
[build]    void obs_frontend_preview_program_trigger_transition(void);
[build]   
[build]    void obs_frontend_set_preview_enabled(bool enable);
[build]    bool obs_frontend_preview_enabled(void);
[build]   
[build]    obs_source_t *obs_frontend_get_current_preview_scene(void);
[build]    void obs_frontend_set_current_preview_scene(obs_source_t *scene);
[build]   
[build]    void obs_frontend_take_screenshot(void);
[build]    void obs_frontend_take_source_screenshot(obs_source_t *source);
[build]   
[build]   /* ------------------------------------------------------------------------- */
[build]   
[build]   
[build]   
[build]   
[build]   %endoffile
[build]   
[build]   
[build]   /* declare these manually because mutex + GIL = deadlocks */
[build]   %feature("nothread","0");
[build]   void obs_enter_graphics(void); //Should only block on entering mutex
[build]   %feature("nothread");
[build]   
[build]   %endoffile
[build] La build s'est acheve avec le code de sortie 1
