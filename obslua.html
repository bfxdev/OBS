<html>
  <header>
    <title>Documentation obslua module</title>
  </header>
  <body>
    <h1 style="text-align:center">obslua module</h1>
    <h2>Constants</h2>
    <p>
      ARCH_BITS : 32</br>
      BUILD_CAPTIONS : 1</br>
      CALL_PARAM_IN : 1</br>
      CALL_PARAM_OUT : 2</br>
      CALL_PARAM_TYPE_BOOL : 3</br>
      CALL_PARAM_TYPE_FLOAT : 2</br>
      CALL_PARAM_TYPE_INT : 1</br>
      CALL_PARAM_TYPE_PTR : 4</br>
      CALL_PARAM_TYPE_STRING : 5</br>
      CALL_PARAM_TYPE_VOID : 0</br>
      COMPILE_LUA : 1</br>
      COMPILE_PYTHON : 1</br>
      FALSE : 0</br>
      FILE_LINE : "D:/obs2/libobs\\util\\base.h (36): "</br>
      GS_A8 : 1</br>
      GS_ADDRESS_BORDER : 3</br>
      GS_ADDRESS_CLAMP : 0</br>
      GS_ADDRESS_MIRROR : 2</br>
      GS_ADDRESS_MIRRORONCE : 4</br>
      GS_ADDRESS_WRAP : 1</br>
      GS_ALWAYS : 7</br>
      GS_BACK : 0</br>
      GS_BGRA : 5</br>
      GS_BGRX : 4</br>
      GS_BLEND_DSTALPHA : 8</br>
      GS_BLEND_DSTCOLOR : 6</br>
      GS_BLEND_INVDSTALPHA : 9</br>
      GS_BLEND_INVDSTCOLOR : 7</br>
      GS_BLEND_INVSRCALPHA : 5</br>
      GS_BLEND_INVSRCCOLOR : 3</br>
      GS_BLEND_ONE : 1</br>
      GS_BLEND_SRCALPHA : 4</br>
      GS_BLEND_SRCALPHASAT : 10</br>
      GS_BLEND_SRCCOLOR : 2</br>
      GS_BLEND_ZERO : 0</br>
      GS_BUILD_MIPMAPS : 1</br>
      GS_CLEAR_COLOR : 1</br>
      GS_CLEAR_DEPTH : 2</br>
      GS_CLEAR_STENCIL : 4</br>
      GS_DECR : 4</br>
      GS_DEVICE_DIRECT3D_11 : 2</br>
      GS_DEVICE_OPENGL : 1</br>
      GS_DUP_BUFFER : 16</br>
      GS_DXT1 : 15</br>
      GS_DXT3 : 16</br>
      GS_DXT5 : 17</br>
      GS_DYNAMIC : 2</br>
      GS_EQUAL : 3</br>
      GS_ERROR_FAIL : -1</br>
      GS_ERROR_MODULE_NOT_FOUND : -2</br>
      GS_ERROR_NOT_SUPPORTED : -3</br>
      GS_FILTER_ANISOTROPIC : 2</br>
      GS_FILTER_LINEAR : 1</br>
      GS_FILTER_MIN_LINEAR_MAG_MIP_POINT : 6</br>
      GS_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR : 7</br>
      GS_FILTER_MIN_MAG_LINEAR_MIP_POINT : 8</br>
      GS_FILTER_MIN_MAG_POINT_MIP_LINEAR : 3</br>
      GS_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT : 4</br>
      GS_FILTER_MIN_POINT_MAG_MIP_LINEAR : 5</br>
      GS_FILTER_POINT : 0</br>
      GS_FLIP_U : 1</br>
      GS_FLIP_V : 2</br>
      GS_FRONT : 1</br>
      GS_GEQUAL : 4</br>
      GS_GL_DUMMYTEX : 8</br>
      GS_GREATER : 5</br>
      GS_INCR : 3</br>
      GS_INVERT : 5</br>
      GS_KEEP : 0</br>
      GS_LEQUAL : 2</br>
      GS_LESS : 1</br>
      GS_LINES : 1</br>
      GS_LINESTRIP : 2</br>
      GS_MAX_TEXTURES : 8</br>
      GS_NEGATIVE_X : 1</br>
      GS_NEGATIVE_Y : 3</br>
      GS_NEGATIVE_Z : 5</br>
      GS_NEITHER : 2</br>
      GS_NEVER : 0</br>
      GS_NOTEQUAL : 6</br>
      GS_POINTS : 0</br>
      GS_POSITIVE_X : 0</br>
      GS_POSITIVE_Y : 2</br>
      GS_POSITIVE_Z : 4</br>
      GS_R10G10B10A2 : 6</br>
      GS_R16 : 8</br>
      GS_R16F : 13</br>
      GS_R32F : 14</br>
      GS_R8 : 2</br>
      GS_R8G8 : 18</br>
      GS_RENDER_TARGET : 4</br>
      GS_REPLACE : 2</br>
      GS_RG16F : 11</br>
      GS_RG32F : 12</br>
      GS_RGBA : 3</br>
      GS_RGBA16 : 7</br>
      GS_RGBA16F : 9</br>
      GS_RGBA32F : 10</br>
      GS_SHADER_PARAM_BOOL : 1</br>
      GS_SHADER_PARAM_FLOAT : 2</br>
      GS_SHADER_PARAM_INT : 3</br>
      GS_SHADER_PARAM_INT2 : 8</br>
      GS_SHADER_PARAM_INT3 : 9</br>
      GS_SHADER_PARAM_INT4 : 10</br>
      GS_SHADER_PARAM_MATRIX4X4 : 11</br>
      GS_SHADER_PARAM_STRING : 4</br>
      GS_SHADER_PARAM_TEXTURE : 12</br>
      GS_SHADER_PARAM_UNKNOWN : 0</br>
      GS_SHADER_PARAM_VEC2 : 5</br>
      GS_SHADER_PARAM_VEC3 : 6</br>
      GS_SHADER_PARAM_VEC4 : 7</br>
      GS_SHARED_KM_TEX : 64</br>
      GS_SHARED_TEX : 32</br>
      GS_STENCIL_BACK : 2</br>
      GS_STENCIL_BOTH : 3</br>
      GS_STENCIL_FRONT : 1</br>
      GS_SUCCESS : 0</br>
      GS_TEXTURE_2D : 0</br>
      GS_TEXTURE_3D : 1</br>
      GS_TEXTURE_CUBE : 2</br>
      GS_TRIS : 3</br>
      GS_TRISTRIP : 4</br>
      GS_UNKNOWN : 0</br>
      GS_UNSIGNED_LONG : 1</br>
      GS_UNSIGNED_SHORT : 0</br>
      GS_USE_DEBUG_MARKERS : 0</br>
      GS_Z16 : 1</br>
      GS_Z24_S8 : 2</br>
      GS_Z32F : 3</br>
      GS_Z32F_S8X24 : 4</br>
      GS_ZERO : 1</br>
      GS_ZS_NONE : 0</br>
      INTERACT_ALT_KEY : 8</br>
      INTERACT_CAPS_KEY : 1</br>
      INTERACT_COMMAND_KEY : 128</br>
      INTERACT_CONTROL_KEY : 4</br>
      INTERACT_IS_KEY_PAD : 512</br>
      INTERACT_IS_LEFT : 1024</br>
      INTERACT_IS_RIGHT : 2048</br>
      INTERACT_MOUSE_LEFT : 16</br>
      INTERACT_MOUSE_MIDDLE : 32</br>
      INTERACT_MOUSE_RIGHT : 64</br>
      INTERACT_NONE : 0</br>
      INTERACT_NUMLOCK_KEY : 256</br>
      INTERACT_SHIFT_KEY : 2</br>
      INT_CUR_LINE : 35</br>
      LOG_DEBUG : 400</br>
      LOG_ERROR : 100</br>
      LOG_INFO : 300</br>
      LOG_WARNING : 200</br>
      MKDIR_ERROR : -1</br>
      MKDIR_EXISTS : 1</br>
      MKDIR_SUCCESS : 0</br>
      MOUSE_LEFT : 0</br>
      MOUSE_MIDDLE : 1</br>
      MOUSE_RIGHT : 2</br>
      OBS_ALLOW_DIRECT_RENDERING : 1</br>
      OBS_BALANCE_TYPE_LINEAR : 2</br>
      OBS_BALANCE_TYPE_SINE_LAW : 0</br>
      OBS_BALANCE_TYPE_SQUARE_LAW : 1</br>
      OBS_BOUNDS_MAX_ONLY : 6</br>
      OBS_BOUNDS_NONE : 0</br>
      OBS_BOUNDS_SCALE_INNER : 2</br>
      OBS_BOUNDS_SCALE_OUTER : 3</br>
      OBS_BOUNDS_SCALE_TO_HEIGHT : 5</br>
      OBS_BOUNDS_SCALE_TO_WIDTH : 4</br>
      OBS_BOUNDS_STRETCH : 1</br>
      OBS_COMBO_FORMAT_FLOAT : 2</br>
      OBS_COMBO_FORMAT_INT : 1</br>
      OBS_COMBO_FORMAT_INVALID : 0</br>
      OBS_COMBO_FORMAT_STRING : 3</br>
      OBS_COMBO_INVALID : 0</br>
      OBS_COMBO_TYPE_EDITABLE : 1</br>
      OBS_COMBO_TYPE_INVALID : 0</br>
      OBS_COMBO_TYPE_LIST : 2</br>
      OBS_DATA_ARRAY : 5</br>
      OBS_DATA_BOOLEAN : 3</br>
      OBS_DATA_NULL : 0</br>
      OBS_DATA_NUMBER : 2</br>
      OBS_DATA_NUM_DOUBLE : 2</br>
      OBS_DATA_NUM_INT : 1</br>
      OBS_DATA_NUM_INVALID : 0</br>
      OBS_DATA_OBJECT : 4</br>
      OBS_DATA_STRING : 1</br>
      OBS_DEINTERLACE_FIELD_ORDER_BOTTOM : 1</br>
      OBS_DEINTERLACE_FIELD_ORDER_TOP : 0</br>
      OBS_DEINTERLACE_MODE_BLEND : 3</br>
      OBS_DEINTERLACE_MODE_BLEND_2X : 4</br>
      OBS_DEINTERLACE_MODE_DISABLE : 0</br>
      OBS_DEINTERLACE_MODE_DISCARD : 1</br>
      OBS_DEINTERLACE_MODE_LINEAR : 5</br>
      OBS_DEINTERLACE_MODE_LINEAR_2X : 6</br>
      OBS_DEINTERLACE_MODE_RETRO : 2</br>
      OBS_DEINTERLACE_MODE_YADIF : 7</br>
      OBS_DEINTERLACE_MODE_YADIF_2X : 8</br>
      OBS_EDITABLE_LIST_TYPE_FILES : 1</br>
      OBS_EDITABLE_LIST_TYPE_FILES_AND_URLS : 2</br>
      OBS_EDITABLE_LIST_TYPE_STRINGS : 0</br>
      OBS_EFFECT_AREA : 9</br>
      OBS_EFFECT_BICUBIC : 4</br>
      OBS_EFFECT_BILINEAR_LOWRES : 6</br>
      OBS_EFFECT_DEFAULT : 0</br>
      OBS_EFFECT_DEFAULT_RECT : 1</br>
      OBS_EFFECT_LANCZOS : 5</br>
      OBS_EFFECT_OPAQUE : 2</br>
      OBS_EFFECT_PREMULTIPLIED_ALPHA : 7</br>
      OBS_EFFECT_REPEAT : 8</br>
      OBS_EFFECT_SOLID : 3</br>
      OBS_FONT_BOLD : 1</br>
      OBS_FONT_ITALIC : 2</br>
      OBS_FONT_STRIKEOUT : 8</br>
      OBS_FONT_UNDERLINE : 4</br>
      OBS_FRONTEND_EVENT_EXIT : 17</br>
      OBS_FRONTEND_EVENT_FINISHED_LOADING : 26</br>
      OBS_FRONTEND_EVENT_PREVIEW_SCENE_CHANGED : 24</br>
      OBS_FRONTEND_EVENT_PROFILE_CHANGED : 15</br>
      OBS_FRONTEND_EVENT_PROFILE_LIST_CHANGED : 16</br>
      OBS_FRONTEND_EVENT_RECORDING_PAUSED : 27</br>
      OBS_FRONTEND_EVENT_RECORDING_STARTED : 5</br>
      OBS_FRONTEND_EVENT_RECORDING_STARTING : 4</br>
      OBS_FRONTEND_EVENT_RECORDING_STOPPED : 7</br>
      OBS_FRONTEND_EVENT_RECORDING_STOPPING : 6</br>
      OBS_FRONTEND_EVENT_RECORDING_UNPAUSED : 28</br>
      OBS_FRONTEND_EVENT_REPLAY_BUFFER_STARTED : 19</br>
      OBS_FRONTEND_EVENT_REPLAY_BUFFER_STARTING : 18</br>
      OBS_FRONTEND_EVENT_REPLAY_BUFFER_STOPPED : 21</br>
      OBS_FRONTEND_EVENT_REPLAY_BUFFER_STOPPING : 20</br>
      OBS_FRONTEND_EVENT_SCENE_CHANGED : 8</br>
      OBS_FRONTEND_EVENT_SCENE_COLLECTION_CHANGED : 13</br>
      OBS_FRONTEND_EVENT_SCENE_COLLECTION_CLEANUP : 25</br>
      OBS_FRONTEND_EVENT_SCENE_COLLECTION_LIST_CHANGED : 14</br>
      OBS_FRONTEND_EVENT_SCENE_LIST_CHANGED : 9</br>
      OBS_FRONTEND_EVENT_STREAMING_STARTED : 1</br>
      OBS_FRONTEND_EVENT_STREAMING_STARTING : 0</br>
      OBS_FRONTEND_EVENT_STREAMING_STOPPED : 3</br>
      OBS_FRONTEND_EVENT_STREAMING_STOPPING : 2</br>
      OBS_FRONTEND_EVENT_STUDIO_MODE_DISABLED : 23</br>
      OBS_FRONTEND_EVENT_STUDIO_MODE_ENABLED : 22</br>
      OBS_FRONTEND_EVENT_TRANSITION_CHANGED : 10</br>
      OBS_FRONTEND_EVENT_TRANSITION_DURATION_CHANGED : 29</br>
      OBS_FRONTEND_EVENT_TRANSITION_LIST_CHANGED : 12</br>
      OBS_FRONTEND_EVENT_TRANSITION_STOPPED : 11</br>
      OBS_GROUP_CHECKABLE : 2</br>
      OBS_GROUP_NORMAL : 1</br>
      OBS_HOTKEY_REGISTERER_ENCODER : 3</br>
      OBS_HOTKEY_REGISTERER_FRONTEND : 0</br>
      OBS_HOTKEY_REGISTERER_OUTPUT : 2</br>
      OBS_HOTKEY_REGISTERER_SERVICE : 4</br>
      OBS_HOTKEY_REGISTERER_SOURCE : 1</br>
      OBS_ICON_TYPE_AUDIO_INPUT : 4</br>
      OBS_ICON_TYPE_AUDIO_OUTPUT : 5</br>
      OBS_ICON_TYPE_BROWSER : 12</br>
      OBS_ICON_TYPE_CAMERA : 9</br>
      OBS_ICON_TYPE_COLOR : 2</br>
      OBS_ICON_TYPE_CUSTOM : 13</br>
      OBS_ICON_TYPE_DESKTOP_CAPTURE : 6</br>
      OBS_ICON_TYPE_GAME_CAPTURE : 8</br>
      OBS_ICON_TYPE_IMAGE : 1</br>
      OBS_ICON_TYPE_MEDIA : 11</br>
      OBS_ICON_TYPE_SLIDESHOW : 3</br>
      OBS_ICON_TYPE_TEXT : 10</br>
      OBS_ICON_TYPE_UNKNOWN : 0</br>
      OBS_ICON_TYPE_WINDOW_CAPTURE : 7</br>
      OBS_KEY_LAST_VALUE : 636</br>
      OBS_MEDIA_STATE_BUFFERING : 3</br>
      OBS_MEDIA_STATE_ENDED : 6</br>
      OBS_MEDIA_STATE_ERROR : 7</br>
      OBS_MEDIA_STATE_NONE : 0</br>
      OBS_MEDIA_STATE_OPENING : 2</br>
      OBS_MEDIA_STATE_PAUSED : 4</br>
      OBS_MEDIA_STATE_PLAYING : 1</br>
      OBS_MEDIA_STATE_STOPPED : 5</br>
      OBS_MONITORING_TYPE_MONITOR_AND_OUTPUT : 2</br>
      OBS_MONITORING_TYPE_MONITOR_ONLY : 1</br>
      OBS_MONITORING_TYPE_NONE : 0</br>
      OBS_NO_DIRECT_RENDERING : 0</br>
      OBS_NUMBER_SCROLLER : 0</br>
      OBS_NUMBER_SLIDER : 1</br>
      OBS_OBJ_TYPE_ENCODER : 3</br>
      OBS_OBJ_TYPE_INVALID : 0</br>
      OBS_OBJ_TYPE_OUTPUT : 2</br>
      OBS_OBJ_TYPE_SERVICE : 4</br>
      OBS_OBJ_TYPE_SOURCE : 1</br>
      OBS_ORDER_MOVE_BOTTOM : 3</br>
      OBS_ORDER_MOVE_DOWN : 1</br>
      OBS_ORDER_MOVE_TOP : 2</br>
      OBS_ORDER_MOVE_UP : 0</br>
      OBS_OUTPUT_DELAY_PRESERVE : 1</br>
      OBS_PATH_DIRECTORY : 2</br>
      OBS_PATH_FILE : 0</br>
      OBS_PATH_FILE_SAVE : 1</br>
      OBS_PROPERTIES_DEFER_UPDATE : 1</br>
      OBS_PROPERTY_BOOL : 1</br>
      OBS_PROPERTY_BUTTON : 8</br>
      OBS_PROPERTY_COLOR : 7</br>
      OBS_PROPERTY_EDITABLE_LIST : 10</br>
      OBS_PROPERTY_FLOAT : 3</br>
      OBS_PROPERTY_FONT : 9</br>
      OBS_PROPERTY_FRAME_RATE : 11</br>
      OBS_PROPERTY_GROUP : 12</br>
      OBS_PROPERTY_INT : 2</br>
      OBS_PROPERTY_INVALID : 0</br>
      OBS_PROPERTY_LIST : 6</br>
      OBS_PROPERTY_PATH : 5</br>
      OBS_PROPERTY_TEXT : 4</br>
      OBS_SCALE_AREA : 5</br>
      OBS_SCALE_BICUBIC : 2</br>
      OBS_SCALE_BILINEAR : 3</br>
      OBS_SCALE_DISABLE : 0</br>
      OBS_SCALE_LANCZOS : 4</br>
      OBS_SCALE_POINT : 1</br>
      OBS_SCENE_DUP_COPY : 1</br>
      OBS_SCENE_DUP_PRIVATE_COPY : 3</br>
      OBS_SCENE_DUP_PRIVATE_REFS : 2</br>
      OBS_SCENE_DUP_REFS : 0</br>
      OBS_SOURCE_ASYNC : 4</br>
      OBS_SOURCE_ASYNC_VIDEO : 5</br>
      OBS_SOURCE_AUDIO : 2</br>
      OBS_SOURCE_CAP_DISABLED : 1024</br>
      OBS_SOURCE_CAP_OBSOLETE : 1024</br>
      OBS_SOURCE_COMPOSITE : 64</br>
      OBS_SOURCE_CONTROLLABLE_MEDIA : 8192</br>
      OBS_SOURCE_CUSTOM_DRAW : 8</br>
      OBS_SOURCE_DEPRECATED : 256</br>
      OBS_SOURCE_DO_NOT_DUPLICATE : 128</br>
      OBS_SOURCE_DO_NOT_SELF_MONITOR : 512</br>
      OBS_SOURCE_FLAG_FORCE_MONO : 2</br>
      OBS_SOURCE_FLAG_UNUSED_1 : 1</br>
      OBS_SOURCE_INTERACTION : 32</br>
      OBS_SOURCE_MONITOR_BY_DEFAULT : 2048</br>
      OBS_SOURCE_SUBMIX : 4096</br>
      OBS_SOURCE_TYPE_FILTER : 1</br>
      OBS_SOURCE_TYPE_INPUT : 0</br>
      OBS_SOURCE_TYPE_SCENE : 3</br>
      OBS_SOURCE_TYPE_TRANSITION : 2</br>
      OBS_SOURCE_VIDEO : 1</br>
      OBS_TASK_GRAPHICS : 1</br>
      OBS_TASK_UI : 0</br>
      OBS_TEXT_DEFAULT : 0</br>
      OBS_TEXT_MULTILINE : 2</br>
      OBS_TEXT_PASSWORD : 1</br>
      OBS_TRANSITION_MODE_AUTO : 0</br>
      OBS_TRANSITION_MODE_MANUAL : 1</br>
      OBS_TRANSITION_SCALE_ASPECT : 1</br>
      OBS_TRANSITION_SCALE_MAX_ONLY : 0</br>
      OBS_TRANSITION_SCALE_STRETCH : 2</br>
      OBS_TRANSITION_SOURCE_A : 0</br>
      OBS_TRANSITION_SOURCE_B : 1</br>
      OFF : 0</br>
      ON : 1</br>
      PYTHON_LIB : "python36"</br>
      SCRIPT_DIR : "../../data/obs-scripting/64bit"</br>
      S__LINE__ : "33"</br>
      TRUE : 1</br>
      UI_ENABLED : 1</br>
      XINPUT_MOUSE_LEN : 33</br>
    </p>
    <h2>Functions</h2>
    <hr/><h3>base_get_alignment()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>base_get_log_handler(handler, param)</h3>
    <pre>
    Sets/gets the current log handler.
    
    </pre>
    <p>handler : p_f_int_p_q_const__char_va_list_p_void__void</p>
    <p>param : p_void</p>
    <p><pre>void base_get_log_handler(log_handler_t *handler, void **param)</pre></p>
    <hr/><h3>base_set_allocator(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : base_allocator</p>
    <hr/><h3>base_set_crash_handler(handler, param)</h3>
    <pre>
    Sets the current crash handler.
    
    </pre>
    <p>handler : f_p_q_const__char_va_list_p_void__void</p>
    <p>param : ref_void*</p>
    <p><pre>void base_set_crash_handler(void (*handler)(const char *, va_list, void *), void *param)</pre></p>
    <hr/><h3>base_set_log_handler(handler, param)</h3>
    <pre>
    Sets/gets the current log handler.
    
    </pre>
    <p>handler : f_int_p_q_const__char_va_list_p_void__void</p>
    <p>param : ref_void*</p>
    <p><pre>void base_set_log_handler(log_handler_t handler, void *param)</pre></p>
    <hr/><h3>bfree(ptr)</h3>
    <pre>
    Frees memory allocated with :c:func:`bmalloc()` or :c:func:`bfree()`.
    
    </pre>
    <p>ptr : ref_void*</p>
    <p><pre>void bfree(void *ptr)</pre></p>
    <hr/><h3>blog(log_level, format)</h3>
    <pre>
    Logging function.
    
    </pre>
    <p>log_level : int</p>
    <p>format : char*</p>
    <p><pre>void blog(int log_level, const char *format, ...)</pre></p>
    <hr/><h3>bmalloc(size)</h3>
    <pre>
    Allocates memory and increases the memory leak counter.
    
    </pre>
    <p>size : number</p>
    <p>Return : void</p>
    <p><pre>void *bmalloc(size_t size)</pre></p>
    <hr/><h3>bmemdup(ptr, size)</h3>
    <pre>
    Duplicates memory.
    
    </pre>
    <p>ptr : ref_void*</p>
    <p>size : number</p>
    <p>Return : void</p>
    <p><pre>void *bmemdup(const void *ptr, size_t size)</pre></p>
    <hr/><h3>bnum_allocs()</h3>
    <pre>
    Returns current number of active allocations.
    
    </pre>
    <p>Return : number</p>
    <p><pre>long bnum_allocs(void)</pre></p>
    <hr/><h3>brealloc(ptr, size)</h3>
    <pre>
    Reallocates memory.  Use only with memory that's been allocated by
    :c:func:`bmalloc()`.
    
    </pre>
    <p>ptr : ref_void*</p>
    <p>size : number</p>
    <p>Return : void</p>
    <p><pre>void *brealloc(void *ptr, size_t size)</pre></p>
    <hr/><h3>bstrdup(str)</h3>
    <pre>
    Duplicates a string.
    </pre>
    <p>str : string</p>
    <p>Return : string</p>
    <p><pre>char *bstrdup(const char *str)</pre></p>
    <hr/><h3>bstrdup_n(str, n)</h3>
    <pre>
    Duplicates a string of *n* bytes and automatically zero-terminates
    it.
    
    </pre>
    <p>str : string</p>
    <p>n : number</p>
    <p>Return : string</p>
    <p><pre>char *bstrdup_n(const char *str, size_t n)</pre></p>
    <hr/><h3>bwstrdup(str)</h3>
    <pre>
    Duplicates a string.
    </pre>
    <p>str : wchar_t</p>
    <p>Return : wchar_t</p>
    <p><pre>wchar_t *bwstrdup(const wchar_t *str)</pre></p>
    <hr/><h3>bwstrdup_n(str, n)</h3>
    <pre>
    Duplicates a string of *n* bytes and automatically zero-terminates
    it.
    
    </pre>
    <p>str : wchar_t</p>
    <p>n : number</p>
    <p>Return : wchar_t</p>
    <p><pre>wchar_t *bwstrdup_n(const wchar_t *str, size_t n)</pre></p>
    <hr/><h3>bzalloc(size)</h3>
    <pre>
    Inline function that allocates zeroed memory.
    
    </pre>
    <p>size : number</p>
    <p>Return : void</p>
    <p><pre>void *bzalloc(size_t size)</pre></p>
    <hr/><h3>calldata_bool(data, name)</h3>
    <pre>
    Gets a boolean parameter.
    
    :param data: Calldata structure
    :param name: Parameter name
    :return:     Boolean value
    
    </pre>
    <p>data : calldata</p>
    <p>name : string</p>
    <p>Return : boolean</p>
    <p><pre>bool calldata_bool(const calldata_t *data, const char *name)</pre></p>
    <hr/><h3>calldata_clear(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : calldata</p>
    <hr/><h3>calldata_create()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>calldata_destroy(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : calldata</p>
    <hr/><h3>calldata_float(data, name)</h3>
    <pre>
    Gets a floating point parameter.
    
    :param data: Calldata structure
    :param name: Parameter name
    :return:     Floating point value
    
    </pre>
    <p>data : calldata</p>
    <p>name : string</p>
    <p>Return : number</p>
    <p><pre>double calldata_float(const calldata_t *data, const char *name)</pre></p>
    <hr/><h3>calldata_free(data)</h3>
    <pre>
    Frees a calldata structure.
    
    :param data: Calldata structure
    
    </pre>
    <p>data : calldata</p>
    <p><pre>void calldata_free(calldata_t *data)</pre></p>
    <hr/><h3>calldata_get_bool(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : calldata</p>
    <p>param2 : string</p>
    <p>param3 : bool</p>
    <hr/><h3>calldata_get_data(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : calldata</p>
    <p>param2 : string</p>
    <p>param3 : ref_void*</p>
    <p>param4 : number</p>
    <hr/><h3>calldata_get_float(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : calldata</p>
    <p>param2 : string</p>
    <p>param3 : double</p>
    <hr/><h3>calldata_get_int(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : calldata</p>
    <p>param2 : string</p>
    <p>param3 : long_long</p>
    <hr/><h3>calldata_get_ptr(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : calldata</p>
    <p>param2 : string</p>
    <p>param3 : ref_void*</p>
    <hr/><h3>calldata_get_string(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : calldata</p>
    <p>param2 : string</p>
    <p>param3 : p_char</p>
    <hr/><h3>calldata_init(data)</h3>
    <pre>
    Initializes a calldata structure (zeroes it).
    
    :param data: Calldata structure
    
    </pre>
    <p>data : calldata</p>
    <p><pre>void calldata_init(calldata_t *data)</pre></p>
    <hr/><h3>calldata_init_fixed(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : calldata</p>
    <p>param2 : unsigned_char</p>
    <p>param3 : number</p>
    <hr/><h3>calldata_int(data, name)</h3>
    <pre>
    Gets an integer parameter.
    
    :param data: Calldata structure
    :param name: Parameter name
    :return:     Integer value
    
    </pre>
    <p>data : calldata</p>
    <p>name : string</p>
    <p>Return : number</p>
    <p><pre>long long calldata_int(const calldata_t *data, const char *name)</pre></p>
    <hr/><h3>calldata_ptr(data, name)</h3>
    <pre>
    Gets a pointer parameter.
    
    :param data: Calldata structure
    :param name: Parameter name
    :return:     Pointer value
    
    </pre>
    <p>data : calldata</p>
    <p>name : string</p>
    <p>Return : void</p>
    <p><pre>void *calldata_ptr(const calldata_t *data, const char *name)</pre></p>
    <hr/><h3>calldata_sceneitem(calldata, name)</h3>
    <pre>
    Casts a pointer parameter of a calldata_t object to an
    obs_sceneitem_t object.
    
    :param calldata: A calldata_t object.
    :param name:     Name of the parameter.
    :return:         A borrowed reference to an obs_sceneitem_t object.
    </pre>
    <p>calldata : unknown</p>
    <p>name : unknown</p>
    <p>Return : unknown</p>
    <hr/><h3>calldata_set_bool(data, name, val)</h3>
    <pre>
    Sets a boolean parameter.
    
    :param data: Calldata structure
    :param name: Parameter name
    :param val:  Boolean value
    
    </pre>
    <p>data : calldata</p>
    <p>name : string</p>
    <p>val : boolean</p>
    <p><pre>void calldata_set_bool(calldata_t *data, const char *name, bool val)</pre></p>
    <hr/><h3>calldata_set_data(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : calldata</p>
    <p>param2 : string</p>
    <p>param3 : ref_void*</p>
    <p>param4 : number</p>
    <hr/><h3>calldata_set_float(data, name, val)</h3>
    <pre>
    Sets a floating point parameter.
    
    :param data: Calldata structure
    :param name: Parameter name
    :param val:  Floating point value
    
    </pre>
    <p>data : calldata</p>
    <p>name : string</p>
    <p>val : number</p>
    <p><pre>void calldata_set_float(calldata_t *data, const char *name, double val)</pre></p>
    <hr/><h3>calldata_set_int(data, name, val)</h3>
    <pre>
    Sets an integer parameter.
    
    :param data: Calldata structure
    :param name: Parameter name
    :param val:  Integer value
    
    </pre>
    <p>data : calldata</p>
    <p>name : string</p>
    <p>val : number</p>
    <p><pre>void calldata_set_int(calldata_t *data, const char *name, long long val)</pre></p>
    <hr/><h3>calldata_set_ptr(data, name, ptr)</h3>
    <pre>
    Sets a pointer parameter.
    
    :param data: Calldata structure
    :param name: Parameter name
    :param val:  Pointer value
    
    </pre>
    <p>data : calldata</p>
    <p>name : string</p>
    <p>ptr : ref_void*</p>
    <p><pre>void calldata_set_ptr(calldata_t *data, const char *name, void *ptr)</pre></p>
    <hr/><h3>calldata_set_string(data, name, str)</h3>
    <pre>
    Sets a string parameter.
    
    :param data: Calldata structure
    :param name: Parameter name
    :param val:  String
    
    </pre>
    <p>data : calldata</p>
    <p>name : string</p>
    <p>str : string</p>
    <p><pre>void calldata_set_string(calldata_t *data, const char *name, const char *str)</pre></p>
    <hr/><h3>calldata_source(calldata, name)</h3>
    <pre>
    Casts a pointer parameter of a calldata_t object to an obs_source_t
    object.
    
    :param calldata: A calldata_t object.
    :param name:     Name of the parameter.
    :return:         A borrowed reference to an obs_source_t object.
    
    </pre>
    <p>calldata : unknown</p>
    <p>name : unknown</p>
    <p>Return : unknown</p>
    <hr/><h3>calldata_string(data, name)</h3>
    <pre>
    Gets a string parameter.
    
    :param data: Calldata structure
    :param name: Parameter name
    :return:     String value
    
    </pre>
    <p>data : calldata</p>
    <p>name : string</p>
    <p>Return : string</p>
    <p><pre>const char *calldata_string(const calldata_t *data, const char *name)</pre></p>
    <hr/><h3>gs_begin_frame()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>gs_begin_scene()</h3>
    <pre>
    Begins/ends a scene (this is automatically called by libobs, there's
    no need to call this manually).
    
    </pre>
    <p><pre>void gs_begin_scene(void)</pre></p>
    <hr/><h3>gs_blend_function(src, dest)</h3>
    <pre>
    Sets the blend function
    
    :param src:  Blend type for the source
    :param dest: Blend type for the destination
    
    </pre>
    <p>src : number</p>
    <p>dest : number</p>
    <p><pre>void gs_blend_function(enum gs_blend_type src, enum gs_blend_type dest)</pre></p>
    <hr/><h3>gs_blend_function_separate(src_c, dest_c, src_a, dest_a)</h3>
    <pre>
    Sets the blend function for RGB and alpha separately
    
    :param src_c:  Blend type for the source RGB
    :param dest_c: Blend type for the destination RGB
    :param src_a:  Blend type for the source alpha
    :param dest_a: Blend type for the destination alpha
    
    </pre>
    <p>src_c : number</p>
    <p>dest_c : number</p>
    <p>src_a : number</p>
    <p>dest_a : number</p>
    <p><pre>void gs_blend_function_separate(enum gs_blend_type src_c, enum gs_blend_type dest_c, enum gs_blend_type src_a, enum gs_blend_type dest_a)</pre></p>
    <hr/><h3>gs_blend_state_pop()</h3>
    <pre>
    Pops/restores the last blend state
    
    </pre>
    <p><pre>void gs_blend_state_pop(void)</pre></p>
    <hr/><h3>gs_blend_state_push()</h3>
    <pre>
    Pushes/stores the current blend state
    
    </pre>
    <p><pre>void gs_blend_state_push(void)</pre></p>
    <hr/><h3>gs_clear(clear_flags, color, depth, stencil)</h3>
    <pre>
    Clears color/depth/stencil buffers.
    
    :param clear_flags: Flags to clear with.  Can be one of the following
                        values:
    
                        - GS_CLEAR_COLOR   - Clears color buffer
                        - GS_CLEAR_DEPTH   - Clears depth buffer
                        - GS_CLEAR_STENCIL - Clears stencil buffer
    
    :param color:       Color value to clear the color buffer with
    :param depth:       Depth value to clear the depth buffer with
    :param stencil:     Stencil value to clear the stencil buffer with
    
    </pre>
    <p>clear_flags : number</p>
    <p>color : vec4</p>
    <p>depth : number</p>
    <p>stencil : number</p>
    <p><pre>void gs_clear(uint32_t clear_flags, const struct vec4 *color, float depth, uint8_t stencil)</pre></p>
    <hr/><h3>gs_color(color)</h3>
    <pre>
    </pre>
    <p>color : number</p>
    <p><pre>void gs_color(uint32_t color)</pre></p>
    <hr/><h3>gs_color4v(v)</h3>
    <pre>
    </pre>
    <p>v : vec4</p>
    <p><pre>void gs_color4v(const struct vec4 *v)</pre></p>
    <hr/><h3>gs_copy_texture(dst, src)</h3>
    <pre>
    Copies a texture
    
    :param dst: Destination texture
    :param src: Source texture
    
    </pre>
    <p>dst : gs_texture</p>
    <p>src : gs_texture</p>
    <p><pre>void gs_copy_texture(gs_texture_t *dst, gs_texture_t *src)</pre></p>
    <hr/><h3>gs_copy_texture_region(param1, param2, param3, param4, param5, param6, param7, param8)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_texture</p>
    <p>param2 : number</p>
    <p>param3 : number</p>
    <p>param4 : gs_texture</p>
    <p>param5 : number</p>
    <p>param6 : number</p>
    <p>param7 : number</p>
    <p>param8 : number</p>
    <hr/><h3>gs_create(graphics, module, adapter)</h3>
    <pre>
    Creates a graphics context
    
    :param graphics: Pointer to receive the graphics context
    :param module:   Module name
    :param adapter:  Adapter index
    :return:         Can return one of the following values:
    
                     - GS_SUCCESS
                     - GS_ERROR_FAIL
                     - GS_ERROR_MODULE_NOT_FOUND
                     - GS_ERROR_NOT_SUPPORTED
    
    </pre>
    <p>graphics : p_graphics_subsystem</p>
    <p>module : string</p>
    <p>adapter : number</p>
    <p>Return : number</p>
    <p><pre>int gs_create(graphics_t **graphics, const char *module, uint32_t adapter)</pre></p>
    <hr/><h3>gs_create_texture_file_data(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <p>param2 : gs_color_format</p>
    <p>param3 : unsigned_int</p>
    <p>param4 : unsigned_int</p>
    <hr/><h3>gs_cubetexture_create(size, color_format, levels, data, flags)</h3>
    <pre>
    Creates a cubemap texture.
    
    :param size:         Width/height/depth value
    :param color_format: Color format
    :param levels:       Number of texture levels
    :param data:         Pointer to array of texture data pointers
    :param flags:        Can be 0 or a bitwise-OR combination of one or
                         more of the following value:
    
                         - GS_BUILD_MIPMAPS - Automatically builds
                           mipmaps (Note: not fully tested)
                         - GS_DYNAMIC - Dynamic
                         - GS_RENDER_TARGET - Render target
    
    :return:             A new cube texture object
    
    </pre>
    <p>size : number</p>
    <p>color_format : number</p>
    <p>levels : number</p>
    <p>data : p_unsigned_char</p>
    <p>flags : number</p>
    <p>Return : gs_texture</p>
    <p><pre>gs_texture_t *gs_cubetexture_create(uint32_t size, enum gs_color_format color_format, uint32_t levels, const uint8_t **data, uint32_t flags)</pre></p>
    <hr/><h3>gs_cubetexture_destroy(cubetex)</h3>
    <pre>
    Destroys a cube texture.
    
    :param cubetex: Cube texture object
    
    </pre>
    <p>cubetex : gs_texture</p>
    <p><pre>void     gs_cubetexture_destroy(gs_texture_t *cubetex)</pre></p>
    <hr/><h3>gs_cubetexture_get_color_format(cubetex)</h3>
    <pre>
    Gets the color format of a cube texture.
    
    :param cubetex: Cube texture object
    :return:        The color format of the cube texture
    
    </pre>
    <p>cubetex : gs_texture</p>
    <p>Return : number</p>
    <p><pre>enum gs_color_format gs_cubetexture_get_color_format(const gs_texture_t *cubetex)</pre></p>
    <hr/><h3>gs_cubetexture_get_size(cubetex)</h3>
    <pre>
    Get the width/height/depth value of a cube texture.
    
    :param cubetex: Cube texture object
    :return:        The width/height/depth value of the cube texture
    
    </pre>
    <p>cubetex : gs_texture</p>
    <p>Return : number</p>
    <p><pre>uint32_t gs_cubetexture_get_size(const gs_texture_t *cubetex)</pre></p>
    <hr/><h3>gs_cubetexture_set_image(cubetex, side, data, linesize, invert)</h3>
    <pre>
    Sets an image of a cube texture side.
    
    :param cubetex:  Cube texture object
    :param side:     Side
    :param data:     Texture data to set
    :param linesize: Line size (pitch) of the texture data
    :param invert:   *true* to invert texture data, *false* otherwise
    
    </pre>
    <p>cubetex : gs_texture</p>
    <p>side : number</p>
    <p>data : ref_void*</p>
    <p>linesize : number</p>
    <p>invert : boolean</p>
    <p><pre>void gs_cubetexture_set_image(gs_texture_t *cubetex, uint32_t side, const void *data, uint32_t linesize, bool invert)</pre></p>
    <hr/><h3>gs_debug_marker_begin(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : float</p>
    <p>param2 : string</p>
    <hr/><h3>gs_debug_marker_begin_format(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : float</p>
    <p>param2 : string</p>
    <hr/><h3>gs_debug_marker_end()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>gs_depth_function(test)</h3>
    <pre>
    Sets the depth function
    
    :param test: Sets the depth test type
    
    </pre>
    <p>test : number</p>
    <p><pre>void gs_depth_function(enum gs_depth_test test)</pre></p>
    <hr/><h3>gs_destroy(graphics)</h3>
    <pre>
    Destroys a graphics context
    
    :param graphics: Graphics context
    
    </pre>
    <p>graphics : graphics_subsystem</p>
    <p><pre>void gs_destroy(graphics_t *graphics)</pre></p>
    <hr/><h3>gs_draw(draw_mode, start_vert, num_verts)</h3>
    <pre>
    Draws a primitive or set of primitives.
    
    :param draw_mode:  The primitive draw mode to use
    :param start_vert: Starting vertex index
    :param num_verts:  Number of vertices
    
    </pre>
    <p>draw_mode : number</p>
    <p>start_vert : number</p>
    <p>num_verts : number</p>
    <p><pre>void gs_draw(enum gs_draw_mode draw_mode, uint32_t start_vert, uint32_t num_verts)</pre></p>
    <hr/><h3>gs_draw_cube_backdrop(param1, param2, param3, param4, param5, param6, param7)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_texture</p>
    <p>param2 : quat</p>
    <p>param3 : number</p>
    <p>param4 : number</p>
    <p>param5 : number</p>
    <p>param6 : number</p>
    <p>param7 : number</p>
    <hr/><h3>gs_draw_sprite(tex, flip, width, height)</h3>
    <pre>
    Draws a 2D sprite.  Sets the "image" parameter of the current effect
    to the texture and renders a quad.
    
    If width or height is 0, the width or height of the texture will be
    used.  The flip value specifies whether the texture should be flipped
    on the U or V axis with GS_FLIP_U and GS_FLIP_V.
    
    :param tex:    Texture to draw
    :param flip:   Can be 0 or a bitwise-OR combination of one of the
                   following values:
    
                   - GS_FLIP_U - Flips the texture horizontally
                   - GS_FLIP_V - Flips the texture vertically
    
    :param width:  Width
    :param height: Height
    
    </pre>
    <p>tex : gs_texture</p>
    <p>flip : number</p>
    <p>width : number</p>
    <p>height : number</p>
    <p><pre>void gs_draw_sprite(gs_texture_t *tex, uint32_t flip, uint32_t width, uint32_t height)</pre></p>
    <hr/><h3>gs_draw_sprite_subregion(tex, flip, x, y, cx, cy)</h3>
    <pre>
    Draws a subregion of a 2D sprite.  Sets the "image" parameter of the
    current effect to the texture and renders a quad.
    
    :param tex:    Texture to draw
    :param flip:   Can be 0 or a bitwise-OR combination of one of the
                   following values:
    
                   - GS_FLIP_U - Flips the texture horizontally
                   - GS_FLIP_V - Flips the texture vertically
    
    :param x:      X value within subregion
    :param y:      Y value within subregion
    :param cx:     CX value of subregion
    :param cy:     CY value of subregion
    
    </pre>
    <p>tex : gs_texture</p>
    <p>flip : number</p>
    <p>x : number</p>
    <p>y : number</p>
    <p>cx : number</p>
    <p>cy : number</p>
    <p><pre>void gs_draw_sprite_subregion(gs_texture_t *tex, uint32_t flip, uint32_t x, uint32_t y, uint32_t cx, uint32_t cy)</pre></p>
    <hr/><h3>gs_effect_create(effect_string, filename, error_string)</h3>
    <pre>
    Creates an effect from a string.
    
    :param effect_String: Effect string
    :param error_string:  Receives a pointer to the error string, which
                          must be freed with :c:func:`bfree()`.  If
                          *NULL*, this parameter is ignored.
    :return:              The effect object, or *NULL* on error
    
    </pre>
    <p>effect_string : string</p>
    <p>filename : string</p>
    <p>error_string : p_char</p>
    <p>Return : gs_effect</p>
    <p><pre>gs_effect_t *gs_effect_create(const char *effect_string, const char *filename, char **error_string)</pre></p>
    <hr/><h3>gs_effect_create_from_file(file, error_string)</h3>
    <pre>
    Creates an effect from file.
    
    :param file:         Path to the effect file
    :param error_string: Receives a pointer to the error string, which
                         must be freed with :c:func:`bfree()`.  If
                         *NULL*, this parameter is ignored.
    :return:             The effect object, or *NULL* on error
    
    </pre>
    <p>file : string</p>
    <p>error_string : p_char</p>
    <p>Return : gs_effect</p>
    <p><pre>gs_effect_t *gs_effect_create_from_file(const char *file, char **error_string)</pre></p>
    <hr/><h3>gs_effect_destroy(effect)</h3>
    <pre>
    Destroys the effect
    
    :param effect: Effect object
    
    </pre>
    <p>effect : gs_effect</p>
    <p><pre>void gs_effect_destroy(gs_effect_t *effect)</pre></p>
    <hr/><h3>gs_effect_get_current_technique(effect)</h3>
    <pre>
    Gets the current active technique of the effect.
    
    :param effect: Effect object
    :return:       Technique object, or *NULL* if none currently active
    
    </pre>
    <p>effect : gs_effect</p>
    <p>Return : gs_effect_technique</p>
    <p><pre>gs_technique_t *gs_effect_get_current_technique(const gs_effect_t *effect)</pre></p>
    <hr/><h3>gs_effect_get_default_val(param)</h3>
    <pre>
    Returns a copy of the param's default value.
    
    :param param:   Effect parameter
    :return:        A pointer to the copied byte value of the param's default value. Freed with :c:func:`bfree()`.
    
    </pre>
    <p>param : gs_effect_param</p>
    <p><pre>void gs_effect_get_default_val(gs_eparam_t *param)</pre></p>
    <hr/><h3>gs_effect_get_default_val_size(param)</h3>
    <pre>
    Returns the size in bytes of the param's default value.
    
    :param param:   Effect parameter
    :return:        The size in bytes of the param's default value.
    </pre>
    <p>param : gs_effect_param</p>
    <p>Return : number</p>
    <p><pre>size_t gs_effect_get_default_val_size(gs_eparam_t *param)</pre></p>
    <hr/><h3>gs_effect_get_num_params(effect)</h3>
    <pre>
    Gets the number of parameters associated with the effect.
    
    :param effect: Effect object
    :return:       Number of parameters the effect has
    
    </pre>
    <p>effect : gs_effect</p>
    <p>Return : number</p>
    <p><pre>size_t gs_effect_get_num_params(const gs_effect_t *effect)</pre></p>
    <hr/><h3>gs_effect_get_param_by_idx(effect, param)</h3>
    <pre>
    Gets a parameter of an effect by its index.
    
    :param effect: Effect object
    :param param:  Parameter index
    :return:       The effect parameter object, or *NULL* if index
                   invalid
    
    </pre>
    <p>effect : gs_effect</p>
    <p>param : number</p>
    <p>Return : gs_effect_param</p>
    <p><pre>gs_eparam_t *gs_effect_get_param_by_idx(const gs_effect_t *effect, size_t param)</pre></p>
    <hr/><h3>gs_effect_get_param_by_name(effect, name)</h3>
    <pre>
    Gets parameter of an effect by its name.
    
    :param effect: Effect object
    :param name:   Name of the parameter
    :return:       The effect parameter object, or *NULL* if not found
    
    </pre>
    <p>effect : gs_effect</p>
    <p>name : string</p>
    <p>Return : gs_effect_param</p>
    <p><pre>gs_eparam_t *gs_effect_get_param_by_name(const gs_effect_t *effect, const char *name)</pre></p>
    <hr/><h3>gs_effect_get_technique(effect, name)</h3>
    <pre>
    Gets a technique of the effect.
    
    :param effect: Effect object
    :param name:   Name of the technique
    :return:       Technique object, or *NULL* if not found
    
    </pre>
    <p>effect : gs_effect</p>
    <p>name : string</p>
    <p>Return : gs_effect_technique</p>
    <p><pre>gs_technique_t *gs_effect_get_technique(const gs_effect_t *effect, const char *name)</pre></p>
    <hr/><h3>gs_effect_get_val(param)</h3>
    <pre>
    Returns a copy of the param's current value.
    
    :param param:   Effect parameter
    :return:        A pointer to the copied byte value of the param's current value. Freed with :c:func:`bfree()`.
    
    </pre>
    <p>param : gs_effect_param</p>
    <p>Return : void</p>
    <p><pre>void *gs_effect_get_val(gs_eparam_t *param)</pre></p>
    <hr/><h3>gs_effect_get_val_size(param)</h3>
    <pre>
    Returns the size in bytes of the param's current value.
    
    :param param:   Effect parameter
    :return:        The size in bytes of the param's current value.
    
    </pre>
    <p>param : gs_effect_param</p>
    <p>Return : number</p>
    <p><pre>size_t gs_effect_get_val_size(gs_eparam_t *param)</pre></p>
    <hr/><h3>gs_effect_get_viewproj_matrix(effect)</h3>
    <pre>
    Gets the view/projection matrix parameter ("viewproj") of the effect.
    
    :param effect: Effect object
    :return:       The view/projection matrix parameter of the effect
    
    </pre>
    <p>effect : gs_effect</p>
    <p>Return : gs_effect_param</p>
    <p><pre>gs_eparam_t *gs_effect_get_viewproj_matrix(const gs_effect_t *effect)</pre></p>
    <hr/><h3>gs_effect_get_world_matrix(effect)</h3>
    <pre>
    Gets the world matrix parameter ("world") of the effect.
    
    :param effect: Effect object
    :return:       The world matrix parameter of the effect
    
    </pre>
    <p>effect : gs_effect</p>
    <p>Return : gs_effect_param</p>
    <p><pre>gs_eparam_t *gs_effect_get_world_matrix(const gs_effect_t *effect)</pre></p>
    <hr/><h3>gs_effect_loop(effect, name)</h3>
    <pre>
    Helper function that automatically begins techniques/passes.
    
    :param effect: Effect object
    :param name:   Name of the technique to execute
    :return:       *true* to draw, *false* when complete
    
    Here is an example of how this function is typically used:
    
    .. code:: cpp
    
    for (gs_effect_loop(effect, "my_technique")) {
            /* perform drawing here */
            [...]
    }
    
    </pre>
    <p>effect : gs_effect</p>
    <p>name : string</p>
    <p>Return : boolean</p>
    <p><pre>bool gs_effect_loop(gs_effect_t *effect, const char *name)</pre></p>
    <hr/><h3>gs_effect_set_bool(param, val)</h3>
    <pre>
    Sets a boolean parameter.
    
    :param param: Effect parameter
    :param val:   Boolean value
    
    </pre>
    <p>param : gs_effect_param</p>
    <p>val : boolean</p>
    <p><pre>void gs_effect_set_bool(gs_eparam_t *param, bool val)</pre></p>
    <hr/><h3>gs_effect_set_color(param, argb)</h3>
    <pre>
    Convenience function for setting a color value via an integer value.
    
    :param param: Effect parameter
    :param argb:  Integer color value (i.e. hex value would be
                  0xAARRGGBB)
    
    </pre>
    <p>param : gs_effect_param</p>
    <p>argb : number</p>
    <p><pre>void gs_effect_set_color(gs_eparam_t *param, uint32_t argb)</pre></p>
    <hr/><h3>gs_effect_set_default(param)</h3>
    <pre>
    Sets the parameter to its default value
    
    :param: Effect parameter
    
    </pre>
    <p>param : gs_effect_param</p>
    <p><pre>void gs_effect_set_default(gs_eparam_t *param)</pre></p>
    <hr/><h3>gs_effect_set_float(param, val)</h3>
    <pre>
    Sets a floating point parameter.
    
    :param param: Effect parameter
    :param val:   Floating point value
    
    </pre>
    <p>param : gs_effect_param</p>
    <p>val : number</p>
    <p><pre>void gs_effect_set_float(gs_eparam_t *param, float val)</pre></p>
    <hr/><h3>gs_effect_set_int(param, val)</h3>
    <pre>
    Sets a integer parameter.
    
    :param param: Effect parameter
    :param val:   Integer value
    
    </pre>
    <p>param : gs_effect_param</p>
    <p>val : number</p>
    <p><pre>void gs_effect_set_int(gs_eparam_t *param, int val)</pre></p>
    <hr/><h3>gs_effect_set_matrix4(param, val)</h3>
    <pre>
    Sets a matrix parameter.
    
    :param param: Effect parameter
    :param val:   Matrix
    
    </pre>
    <p>param : gs_effect_param</p>
    <p>val : matrix4</p>
    <p><pre>void gs_effect_set_matrix4(gs_eparam_t *param, const struct matrix4 *val)</pre></p>
    <hr/><h3>gs_effect_set_next_sampler(param, sampler)</h3>
    <pre>
    Manually changes the sampler for an effect parameter the next time
    it's used.
    
    :param param:   Effect parameter
    :param sampler: Sampler state object
    
    </pre>
    <p>param : gs_effect_param</p>
    <p>sampler : gs_sampler_state</p>
    <p><pre>void gs_effect_set_next_sampler(gs_eparam_t *param, gs_samplerstate_t *sampler)</pre></p>
    <hr/><h3>gs_effect_set_texture(param, val)</h3>
    <pre>
    Sets a texture parameter.
    
    :param param: Effect parameter
    :param val:   Texture
    
    </pre>
    <p>param : gs_effect_param</p>
    <p>val : gs_texture</p>
    <p><pre>void gs_effect_set_texture(gs_eparam_t *param, gs_texture_t *val)</pre></p>
    <hr/><h3>gs_effect_set_val(param, val, size)</h3>
    <pre>
    Sets a parameter with data manually.
    
    :param param: Effect parameter
    :param val:   Pointer to data
    :param size:  Size of data
    
    </pre>
    <p>param : gs_effect_param</p>
    <p>val : ref_void*</p>
    <p>size : number</p>
    <p><pre>void gs_effect_set_val(gs_eparam_t *param, const void *val, size_t size)</pre></p>
    <hr/><h3>gs_effect_set_vec2(param, val)</h3>
    <pre>
    Sets a 2-component vector parameter.
    
    :param param: Effect parameter
    :param val:   Vector
    
    </pre>
    <p>param : gs_effect_param</p>
    <p>val : vec2</p>
    <p><pre>void gs_effect_set_vec2(gs_eparam_t *param, const struct vec2 *val)</pre></p>
    <hr/><h3>gs_effect_set_vec3(param, val)</h3>
    <pre>
    Sets a 3-component vector parameter.
    
    :param param: Effect parameter
    :param val:   Vector
    
    </pre>
    <p>param : gs_effect_param</p>
    <p>val : vec3</p>
    <p><pre>void gs_effect_set_vec3(gs_eparam_t *param, const struct vec3 *val)</pre></p>
    <hr/><h3>gs_effect_set_vec4(param, val)</h3>
    <pre>
    Sets a 4-component vector parameter.
    
    :param param: Effect parameter
    :param val:   Vector
    
    </pre>
    <p>param : gs_effect_param</p>
    <p>val : vec4</p>
    <p><pre>void gs_effect_set_vec4(gs_eparam_t *param, const struct vec4 *val)</pre></p>
    <hr/><h3>gs_effect_update_params(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_effect</p>
    <hr/><h3>gs_enable_blending(enable)</h3>
    <pre>
    Enables/disables blending
    
    :param enable: *true* to enable, *false* to disable
    
    </pre>
    <p>enable : boolean</p>
    <p><pre>void gs_enable_blending(bool enable)</pre></p>
    <hr/><h3>gs_enable_color(red, green, blue, alpha)</h3>
    <pre>
    Enables/disables specific color channels
    
    :param red:   *true* to enable red channel, *false* to disable
    :param green: *true* to enable green channel, *false* to disable
    :param blue:  *true* to enable blue channel, *false* to disable
    :param alpha: *true* to enable alpha channel, *false* to disable
    
    </pre>
    <p>red : boolean</p>
    <p>green : boolean</p>
    <p>blue : boolean</p>
    <p>alpha : boolean</p>
    <p><pre>void gs_enable_color(bool red, bool green, bool blue, bool alpha)</pre></p>
    <hr/><h3>gs_enable_depth_test(enable)</h3>
    <pre>
    Enables/disables depth testing
    
    :param enable: *true* to enable, *false* to disable
    
    </pre>
    <p>enable : boolean</p>
    <p><pre>void gs_enable_depth_test(bool enable)</pre></p>
    <hr/><h3>gs_enable_stencil_test(enable)</h3>
    <pre>
    Enables/disables stencil testing
    
    :param enable: *true* to enable, *false* to disable
    
    </pre>
    <p>enable : boolean</p>
    <p><pre>void gs_enable_stencil_test(bool enable)</pre></p>
    <hr/><h3>gs_enable_stencil_write(enable)</h3>
    <pre>
    Enables/disables stencil writing
    
    :param enable: *true* to enable, *false* to disable
    
    </pre>
    <p>enable : boolean</p>
    <p><pre>void gs_enable_stencil_write(bool enable)</pre></p>
    <hr/><h3>gs_end_scene()</h3>
    <pre>
    Begins/ends a scene (this is automatically called by libobs, there's
    no need to call this manually).
    
    </pre>
    <p><pre>void gs_end_scene(void)</pre></p>
    <hr/><h3>gs_enter_context(graphics)</h3>
    <pre>
    Enters and locks the graphics context
    
    :param graphics: Graphics context
    
    </pre>
    <p>graphics : graphics_subsystem</p>
    <p><pre>void gs_enter_context(graphics_t *graphics)</pre></p>
    <hr/><h3>gs_enum_adapters(callback, param)</h3>
    <pre>
    Enumerates adapters (this really only applies on windows).
    
    :param callback: Enumeration callback
    :param param:    Private data passed to the callback
    
    </pre>
    <p>callback : f_p_void_p_q_const__char_unsigned_int__bool</p>
    <p>param : ref_void*</p>
    <p><pre>void gs_enum_adapters(bool (*callback)(void *param, const char *name, uint32_t id), void *param)</pre></p>
    <hr/><h3>gs_flush()</h3>
    <pre>
    Flushes GPU calls
    
    </pre>
    <p><pre>void gs_flush(void)</pre></p>
    <hr/><h3>gs_frustum(left, right, top, bottom, znear, zfar)</h3>
    <pre>
    Sets the projection matrix to a frustum matrix
    
    </pre>
    <p>left : number</p>
    <p>right : number</p>
    <p>top : number</p>
    <p>bottom : number</p>
    <p>znear : number</p>
    <p>zfar : number</p>
    <p><pre>void gs_frustum(float left, float right, float top, float bottom, float znear, float zfar)</pre></p>
    <hr/><h3>gs_get_context()</h3>
    <pre>
    :return: The currently locked graphics context for this thread
    
    </pre>
    <p>Return : graphics_subsystem</p>
    <p><pre>graphics_t *gs_get_context(void)</pre></p>
    <hr/><h3>gs_get_cull_mode()</h3>
    <pre>
    :return: The current cull mode
    
    </pre>
    <p>Return : number</p>
    <p><pre>enum gs_cull_mode gs_get_cull_mode(void)</pre></p>
    <hr/><h3>gs_get_device_name()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>gs_get_device_obj()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>gs_get_device_type()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>gs_get_effect()</h3>
    <pre>
    :return: The currently active effect, or *NULL* if none active
    
    </pre>
    <p>Return : gs_effect</p>
    <p><pre>gs_effect_t *gs_get_effect(void)</pre></p>
    <hr/><h3>gs_get_format_bpp(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <hr/><h3>gs_get_height()</h3>
    <pre>
    Gets the height of the currently active swap chain
    
    </pre>
    <p>Return : number</p>
    <p><pre>uint32_t gs_get_height(void)</pre></p>
    <hr/><h3>gs_get_input()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>gs_get_pixel_shader()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>gs_get_render_target()</h3>
    <pre>
    :return: The currently active render target
    
    </pre>
    <p>Return : gs_texture</p>
    <p><pre>gs_texture_t  *gs_get_render_target(void)</pre></p>
    <hr/><h3>gs_get_size(cx, cy)</h3>
    <pre>
    Gets the size of the currently active swap chain
    
    :param cx: Pointer to receive width
    :param cy: Pointer to receive height
    
    </pre>
    <p>cx : unsigned_int</p>
    <p>cy : unsigned_int</p>
    <p><pre>void gs_get_size(uint32_t *cx, uint32_t *cy)</pre></p>
    <hr/><h3>gs_get_texture_type(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_texture</p>
    <hr/><h3>gs_get_total_levels(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : number</p>
    <p>param3 : number</p>
    <hr/><h3>gs_get_vertex_shader()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>gs_get_viewport(rect)</h3>
    <pre>
    Gets the current viewport
    
    :param rect: Pointer to receive viewport rectangle
    
    </pre>
    <p>rect : gs_rect</p>
    <p><pre>void gs_get_viewport(struct gs_rect *rect)</pre></p>
    <hr/><h3>gs_get_width()</h3>
    <pre>
    Gets the width of the currently active swap chain
    
    </pre>
    <p>Return : number</p>
    <p><pre>uint32_t gs_get_width(void)</pre></p>
    <hr/><h3>gs_get_zstencil_target()</h3>
    <pre>
    :return: The currently active Z-stencil target
    
    </pre>
    <p>Return : gs_zstencil_buffer</p>
    <p><pre>gs_zstencil_t *gs_get_zstencil_target(void)</pre></p>
    <hr/><h3>gs_image_file2_free(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_image_file2</p>
    <hr/><h3>gs_image_file2_init(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_image_file2</p>
    <p>param2 : string</p>
    <hr/><h3>gs_image_file2_init_texture(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_image_file2</p>
    <hr/><h3>gs_image_file2_tick(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_image_file2</p>
    <p>param2 : number</p>
    <hr/><h3>gs_image_file2_update_texture(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_image_file2</p>
    <hr/><h3>gs_image_file_free(image)</h3>
    <pre>
    Frees an image file helper
    
    :param image: Image file helper
    
    </pre>
    <p>image : gs_image_file</p>
    <p><pre>void gs_image_file_free(gs_image_file_t *image)</pre></p>
    <hr/><h3>gs_image_file_init(image, file)</h3>
    <pre>
    Loads an initializes an image file helper.  Does not initialize the
    texture; call :c:func:`gs_image_file_init_texture()` to initialize
    the texture.
    
    :param image: Image file helper to initialize
    :param file:  Path to the image file to load
    
    </pre>
    <p>image : gs_image_file</p>
    <p>file : string</p>
    <p><pre>void gs_image_file_init(gs_image_file_t *image, const char *file)</pre></p>
    <hr/><h3>gs_image_file_init_texture(image)</h3>
    <pre>
    Initializes the texture of an image file helper.  This is separate
    from :c:func:`gs_image_file_init()` because it allows deferring the
    graphics initialization if needed.
    
    :param image: Image file helper
    
    </pre>
    <p>image : gs_image_file</p>
    <p><pre>void gs_image_file_init_texture(gs_image_file_t *image)</pre></p>
    <hr/><h3>gs_image_file_tick(image, elapsed_time_ns)</h3>
    <pre>
    Performs a tick operation on the image file helper (used primarily
    for animated file).  Does not update the texture until
    :c:func:`gs_image_file_update_texture()` is called.
    
    :param image:           Image file helper
    :param elapsed_time_ns: Elapsed time in nanoseconds
    
    </pre>
    <p>image : gs_image_file</p>
    <p>elapsed_time_ns : number</p>
    <p>Return : boolean</p>
    <p><pre>bool gs_image_file_tick(gs_image_file_t *image, uint64_t elapsed_time_ns)</pre></p>
    <hr/><h3>gs_image_file_update_texture(image)</h3>
    <pre>
    Updates the texture (used primarily for animated files)
    
    :param image: Image file helper
    </pre>
    <p>image : gs_image_file</p>
    <p><pre>void gs_image_file_update_texture(gs_image_file_t *image)</pre></p>
    <hr/><h3>gs_indexbuffer_create(type, indices, num, flags)</h3>
    <pre>
    Creates an index buffer.
    
    :param type:    Index buffer type
    :param indices: Index buffer data.  This buffer must be allocated
                    with :c:func:`bmalloc()`, :c:func:`bzalloc()`, or
                    :c:func:`bralloc()`, and ownership of this buffer is
                    passed to the index buffer object.
    :param num:     Number of indices in the buffer
    
    :param flags:   Creation flags.  Can be 0 or a bitwise-OR combination
                    of any of the following values:
    
                    - GS_DYNAMIC - Can be dynamically updated in real time.
                    - GS_DUP_BUFFER - Do not pass buffer ownership
    
    :return:        A new index buffer object, or *NULL* if failed
    
    </pre>
    <p>type : number</p>
    <p>indices : ref_void*</p>
    <p>num : number</p>
    <p>flags : number</p>
    <p>Return : gs_index_buffer</p>
    <p><pre>gs_indexbuffer_t *gs_indexbuffer_create(enum gs_index_type type, void *indices, size_t num, uint32_t flags)</pre></p>
    <hr/><h3>gs_indexbuffer_destroy(indexbuffer)</h3>
    <pre>
    Destroys an index buffer object.
    
    :param indexbuffer: Index buffer object
    
    </pre>
    <p>indexbuffer : gs_index_buffer</p>
    <p><pre>void     gs_indexbuffer_destroy(gs_indexbuffer_t *indexbuffer)</pre></p>
    <hr/><h3>gs_indexbuffer_flush(indexbuffer)</h3>
    <pre>
    Flushes a index buffer to its interval index data object.  To modify
    its internal index data, call :c:func:`gs_indexbuffer_get_data()`.
    
    Can only be used with dynamic index buffer objects.
    
    :param indexbuffer: Index buffer object
    
    </pre>
    <p>indexbuffer : gs_index_buffer</p>
    <p><pre>void     gs_indexbuffer_flush(gs_indexbuffer_t *indexbuffer)</pre></p>
    <hr/><h3>gs_indexbuffer_flush_direct(indexbuffer, data)</h3>
    <pre>
    Flushes a index buffer to the specified index buffer data.
    
    Can only be used with dynamic index buffer objects.
    
    :param indexbuffer: Index buffer object
    :param data:        Index buffer data to flush
    
    </pre>
    <p>indexbuffer : gs_index_buffer</p>
    <p>data : ref_void*</p>
    <p><pre>void     gs_indexbuffer_flush_direct(gs_indexbuffer_t *indexbuffer, const void *data)</pre></p>
    <hr/><h3>gs_indexbuffer_get_data(indexbuffer)</h3>
    <pre>
    Gets the index buffer data associated with a index buffer object.
    This data can be changed and index buffer can be updated with
    :c:func:`gs_indexbuffer_flush()`.
    
    Can only be used with dynamic index buffer objects.
    
    :param vertbuffer: Index buffer object
    :return:           Index buffer data pointer
    
    </pre>
    <p>indexbuffer : gs_index_buffer</p>
    <p>Return : void</p>
    <p><pre>void     *gs_indexbuffer_get_data(const gs_indexbuffer_t *indexbuffer)</pre></p>
    <hr/><h3>gs_indexbuffer_get_num_indices(indexbuffer)</h3>
    <pre>
    Gets the number of indices associated with this index buffer.
    
    :param indexbuffer: Index buffer object
    :return:            Number of indices the vertex buffer object has
    
    </pre>
    <p>indexbuffer : gs_index_buffer</p>
    <p>Return : number</p>
    <p><pre>size_t   gs_indexbuffer_get_num_indices(const gs_indexbuffer_t *indexbuffer)</pre></p>
    <hr/><h3>gs_indexbuffer_get_type(indexbuffer)</h3>
    <pre>
    Gets the type of index buffer.
    
    :param indexbuffer: Index buffer object
    :return:            Index buffer type
    
    </pre>
    <p>indexbuffer : gs_index_buffer</p>
    <p>Return : number</p>
    <p><pre>enum gs_index_type gs_indexbuffer_get_type(const gs_indexbuffer_t *indexbuffer)</pre></p>
    <hr/><h3>gs_is_compressed_format(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <hr/><h3>gs_leave_context()</h3>
    <pre>
    Leaves and unlocks the graphics context
    
    :param graphics: Graphics context
    
    </pre>
    <p><pre>void gs_leave_context(void)</pre></p>
    <hr/><h3>gs_load_default_samplerstate(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : boolean</p>
    <p>param2 : number</p>
    <hr/><h3>gs_load_indexbuffer(indexbuffer)</h3>
    <pre>
    Loads a index buffer
    
    :param indexbuffer: Index buffer to load, or NULL to unload
    
    </pre>
    <p>indexbuffer : gs_index_buffer</p>
    <p><pre>void gs_load_indexbuffer(gs_indexbuffer_t *indexbuffer)</pre></p>
    <hr/><h3>gs_load_pixelshader(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_shader</p>
    <hr/><h3>gs_load_samplerstate(samplerstate, unit)</h3>
    <pre>
    Loads a sampler state (this is usually not called manually)
    
    :param samplerstate: Sampler state to load, or NULL to unload
    :param unit:         Texture unit to load sampler state for
    
    </pre>
    <p>samplerstate : gs_sampler_state</p>
    <p>unit : number</p>
    <p><pre>void gs_load_samplerstate(gs_samplerstate_t *samplerstate, int unit)</pre></p>
    <hr/><h3>gs_load_swapchain(swapchain)</h3>
    <pre>
    Loads a swapchain
    
    :param swapchain: Swap chain to load, or NULL to unload
    
    </pre>
    <p>swapchain : gs_swap_chain</p>
    <p><pre>void gs_load_swapchain(gs_swapchain_t *swapchain)</pre></p>
    <hr/><h3>gs_load_texture(tex, unit)</h3>
    <pre>
    Loads a texture (this is usually not called manually)
    
    :param tex:  Texture to load, or NULL to unload
    :param unit: Texture unit to load texture for
    
    </pre>
    <p>tex : gs_texture</p>
    <p>unit : number</p>
    <p><pre>void gs_load_texture(gs_texture_t *tex, int unit)</pre></p>
    <hr/><h3>gs_load_vertexbuffer(vertbuffer)</h3>
    <pre>
    Loads a vertex buffer
    
    :param vertbuffer: Vertex buffer to load, or NULL to unload
    
    </pre>
    <p>vertbuffer : gs_vertex_buffer</p>
    <p><pre>void gs_load_vertexbuffer(gs_vertbuffer_t *vertbuffer)</pre></p>
    <hr/><h3>gs_load_vertexshader(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_shader</p>
    <hr/><h3>gs_matrix_get(dst)</h3>
    <pre>
    Gets the current matrix
    
    :param dst: Destination matrix
    
    </pre>
    <p>dst : matrix4</p>
    <p><pre>void gs_matrix_get(struct matrix4 *dst)</pre></p>
    <hr/><h3>gs_matrix_identity()</h3>
    <pre>
    Sets the current matrix to an identity matrix.
    
    </pre>
    <p><pre>void gs_matrix_identity(void)</pre></p>
    <hr/><h3>gs_matrix_mul(matrix)</h3>
    <pre>
    Multiplies the current matrix
    
    :param matrix: Matrix to multiply the current stack matrix with
    
    </pre>
    <p>matrix : matrix4</p>
    <p><pre>void gs_matrix_mul(const struct matrix4 *matrix)</pre></p>
    <hr/><h3>gs_matrix_pop()</h3>
    <pre>
    Pops the current matrix from the matrix stack.
    
    </pre>
    <p><pre>void gs_matrix_pop(void)</pre></p>
    <hr/><h3>gs_matrix_push()</h3>
    <pre>
    Pushes the matrix stack and duplicates the current matrix.
    
    </pre>
    <p><pre>void gs_matrix_push(void)</pre></p>
    <hr/><h3>gs_matrix_rotaa(rot)</h3>
    <pre>
    Multiplies the current matrix with an axis angle
    
    :param rot: Axis angle to multiple the current matrix stack with
    
    </pre>
    <p>rot : axisang</p>
    <p><pre>void gs_matrix_rotaa(const struct axisang *rot)</pre></p>
    <hr/><h3>gs_matrix_rotaa4f(x, y, z, angle)</h3>
    <pre>
    Multiplies the current matrix with an axis angle
    
    :param rot: Axis angle to multiple the current matrix stack with
    
    </pre>
    <p>x : number</p>
    <p>y : number</p>
    <p>z : number</p>
    <p>angle : number</p>
    <p><pre>void gs_matrix_rotaa4f(float x, float y, float z, float angle)</pre></p>
    <hr/><h3>gs_matrix_rotquat(rot)</h3>
    <pre>
    Multiplies the current matrix with a quaternion
    
    :param rot: Quaternion to multiple the current matrix stack with
    
    </pre>
    <p>rot : quat</p>
    <p><pre>void gs_matrix_rotquat(const struct quat *rot)</pre></p>
    <hr/><h3>gs_matrix_scale(scale)</h3>
    <pre>
    Scales the current matrix
    
    :param scale: Scale value to scale the current matrix stack with
    
    </pre>
    <p>scale : vec3</p>
    <p><pre>void gs_matrix_scale(const struct vec3 *scale)</pre></p>
    <hr/><h3>gs_matrix_scale3f(x, y, z)</h3>
    <pre>
    Scales the current matrix
    
    :param scale: Scale value to scale the current matrix stack with
    
    </pre>
    <p>x : number</p>
    <p>y : number</p>
    <p>z : number</p>
    <p><pre>void gs_matrix_scale3f(float x, float y, float z)</pre></p>
    <hr/><h3>gs_matrix_set(matrix)</h3>
    <pre>
    Sets the current matrix.
    
    :param matrix: The matrix to set
    
    </pre>
    <p>matrix : matrix4</p>
    <p><pre>void gs_matrix_set(const struct matrix4 *matrix)</pre></p>
    <hr/><h3>gs_matrix_translate(pos)</h3>
    <pre>
    Translates the current matrix
    
    :param pos: Vector to translate the current matrix stack with
    
    </pre>
    <p>pos : vec3</p>
    <p><pre>void gs_matrix_translate(const struct vec3 *pos)</pre></p>
    <hr/><h3>gs_matrix_translate3f(x, y, z)</h3>
    <pre>
    Translates the current matrix
    
    :param pos: Vector to translate the current matrix stack with
    
    </pre>
    <p>x : number</p>
    <p>y : number</p>
    <p>z : number</p>
    <p><pre>void gs_matrix_translate3f(float x, float y, float z)</pre></p>
    <hr/><h3>gs_matrix_transpose()</h3>
    <pre>
    Transposes the current matrix.
    
    </pre>
    <p><pre>void gs_matrix_transpose(void)</pre></p>
    <hr/><h3>gs_normal3f(x, y, z)</h3>
    <pre>
    </pre>
    <p>x : number</p>
    <p>y : number</p>
    <p>z : number</p>
    <p><pre>void gs_normal3f(float x, float y, float z)</pre></p>
    <hr/><h3>gs_normal3v(v)</h3>
    <pre>
    </pre>
    <p>v : vec3</p>
    <p><pre>void gs_normal3v(const struct vec3 *v)</pre></p>
    <hr/><h3>gs_nv12_available()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>gs_ortho(left, right, top, bottom, znear, zfar)</h3>
    <pre>
    Sets the projection matrix to an orthographic matrix
    
    </pre>
    <p>left : number</p>
    <p>right : number</p>
    <p>top : number</p>
    <p>bottom : number</p>
    <p>znear : number</p>
    <p>zfar : number</p>
    <p><pre>void gs_ortho(float left, float right, float top, float bottom, float znear, float zfar)</pre></p>
    <hr/><h3>gs_param_get_annotation_by_idx(param, annotation)</h3>
    <pre>
    Gets an annotation of a param by its index.
    
    :param param:  Param object
    :param param:  Annotation index
    :return:       The effect parameter object (annotation), or *NULL* if index
                   invalid
    
    </pre>
    <p>param : gs_effect_param</p>
    <p>annotation : number</p>
    <p>Return : gs_effect_param</p>
    <p><pre>gs_eparam_t *gs_param_get_annotation_by_idx(const gs_eparam_t *param, size_t annotation)</pre></p>
    <hr/><h3>gs_param_get_annotation_by_name(pardam, annotation)</h3>
    <pre>
    Gets parameter of an effect by its name.
    
    :param param:  Param object
    :param name:   Name of the annotation
    :return:       The effect parameter object (annotation), or *NULL* if not found
    
    </pre>
    <p>pardam : gs_effect_param</p>
    <p>annotation : string</p>
    <p>Return : gs_effect_param</p>
    <p><pre>gs_eparam_t *gs_param_get_annotation_by_name(const gs_eparam_t *pardam, const char *annotation)</pre></p>
    <hr/><h3>gs_param_get_num_annotations(param)</h3>
    <pre>
    Gets the number of annotations associated with the parameter.
    
    :param param:  Param object
    :return:       Number of annotations the param has
    
    </pre>
    <p>param : gs_effect_param</p>
    <p>Return : number</p>
    <p><pre>size_t gs_param_get_num_annotations(const gs_eparam_t *param)</pre></p>
    <hr/><h3>gs_perspective(fovy, aspect, znear, zfar)</h3>
    <pre>
    Sets the projection matrix to a perspective mode
    
    :param fovy:   Field of view (in degrees)
    :param aspect: Aspect ratio
    :param znear:  Near plane
    :param zfar:   Far plane
    
    </pre>
    <p>fovy : number</p>
    <p>aspect : number</p>
    <p>znear : number</p>
    <p>zfar : number</p>
    <p><pre>void gs_perspective(float fovy, float aspect, float znear, float zfar)</pre></p>
    <hr/><h3>gs_pixelshader_create(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <p>param2 : string</p>
    <p>param3 : p_char</p>
    <hr/><h3>gs_pixelshader_create_from_file(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <p>param2 : p_char</p>
    <hr/><h3>gs_present()</h3>
    <pre>
    Displays what was rendered on to the current render target
    
    </pre>
    <p><pre>void gs_present(void)</pre></p>
    <hr/><h3>gs_projection_pop()</h3>
    <pre>
    Pops/restores the last projection matrix pushed
    
    </pre>
    <p><pre>void gs_projection_pop(void)</pre></p>
    <hr/><h3>gs_projection_push()</h3>
    <pre>
    Pushes/stores the current projection matrix
    
    </pre>
    <p><pre>void gs_projection_push(void)</pre></p>
    <hr/><h3>gs_render_save()</h3>
    <pre>
    </pre>
    <p>Return : gs_vertex_buffer</p>
    <p><pre>gs_vertbuffer_t *gs_render_save(void)</pre></p>
    <hr/><h3>gs_render_start(b_new)</h3>
    <pre>
    </pre>
    <p>b_new : boolean</p>
    <p><pre>void gs_render_start(bool b_new)</pre></p>
    <hr/><h3>gs_render_stop(mode)</h3>
    <pre>
    </pre>
    <p>mode : number</p>
    <p><pre>void gs_render_stop(enum gs_draw_mode mode)</pre></p>
    <hr/><h3>gs_reset_blend_state()</h3>
    <pre>
    Sets the blend state to the default value: source alpha and invert
    source alpha.
    
    </pre>
    <p><pre>void gs_reset_blend_state(void)</pre></p>
    <hr/><h3>gs_reset_viewport()</h3>
    <pre>
     Sets the viewport to current swap chain size
    
    </pre>
    <p><pre>void gs_reset_viewport(void)</pre></p>
    <hr/><h3>gs_resize(cx, cy)</h3>
    <pre>
    Resizes the currently active swap chain
    
    :param cx: New width
    :param cy: New height
    
    </pre>
    <p>cx : number</p>
    <p>cy : number</p>
    <p><pre>void gs_resize(uint32_t cx, uint32_t cy)</pre></p>
    <hr/><h3>gs_samplerstate_create(info)</h3>
    <pre>
    Creates a sampler state object.
    
    :param info: Sampler state information
    :return:     New sampler state object
    
    </pre>
    <p>info : gs_sampler_info</p>
    <p>Return : gs_sampler_state</p>
    <p><pre>gs_samplerstate_t *gs_samplerstate_create(const struct gs_sampler_info *info)</pre></p>
    <hr/><h3>gs_samplerstate_destroy(samplerstate)</h3>
    <pre>
    Destroys a sampler state object.
    
    :param samplerstate: Sampler state object
    
    </pre>
    <p>samplerstate : gs_sampler_state</p>
    <p><pre>void     gs_samplerstate_destroy(gs_samplerstate_t *samplerstate)</pre></p>
    <hr/><h3>gs_set_2d_mode()</h3>
    <pre>
     Sets the projection matrix to a default screen-sized orthographic
     mode
    
    </pre>
    <p><pre>void gs_set_2d_mode(void)</pre></p>
    <hr/><h3>gs_set_3d_mode(fovy, znear, zfar)</h3>
    <pre>
     Sets the projection matrix to a default screen-sized perspective
     mode
    
     :param fovy:  Field of view (in degrees)
     :param znear: Near plane
     :param zfar:  Far plane
    
    </pre>
    <p>fovy : number</p>
    <p>znear : number</p>
    <p>zfar : number</p>
    <p><pre>void gs_set_3d_mode(double fovy, double znear, double zfar)</pre></p>
    <hr/><h3>gs_set_cube_render_target(cubetex, side, zstencil)</h3>
    <pre>
    Sets a cubemap side as the active render target
    
    :param cubetex:  Cubemap
    :param side:     Cubemap side
    :param zstencil: Z-stencil buffer, or *NULL* if none
    
    </pre>
    <p>cubetex : gs_texture</p>
    <p>side : number</p>
    <p>zstencil : gs_zstencil_buffer</p>
    <p><pre>void gs_set_cube_render_target(gs_texture_t *cubetex, int side, gs_zstencil_t *zstencil)</pre></p>
    <hr/><h3>gs_set_cull_mode(mode)</h3>
    <pre>
    Sets the current cull mode.
    
    :param mode: Cull mode
    
    </pre>
    <p>mode : number</p>
    <p><pre>void gs_set_cull_mode(enum gs_cull_mode mode)</pre></p>
    <hr/><h3>gs_set_render_target(tex, zstencil)</h3>
    <pre>
    Sets the active render target
    
    :param tex:      Texture to set as the active render target
    :param zstencil: Z-stencil to use as the active render target
    
    </pre>
    <p>tex : gs_texture</p>
    <p>zstencil : gs_zstencil_buffer</p>
    <p><pre>void gs_set_render_target(gs_texture_t *tex, gs_zstencil_t *zstencil)</pre></p>
    <hr/><h3>gs_set_scissor_rect(rect)</h3>
    <pre>
    Sets or clears the current scissor rectangle
    
    :rect: Scissor rectangle, or *NULL* to clear
    
    </pre>
    <p>rect : gs_rect</p>
    <p><pre>void gs_set_scissor_rect(const struct gs_rect *rect)</pre></p>
    <hr/><h3>gs_set_viewport(x, y, width, height)</h3>
    <pre>
    Sets the current viewport
    
    :param x:      X position relative to upper left
    :param y:      Y position relative to upper left
    :param width:  Width of the viewport
    :param height: Height of the viewport
    
    </pre>
    <p>x : number</p>
    <p>y : number</p>
    <p>width : number</p>
    <p>height : number</p>
    <p><pre>void gs_set_viewport(int x, int y, int width, int height)</pre></p>
    <hr/><h3>gs_stage_texture(dst, src)</h3>
    <pre>
    Copies a texture to a staging surface and copies it to RAM.  Ideally
    best to give this a frame to process to prevent stalling.
    
    :param dst: Staging surface
    :param src: Texture to stage
    
    </pre>
    <p>dst : gs_stage_surface</p>
    <p>src : gs_texture</p>
    <p><pre>void gs_stage_texture(gs_stagesurf_t *dst, gs_texture_t *src)</pre></p>
    <hr/><h3>gs_stagesurface_create(width, height, color_format)</h3>
    <pre>
    Creates a staging surface.
    
    :param width:        Width
    :param height:       Height
    :param color_format: Color format
    :return:             The staging surface object
    
    </pre>
    <p>width : number</p>
    <p>height : number</p>
    <p>color_format : number</p>
    <p>Return : gs_stage_surface</p>
    <p><pre>gs_stagesurf_t *gs_stagesurface_create(uint32_t width, uint32_t height, enum gs_color_format color_format)</pre></p>
    <hr/><h3>gs_stagesurface_destroy(stagesurf)</h3>
    <pre>
    Destroys a staging surface.
    
    :param stagesurf: Staging surface object
    
    </pre>
    <p>stagesurf : gs_stage_surface</p>
    <p><pre>void     gs_stagesurface_destroy(gs_stagesurf_t *stagesurf)</pre></p>
    <hr/><h3>gs_stagesurface_get_color_format(stagesurf)</h3>
    <pre>
    Gets the color format of a staging surface object.
    
    :param stagesurf: Staging surface object
    :return:          Color format of the staging surface
    
    </pre>
    <p>stagesurf : gs_stage_surface</p>
    <p>Return : number</p>
    <p><pre>enum gs_color_format gs_stagesurface_get_color_format(const gs_stagesurf_t *stagesurf)</pre></p>
    <hr/><h3>gs_stagesurface_get_height(stagesurf)</h3>
    <pre>
    Gets the width/height of a staging surface object.
    
    :param stagesurf: Staging surface object
    :return:          Width/height of the staging surface
    
    </pre>
    <p>stagesurf : gs_stage_surface</p>
    <p>Return : number</p>
    <p><pre>uint32_t gs_stagesurface_get_height(const gs_stagesurf_t *stagesurf)</pre></p>
    <hr/><h3>gs_stagesurface_get_width(stagesurf)</h3>
    <pre>
    Gets the width/height of a staging surface object.
    
    :param stagesurf: Staging surface object
    :return:          Width/height of the staging surface
    
    </pre>
    <p>stagesurf : gs_stage_surface</p>
    <p>Return : number</p>
    <p><pre>uint32_t gs_stagesurface_get_width(const gs_stagesurf_t *stagesurf)</pre></p>
    <hr/><h3>gs_stagesurface_map(stagesurf, data, linesize)</h3>
    <pre>
    Maps the staging surface texture (for reading).  Call
    :c:func:`gs_stagesurface_unmap()` to unmap when complete.
    
    :param stagesurf: Staging surface object
    :param data:      Pointer to receive texture data pointer
    :param linesize:  Pointer to receive line size (pitch) of the texture
                      data
    :return:          *true* if map successful, *false* otherwise
    
    </pre>
    <p>stagesurf : gs_stage_surface</p>
    <p>data : p_unsigned_char</p>
    <p>linesize : unsigned_int</p>
    <p>Return : boolean</p>
    <p><pre>bool     gs_stagesurface_map(gs_stagesurf_t *stagesurf, uint8_t **data, uint32_t *linesize)</pre></p>
    <hr/><h3>gs_stagesurface_unmap(stagesurf)</h3>
    <pre>
    Unmaps a staging surface.
    
    :param stagesurf: Staging surface object
    
    </pre>
    <p>stagesurf : gs_stage_surface</p>
    <p><pre>void     gs_stagesurface_unmap(gs_stagesurf_t *stagesurf)</pre></p>
    <hr/><h3>gs_stencil_function(side, test)</h3>
    <pre>
    Sets the stencil function
    
    :param side: Stencil side
    :param test: Depth test
    
    </pre>
    <p>side : number</p>
    <p>test : number</p>
    <p><pre>void gs_stencil_function(enum gs_stencil_side side, enum gs_depth_test test)</pre></p>
    <hr/><h3>gs_stencil_op(side, fail, zfail, zpass)</h3>
    <pre>
    Sets the stencil operation
    
    :param side:  Stencil side
    :param fail:  Operation to perform on stencil test failure
    :param zfail: Operation to perform on depth test failure
    :param zpass: Operation to perform on depth test success
    
    </pre>
    <p>side : number</p>
    <p>fail : number</p>
    <p>zfail : number</p>
    <p>zpass : number</p>
    <p><pre>void gs_stencil_op(enum gs_stencil_side side, enum gs_stencil_op_type fail, enum gs_stencil_op_type zfail, enum gs_stencil_op_type zpass)</pre></p>
    <hr/><h3>gs_swapchain_create(data)</h3>
    <pre>
    Creates a swap chain (display view on a native widget)
    
    :param data: Swap chain initialization data
    :return:     New swap chain object, or *NULL* if failed
    
    </pre>
    <p>data : gs_init_data</p>
    <p>Return : gs_swap_chain</p>
    <p><pre>gs_swapchain_t *gs_swapchain_create(const struct gs_init_data *data)</pre></p>
    <hr/><h3>gs_swapchain_destroy(swapchain)</h3>
    <pre>
    Destroys a swap chain
    
    </pre>
    <p>swapchain : gs_swap_chain</p>
    <p><pre>void     gs_swapchain_destroy(gs_swapchain_t *swapchain)</pre></p>
    <hr/><h3>gs_technique_begin(technique)</h3>
    <pre>
    Begins a technique.
    
    :param technique: Technique object
    :return:          Number of passes this technique uses
    
    </pre>
    <p>technique : gs_effect_technique</p>
    <p>Return : number</p>
    <p><pre>size_t gs_technique_begin(gs_technique_t *technique)</pre></p>
    <hr/><h3>gs_technique_begin_pass(technique, pass)</h3>
    <pre>
    Begins a pass.  Automatically loads the vertex/pixel shaders
    associated with this pass.  Draw after calling this function.
    
    :param technique: Technique object
    :param pass:      Pass index
    :return:          *true* if the pass is valid, *false* otherwise
    
    </pre>
    <p>technique : gs_effect_technique</p>
    <p>pass : number</p>
    <p>Return : boolean</p>
    <p><pre>bool gs_technique_begin_pass(gs_technique_t *technique, size_t pass)</pre></p>
    <hr/><h3>gs_technique_begin_pass_by_name(technique, name)</h3>
    <pre>
    Begins a pass by its name if the pass has a name.  Automatically
    loads the vertex/pixel shaders associated with this pass.  Draw after
    calling this function.
    
    :param technique: Technique object
    :param name:      Name of the pass
    :return:          *true* if the pass is valid, *false* otherwise
    
    </pre>
    <p>technique : gs_effect_technique</p>
    <p>name : string</p>
    <p>Return : boolean</p>
    <p><pre>bool gs_technique_begin_pass_by_name(gs_technique_t *technique, const char *name)</pre></p>
    <hr/><h3>gs_technique_end(technique)</h3>
    <pre>
    Ends a technique.  Make sure all active passes have been ended before
    calling.
    
    :param technique: Technique object
    
    </pre>
    <p>technique : gs_effect_technique</p>
    <p><pre>void gs_technique_end(gs_technique_t *technique)</pre></p>
    <hr/><h3>gs_technique_end_pass(technique)</h3>
    <pre>
    Ends a pass.
    
    :param technique: Technique object
    
    </pre>
    <p>technique : gs_effect_technique</p>
    <p><pre>void gs_technique_end_pass(gs_technique_t *technique)</pre></p>
    <hr/><h3>gs_technique_get_pass_by_idx(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_effect_technique</p>
    <p>param2 : number</p>
    <hr/><h3>gs_technique_get_pass_by_name(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_effect_technique</p>
    <p>param2 : string</p>
    <hr/><h3>gs_texcoord(x, y, unit)</h3>
    <pre>
    </pre>
    <p>x : number</p>
    <p>y : number</p>
    <p>unit : number</p>
    <p><pre>void gs_texcoord(float x, float y, int unit)</pre></p>
    <hr/><h3>gs_texcoord2v(v, unit)</h3>
    <pre>
    </pre>
    <p>v : vec2</p>
    <p>unit : number</p>
    <p><pre>void gs_texcoord2v(const struct vec2 *v, int unit)</pre></p>
    <hr/><h3>gs_texrender_begin(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_texture_render</p>
    <p>param2 : number</p>
    <p>param3 : number</p>
    <hr/><h3>gs_texrender_create(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : number</p>
    <hr/><h3>gs_texrender_destroy(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_texture_render</p>
    <hr/><h3>gs_texrender_end(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_texture_render</p>
    <hr/><h3>gs_texrender_get_texture(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_texture_render</p>
    <hr/><h3>gs_texrender_reset(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_texture_render</p>
    <hr/><h3>gs_texture_create(width, height, color_format, levels, data, flags)</h3>
    <pre>
    Creates a texture.
    
    :param width:        Width
    :param height:       Height
    :param color_format: Color format
    :param levels:       Number of total texture levels.  Set to 1 if no
                         mip-mapping
    :param data:         Pointer to array of texture data pointers
    :param flags:        Can be 0 or a bitwise-OR combination of one or
                         more of the following value:
    
                         - GS_BUILD_MIPMAPS - Automatically builds
                           mipmaps (Note: not fully tested)
                         - GS_DYNAMIC - Dynamic
                         - GS_RENDER_TARGET - Render target
    
    :return:             A new texture object
    
    </pre>
    <p>width : number</p>
    <p>height : number</p>
    <p>color_format : number</p>
    <p>levels : number</p>
    <p>data : p_unsigned_char</p>
    <p>flags : number</p>
    <p>Return : gs_texture</p>
    <p><pre>gs_texture_t *gs_texture_create(uint32_t width, uint32_t height, enum gs_color_format color_format, uint32_t levels, const uint8_t **data, uint32_t flags)</pre></p>
    <hr/><h3>gs_texture_create_from_file(file)</h3>
    <pre>
    Creates a texture from a file.  Note that this isn't recommended for
    animated gifs -- instead use the :ref:`image_file_helper`.
    
    :param file: Image file to open
    
    </pre>
    <p>file : string</p>
    <p>Return : gs_texture</p>
    <p><pre>gs_texture_t *gs_texture_create_from_file(const char *file)</pre></p>
    <hr/><h3>gs_texture_destroy(tex)</h3>
    <pre>
    Destroys a texture
    
    :param tex: Texture object
    
    </pre>
    <p>tex : gs_texture</p>
    <p><pre>void     gs_texture_destroy(gs_texture_t *tex)</pre></p>
    <hr/><h3>gs_texture_get_color_format(tex)</h3>
    <pre>
    Gets the texture's color format
    
    :param tex: Texture object
    :return:    The texture's color format
    
    </pre>
    <p>tex : gs_texture</p>
    <p>Return : number</p>
    <p><pre>enum gs_color_format gs_texture_get_color_format(const gs_texture_t *tex)</pre></p>
    <hr/><h3>gs_texture_get_height(tex)</h3>
    <pre>
    Gets the texture's height
    
    :param tex: Texture object
    :return:    The texture's height
    
    </pre>
    <p>tex : gs_texture</p>
    <p>Return : number</p>
    <p><pre>uint32_t gs_texture_get_height(const gs_texture_t *tex)</pre></p>
    <hr/><h3>gs_texture_get_obj(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_texture</p>
    <hr/><h3>gs_texture_get_width(tex)</h3>
    <pre>
    Gets the texture's width
    
    :param tex: Texture object
    :return:    The texture's width
    
    </pre>
    <p>tex : gs_texture</p>
    <p>Return : number</p>
    <p><pre>uint32_t gs_texture_get_width(const gs_texture_t *tex)</pre></p>
    <hr/><h3>gs_texture_is_rect(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_texture</p>
    <hr/><h3>gs_texture_map(tex, ptr, linesize)</h3>
    <pre>
    Maps a texture.
    
    :param tex:      Texture object
    :param ptr:      Pointer to receive the pointer to the texture data
                     to write to
    :param linesize: Pointer to receive the line size (pitch) of the
                     texture
    
    </pre>
    <p>tex : gs_texture</p>
    <p>ptr : p_unsigned_char</p>
    <p>linesize : unsigned_int</p>
    <p>Return : boolean</p>
    <p><pre>bool     gs_texture_map(gs_texture_t *tex, uint8_t **ptr, uint32_t *linesize)</pre></p>
    <hr/><h3>gs_texture_set_image(tex, data, linesize, invert)</h3>
    <pre>
    Sets the image of a dynamic texture
    
    :param tex:      Texture object
    :param data:     Data to set as the image
    :param linesize: Line size (pitch) of the data
    :param invert:   *true* to invert vertically, *false* otherwise
    
    </pre>
    <p>tex : gs_texture</p>
    <p>data : unsigned_char</p>
    <p>linesize : number</p>
    <p>invert : boolean</p>
    <p><pre>void gs_texture_set_image(gs_texture_t *tex, const uint8_t *data, uint32_t linesize, bool invert)</pre></p>
    <hr/><h3>gs_texture_unmap(tex)</h3>
    <pre>
    Unmaps a texture.
    
    :param tex: Texture object
    
    </pre>
    <p>tex : gs_texture</p>
    <p><pre>void     gs_texture_unmap(gs_texture_t *tex)</pre></p>
    <hr/><h3>gs_timer_begin(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_timer</p>
    <hr/><h3>gs_timer_create()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>gs_timer_destroy(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_timer</p>
    <hr/><h3>gs_timer_end(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_timer</p>
    <hr/><h3>gs_timer_get_data(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_timer</p>
    <p>param2 : unsigned_long_long</p>
    <hr/><h3>gs_timer_range_begin(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_timer_range</p>
    <hr/><h3>gs_timer_range_create()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>gs_timer_range_destroy(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_timer_range</p>
    <hr/><h3>gs_timer_range_end(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_timer_range</p>
    <hr/><h3>gs_timer_range_get_data(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_timer_range</p>
    <p>param2 : bool</p>
    <p>param3 : unsigned_long_long</p>
    <hr/><h3>gs_vbdata_create()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>gs_vbdata_destroy(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_vb_data</p>
    <hr/><h3>gs_vertex2f(x, y)</h3>
    <pre>
    </pre>
    <p>x : number</p>
    <p>y : number</p>
    <p><pre>void gs_vertex2f(float x, float y)</pre></p>
    <hr/><h3>gs_vertex2v(v)</h3>
    <pre>
    </pre>
    <p>v : vec2</p>
    <p><pre>void gs_vertex2v(const struct vec2 *v)</pre></p>
    <hr/><h3>gs_vertex3f(x, y, z)</h3>
    <pre>
    </pre>
    <p>x : number</p>
    <p>y : number</p>
    <p>z : number</p>
    <p><pre>void gs_vertex3f(float x, float y, float z)</pre></p>
    <hr/><h3>gs_vertex3v(v)</h3>
    <pre>
    </pre>
    <p>v : vec3</p>
    <p><pre>void gs_vertex3v(const struct vec3 *v)</pre></p>
    <hr/><h3>gs_vertexbuffer_create(data, flags)</h3>
    <pre>
    Creates a vertex buffer.
    
    :param data:  Vertex buffer data to create vertex buffer with.  The
                  structure should be created with gs_vbdata_create(),
                  and then buffers in this structure should be allocated
                  with :c:func:`bmalloc()`, :c:func:`bzalloc()`, or
                  :c:func:`brealloc()`.  The ownership of the gs_vb_data
                  pointer is then passed to the function, and they should
                  not be destroyed by the caller once passed
    
    :param flags: Creation flags.  Can be 0 or a bitwise-OR combination
                  of any of the following values:
    
                  - GS_DYNAMIC - Can be dynamically updated in real time.
                  - GS_DUP_BUFFER - Do not pass buffer ownership of the
                    structure or the buffer pointers within the
                    structure.
    
    :return:      A new vertex buffer object, or *NULL* if failed
    
    </pre>
    <p>data : gs_vb_data</p>
    <p>flags : number</p>
    <p>Return : gs_vertex_buffer</p>
    <p><pre>gs_vertbuffer_t *gs_vertexbuffer_create(struct gs_vb_data *data, uint32_t flags)</pre></p>
    <hr/><h3>gs_vertexbuffer_destroy(vertbuffer)</h3>
    <pre>
    Destroys a vertex buffer object.
    
    :param vertbuffer: Vertex buffer object
    
    </pre>
    <p>vertbuffer : gs_vertex_buffer</p>
    <p><pre>void     gs_vertexbuffer_destroy(gs_vertbuffer_t *vertbuffer)</pre></p>
    <hr/><h3>gs_vertexbuffer_flush(vertbuffer)</h3>
    <pre>
    Flushes a vertex buffer to its interval vertex data object.  To
    modify its internal vertex data, call
    :c:func:`gs_vertexbuffer_get_data()`.
    
    Can only be used with dynamic vertex buffer objects.
    
    :param vertbuffer: Vertex buffer object
    
    </pre>
    <p>vertbuffer : gs_vertex_buffer</p>
    <p><pre>void     gs_vertexbuffer_flush(gs_vertbuffer_t *vertbuffer)</pre></p>
    <hr/><h3>gs_vertexbuffer_flush_direct(vertbuffer, data)</h3>
    <pre>
    Directly flushes a vertex buffer to the specified vertex buffer data.
    .
    
    Can only be used with dynamic vertex buffer objects.
    
    :param vertbuffer: Vertex buffer object
    :param data:       Vertex buffer data to flush.  Components that
                       don't need to be flushed can be left *NULL*
    
    </pre>
    <p>vertbuffer : gs_vertex_buffer</p>
    <p>data : gs_vb_data</p>
    <p><pre>void     gs_vertexbuffer_flush_direct(gs_vertbuffer_t *vertbuffer, const struct gs_vb_data *data)</pre></p>
    <hr/><h3>gs_vertexbuffer_get_data(vertbuffer)</h3>
    <pre>
    Gets the vertex buffer data associated with a vertex buffer object.
    This data can be changed and vertex buffer can be updated with
    :c:func:`gs_vertexbuffer_flush()`.
    
    Can only be used with dynamic vertex buffer objects.
    
    :param vertbuffer: Vertex buffer object
    :return:           Vertex buffer data structure
    
    </pre>
    <p>vertbuffer : gs_vertex_buffer</p>
    <p>Return : gs_vb_data</p>
    <p><pre>struct gs_vb_data *gs_vertexbuffer_get_data(const gs_vertbuffer_t *vertbuffer)</pre></p>
    <hr/><h3>gs_vertexshader_create(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <p>param2 : string</p>
    <p>param3 : p_char</p>
    <hr/><h3>gs_vertexshader_create_from_file(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <p>param2 : p_char</p>
    <hr/><h3>gs_viewport_pop()</h3>
    <pre>
    Pops/recalls the last pushed viewport
    
    </pre>
    <p><pre>void gs_viewport_pop(void)</pre></p>
    <hr/><h3>gs_viewport_push()</h3>
    <pre>
    Pushes/stores the current viewport
    
    </pre>
    <p><pre>void gs_viewport_push(void)</pre></p>
    <hr/><h3>gs_voltexture_create(param1, param2, param3, param4, param5, param6, param7)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : number</p>
    <p>param3 : number</p>
    <p>param4 : number</p>
    <p>param5 : number</p>
    <p>param6 : p_unsigned_char</p>
    <p>param7 : number</p>
    <hr/><h3>gs_voltexture_destroy(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_texture</p>
    <hr/><h3>gs_voltexture_get_color_format(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_texture</p>
    <hr/><h3>gs_voltexture_get_depth(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_texture</p>
    <hr/><h3>gs_voltexture_get_height(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_texture</p>
    <hr/><h3>gs_voltexture_get_width(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : gs_texture</p>
    <hr/><h3>gs_zstencil_create(width, height, format)</h3>
    <pre>
    Creates a Z-stencil surface object.
    
    :param width:  Width
    :param height: Height
    :param format: Format
    :return:       New Z-stencil surface object, or *NULL* if failed
    
    </pre>
    <p>width : number</p>
    <p>height : number</p>
    <p>format : number</p>
    <p>Return : gs_zstencil_buffer</p>
    <p><pre>gs_zstencil_t *gs_zstencil_create(uint32_t width, uint32_t height, enum gs_zstencil_format format)</pre></p>
    <hr/><h3>gs_zstencil_destroy(zstencil)</h3>
    <pre>
    Destroys a Z-stencil buffer.
    
    :param zstencil: Z-stencil surface object
    
    </pre>
    <p>zstencil : gs_zstencil_buffer</p>
    <p><pre>void     gs_zstencil_destroy(gs_zstencil_t *zstencil)</pre></p>
    <hr/><h3>matrix3_copy(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : matrix3</p>
    <hr/><h3>matrix3_from_axisang(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : axisang</p>
    <hr/><h3>matrix3_from_matrix4(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : matrix4</p>
    <hr/><h3>matrix3_from_quat(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : quat</p>
    <hr/><h3>matrix3_identity(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <hr/><h3>matrix3_inv(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : matrix3</p>
    <hr/><h3>matrix3_mirror(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : matrix3</p>
    <p>param3 : plane</p>
    <hr/><h3>matrix3_mirrorv(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : matrix3</p>
    <p>param3 : vec3</p>
    <hr/><h3>matrix3_mul(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : matrix3</p>
    <p>param3 : matrix3</p>
    <hr/><h3>matrix3_rotate(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : matrix3</p>
    <p>param3 : quat</p>
    <hr/><h3>matrix3_rotate_aa(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : matrix3</p>
    <p>param3 : axisang</p>
    <hr/><h3>matrix3_rotate_aa4f(param1, param2, param3, param4, param5, param6)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : matrix3</p>
    <p>param3 : number</p>
    <p>param4 : number</p>
    <p>param5 : number</p>
    <p>param6 : number</p>
    <hr/><h3>matrix3_scale(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : matrix3</p>
    <p>param3 : vec3</p>
    <hr/><h3>matrix3_scale3f(param1, param2, param3, param4, param5)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : matrix3</p>
    <p>param3 : number</p>
    <p>param4 : number</p>
    <p>param5 : number</p>
    <hr/><h3>matrix3_translate(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : matrix3</p>
    <p>param3 : vec3</p>
    <hr/><h3>matrix3_translate3f(param1, param2, param3, param4, param5)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : matrix3</p>
    <p>param3 : number</p>
    <p>param4 : number</p>
    <p>param5 : number</p>
    <hr/><h3>matrix3_transpose(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix3</p>
    <p>param2 : matrix3</p>
    <hr/><h3>matrix4_copy(dst, m)</h3>
    <pre>
    Copies a matrix
    
    :param dst: Destination matrix
    :param m:   Matrix to copy
    
    </pre>
    <p>dst : matrix4</p>
    <p>m : matrix4</p>
    <p><pre>void matrix4_copy(struct matrix4 *dst, const struct matrix4 *m)</pre></p>
    <hr/><h3>matrix4_determinant(m)</h3>
    <pre>
    Gets the determinant value of a matrix
    
    :param m: Matrix
    :return:  Determinant
    
    </pre>
    <p>m : matrix4</p>
    <p>Return : number</p>
    <p><pre>float matrix4_determinant(const struct matrix4 *m)</pre></p>
    <hr/><h3>matrix4_from_axisang(dst, aa)</h3>
    <pre>
    Converts an axis angle to a matrix
    
    :param dst: Destination matrix
    :param aa:  Axis angle to convert
    
    </pre>
    <p>dst : matrix4</p>
    <p>aa : axisang</p>
    <p><pre>void matrix4_from_axisang(struct matrix4 *dst, const struct axisang *aa)</pre></p>
    <hr/><h3>matrix4_from_matrix3(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix4</p>
    <p>param2 : matrix3</p>
    <hr/><h3>matrix4_from_quat(dst, q)</h3>
    <pre>
    Converts a quaternion to a matrix
    
    :param dst: Destination matrix
    :param q:   Quaternion to convert
    
    </pre>
    <p>dst : matrix4</p>
    <p>q : quat</p>
    <p><pre>void matrix4_from_quat(struct matrix4 *dst, const struct quat *q)</pre></p>
    <hr/><h3>matrix4_identity(dst)</h3>
    <pre>
    Sets an identity matrix
    
    :param dst: Destination matrix
    
    </pre>
    <p>dst : matrix4</p>
    <p><pre>void matrix4_identity(struct matrix4 *dst)</pre></p>
    <hr/><h3>matrix4_inv(dst, m)</h3>
    <pre>
    Inverts a matrix
    
    :param dst: Destination matrix
    :param m:   Matrix to invert
    
    </pre>
    <p>dst : matrix4</p>
    <p>m : matrix4</p>
    <p>Return : boolean</p>
    <p><pre>bool matrix4_inv(struct matrix4 *dst, const struct matrix4 *m)</pre></p>
    <hr/><h3>matrix4_mul(dst, m1, m2)</h3>
    <pre>
    Multiples two matrices
    
    :param dst: Destination matrix
    :param m1:  Matrix 1
    :param m2:  Matrix 2
    
    </pre>
    <p>dst : matrix4</p>
    <p>m1 : matrix4</p>
    <p>m2 : matrix4</p>
    <p><pre>void matrix4_mul(struct matrix4 *dst, const struct matrix4 *m1, const struct matrix4 *m2)</pre></p>
    <hr/><h3>matrix4_rotate(dst, m, q)</h3>
    <pre>
    Rotates a matrix by a quaternion
    
    :param dst: Destination matrix
    :param m:   Matrix to rotate
    :param q:   Rotation quaternion
    
    </pre>
    <p>dst : matrix4</p>
    <p>m : matrix4</p>
    <p>q : quat</p>
    <p><pre>void matrix4_rotate(struct matrix4 *dst, const struct matrix4 *m, const struct quat *q)</pre></p>
    <hr/><h3>matrix4_rotate_aa(dst, m, aa)</h3>
    <pre>
    Rotates a matrix by an axis angle
    
    :param dst: Destination matrix
    :param m:   Matrix to rotate
    :param aa:  Rotation anxis angle
    
    </pre>
    <p>dst : matrix4</p>
    <p>m : matrix4</p>
    <p>aa : axisang</p>
    <p><pre>void matrix4_rotate_aa(struct matrix4 *dst, const struct matrix4 *m, const struct axisang *aa)</pre></p>
    <hr/><h3>matrix4_rotate_aa4f(dst, m, x, y, z, rot)</h3>
    <pre>
    Rotates a matrix by an axis angle
    
    :param dst: Destination matrix
    :param m:   Matrix to rotate
    :param aa:  Rotation anxis angle
    
    </pre>
    <p>dst : matrix4</p>
    <p>m : matrix4</p>
    <p>x : number</p>
    <p>y : number</p>
    <p>z : number</p>
    <p>rot : number</p>
    <p><pre>void matrix4_rotate_aa4f(struct matrix4 *dst, const struct matrix4 *m, float x, float y, float z, float rot)</pre></p>
    <hr/><h3>matrix4_rotate_aa_i(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix4</p>
    <p>param2 : axisang</p>
    <p>param3 : matrix4</p>
    <hr/><h3>matrix4_rotate_i(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix4</p>
    <p>param2 : quat</p>
    <p>param3 : matrix4</p>
    <hr/><h3>matrix4_scale(dst, m, v)</h3>
    <pre>
    Scales each matrix component by the components of a 3-component vector
    
    :param dst: Destination matrix
    :param m:   Matrix to scale
    :param v:   Scale vector
    
    </pre>
    <p>dst : matrix4</p>
    <p>m : matrix4</p>
    <p>v : vec3</p>
    <p><pre>void matrix4_scale(struct matrix4 *dst, const struct matrix4 *m, const struct vec3 *v)</pre></p>
    <hr/><h3>matrix4_scale3f(dst, m, x, y, z)</h3>
    <pre>
    Scales each matrix component by the components of a 3-component vector
    
    :param dst: Destination matrix
    :param m:   Matrix to scale
    :param v:   Scale vector
    
    </pre>
    <p>dst : matrix4</p>
    <p>m : matrix4</p>
    <p>x : number</p>
    <p>y : number</p>
    <p>z : number</p>
    <p><pre>void matrix4_scale3f(struct matrix4 *dst, const struct matrix4 *m, float x, float y, float z)</pre></p>
    <hr/><h3>matrix4_scale_i(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix4</p>
    <p>param2 : vec3</p>
    <p>param3 : matrix4</p>
    <hr/><h3>matrix4_translate3f(dst, m, x, y, z)</h3>
    <pre>
    Translates the matrix by a 3-component vector
    
    :param dst: Destination matrix
    :param m:   Matrix to translate
    :param v:   Translation vector
    
    </pre>
    <p>dst : matrix4</p>
    <p>m : matrix4</p>
    <p>x : number</p>
    <p>y : number</p>
    <p>z : number</p>
    <p><pre>void matrix4_translate3f(struct matrix4 *dst, const struct matrix4 *m, float x, float y, float z)</pre></p>
    <hr/><h3>matrix4_translate3v(dst, m, v)</h3>
    <pre>
    Translates the matrix by a 3-component vector
    
    :param dst: Destination matrix
    :param m:   Matrix to translate
    :param v:   Translation vector
    
    </pre>
    <p>dst : matrix4</p>
    <p>m : matrix4</p>
    <p>v : vec3</p>
    <p><pre>void matrix4_translate3v(struct matrix4 *dst, const struct matrix4 *m, const struct vec3 *v)</pre></p>
    <hr/><h3>matrix4_translate3v_i(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix4</p>
    <p>param2 : vec3</p>
    <p>param3 : matrix4</p>
    <hr/><h3>matrix4_translate4v(dst, m, v)</h3>
    <pre>
    Translates the matrix by a 4-component vector
    
    :param dst: Destination matrix
    :param m:   Matrix to translate
    :param v:   Translation vector
    
    </pre>
    <p>dst : matrix4</p>
    <p>m : matrix4</p>
    <p>v : vec4</p>
    <p><pre>void matrix4_translate4v(struct matrix4 *dst, const struct matrix4 *m, const struct vec4 *v)</pre></p>
    <hr/><h3>matrix4_translate4v_i(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : matrix4</p>
    <p>param2 : vec4</p>
    <p>param3 : matrix4</p>
    <hr/><h3>matrix4_transpose(dst, m)</h3>
    <pre>
    Transposes a matrix
    
    :param dst: Destination matrix
    :param m:   Matrix to transpose
    </pre>
    <p>dst : matrix4</p>
    <p>m : matrix4</p>
    <p><pre>void matrix4_transpose(struct matrix4 *dst, const struct matrix4 *m)</pre></p>
    <hr/><h3>obs_add_data_path(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <hr/><h3>obs_add_main_render_callback(callback)</h3>
    <pre>
    **Lua only:** Adds a primary output render callback.  This callback
    has no parameters.
    
    :param callback: Render callback.  Use
                     :py:func:`obs_remove_main_render_callback()` or
                     :py:func:`remove_current_callback()` to remove the
                     callback.
    
    </pre>
    <p>callback : unknown</p>
    <p>Return : unknown</p>
    <hr/><h3>obs_add_module_path(bin, data)</h3>
    <pre>
    Adds a module search path to be used with obs_find_modules.  If the search
    path strings contain %module%, that text will be replaced with the module
    name when used.
    
    :param  bin:  Specifies the module's binary directory search path
    :param  data: Specifies the module's data directory search path
    
    </pre>
    <p>bin : string</p>
    <p>data : string</p>
    <p><pre>void obs_add_module_path(const char *bin, const char *data)</pre></p>
    <hr/><h3>obs_add_raw_video_callback(conversion, callback, param)</h3>
    <pre>
    Adds/removes a raw video callback.  Allows the ability to obtain raw
    video frames without necessarily using an output.
    
    :param conversion: Specifies conversion requirements.  Can be NULL.
    :param callback:   The callback that receives raw video frames.
    :param param:      The private data associated with the callback.
    
    Primary signal/procedure handlers
    </pre>
    <p>conversion : video_scale_info</p>
    <p>callback : f_p_void_p_struct_video_data__void</p>
    <p>param : ref_void*</p>
    <p><pre>void obs_add_raw_video_callback(const struct video_scale_info *conversion, void (*callback)(void *param, struct video_data *frame), void *param)</pre></p>
    <hr/><h3>obs_apply_private_data(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <hr/><h3>obs_audio_encoder_create(id, name, settings, mixer_idx, hotkey_data)</h3>
    <pre>
    Creates an audio encoder with the specified settings.
    
    The "encoder" context is used for encoding video/audio data.  Use
    :c:func:`obs_encoder_release()` to release it.
    
    :param   id:             The encoder type string identifier
    :param   name:           The desired name of the encoder.  If this is
                             not unique, it will be made to be unique
    :param   settings:       The settings for the encoder, or *NULL* if
                             none
    :param   mixer_idx:      The audio mixer index this audio encoder
                             will capture audio from
    :param   hotkey_data:    Saved hotkey data for the encoder, or *NULL*
                             if none
    :return:                 A reference to the newly created encoder, or
                             *NULL* if failed
    
    </pre>
    <p>id : string</p>
    <p>name : string</p>
    <p>settings : obs_data</p>
    <p>mixer_idx : number</p>
    <p>hotkey_data : obs_data</p>
    <p>Return : obs_encoder</p>
    <p><pre>obs_encoder_t *obs_audio_encoder_create(const char *id, const char *name, obs_data_t *settings, size_t mixer_idx, obs_data_t *hotkey_data)</pre></p>
    <hr/><h3>obs_data_addref(data)</h3>
    <pre>
    Adds/releases a reference to a data object.
    
    </pre>
    <p>data : obs_data</p>
    <p><pre>void obs_data_addref(obs_data_t *data)</pre></p>
    <hr/><h3>obs_data_apply(target, apply_data)</h3>
    <pre>
    Merges the data of *apply_data* in to *target*.
    
    </pre>
    <p>target : obs_data</p>
    <p>apply_data : obs_data</p>
    <p><pre>void obs_data_apply(obs_data_t *target, obs_data_t *apply_data)</pre></p>
    <hr/><h3>obs_data_array_addref(array)</h3>
    <pre>
    </pre>
    <p>array : obs_data_array</p>
    <p><pre>void obs_data_array_addref(obs_data_array_t *array)</pre></p>
    <hr/><h3>obs_data_array_count(array)</h3>
    <pre>
    </pre>
    <p>array : obs_data_array</p>
    <p>Return : number</p>
    <p><pre>size_t obs_data_array_count(obs_data_array_t *array)</pre></p>
    <hr/><h3>obs_data_array_create()</h3>
    <pre>
    :return: A new reference to a data array object.
    
    </pre>
    <p>Return : obs_data_array</p>
    <p><pre>obs_data_array_t *obs_data_array_create()</pre></p>
    <hr/><h3>obs_data_array_erase(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_array</p>
    <p>param2 : number</p>
    <hr/><h3>obs_data_array_insert(array, idx, obj)</h3>
    <pre>
    </pre>
    <p>array : obs_data_array</p>
    <p>idx : number</p>
    <p>obj : obs_data</p>
    <p><pre>void obs_data_array_insert(obs_data_array_t *array, size_t idx, obs_data_t *obj)</pre></p>
    <hr/><h3>obs_data_array_item(array, idx)</h3>
    <pre>
    :return: An incremented reference to the data object associated with
             this array entry.
    
    </pre>
    <p>array : obs_data_array</p>
    <p>idx : number</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_data_array_item(obs_data_array_t *array, size_t idx)</pre></p>
    <hr/><h3>obs_data_array_push_back(array, obj)</h3>
    <pre>
    </pre>
    <p>array : obs_data_array</p>
    <p>obj : obs_data</p>
    <p>Return : number</p>
    <p><pre>size_t obs_data_array_push_back(obs_data_array_t *array, obs_data_t *obj)</pre></p>
    <hr/><h3>obs_data_array_push_back_array(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_array</p>
    <p>param2 : obs_data_array</p>
    <hr/><h3>obs_data_array_release(array)</h3>
    <pre>
    </pre>
    <p>array : obs_data_array</p>
    <p><pre>void obs_data_array_release(obs_data_array_t *array)</pre></p>
    <hr/><h3>obs_data_clear(data)</h3>
    <pre>
    Clears all user data in the data object.
    
    </pre>
    <p>data : obs_data</p>
    <p><pre>void obs_data_clear(obs_data_t *data)</pre></p>
    <hr/><h3>obs_data_create()</h3>
    <pre>
    :return: A new reference to a data object.
    
    </pre>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_data_create()</pre></p>
    <hr/><h3>obs_data_create_from_json(json_string)</h3>
    <pre>
    Creates a data object from a Json string.
    
    :param json_string: Json string
    :return:            A new reference to a data object
    
    </pre>
    <p>json_string : string</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_data_create_from_json(const char *json_string)</pre></p>
    <hr/><h3>obs_data_create_from_json_file(json_file)</h3>
    <pre>
    Creates a data object from a Json file.
    
    :param json_file: Json file path
    :return:          A new reference to a data object
    
    </pre>
    <p>json_file : string</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_data_create_from_json_file(const char *json_file)</pre></p>
    <hr/><h3>obs_data_create_from_json_file_safe(json_file, backup_ext)</h3>
    <pre>
    Creates a data object from a Json file, with a backup file in case
    the original is corrupted or fails to load.
    
    :param json_file:  Json file path
    :param backup_ext: Backup file extension
    :return:           A new reference to a data object
    
    </pre>
    <p>json_file : string</p>
    <p>backup_ext : string</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_data_create_from_json_file_safe(const char *json_file, const char *backup_ext)</pre></p>
    <hr/><h3>obs_data_erase(data, name)</h3>
    <pre>
    Erases the user data for item *name* within the data object.
    
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p><pre>void obs_data_erase(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_first(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <hr/><h3>obs_data_get_array(data, name)</h3>
    <pre>
    :return: An incremented reference to a data array object.
    
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : obs_data_array</p>
    <p><pre>obs_data_array_t *obs_data_get_array(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_autoselect_array(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <hr/><h3>obs_data_get_autoselect_bool(data, name)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_data_get_autoselect_bool(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_autoselect_double(data, name)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : number</p>
    <p><pre>double obs_data_get_autoselect_double(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_autoselect_frames_per_second(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : media_frames_per_second</p>
    <p>param4 : p_char</p>
    <hr/><h3>obs_data_get_autoselect_int(data, name)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : number</p>
    <p><pre>long long obs_data_get_autoselect_int(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_autoselect_obj(data, name)</h3>
    <pre>
    :return: An incremented reference to a data object.
    
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_data_get_autoselect_obj(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_autoselect_quat(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : quat</p>
    <hr/><h3>obs_data_get_autoselect_string(data, name)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : string</p>
    <p><pre>const char *obs_data_get_autoselect_string(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_autoselect_vec2(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec2</p>
    <hr/><h3>obs_data_get_autoselect_vec3(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec3</p>
    <hr/><h3>obs_data_get_autoselect_vec4(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec4</p>
    <hr/><h3>obs_data_get_bool(data, name)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_data_get_bool(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_default_array(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <hr/><h3>obs_data_get_default_bool(data, name)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_data_get_default_bool(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_default_double(data, name)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : number</p>
    <p><pre>double obs_data_get_default_double(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_default_frames_per_second(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : media_frames_per_second</p>
    <p>param4 : p_char</p>
    <hr/><h3>obs_data_get_default_int(data, name)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : number</p>
    <p><pre>long long obs_data_get_default_int(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_default_obj(data, name)</h3>
    <pre>
    :return: An incremented reference to a data object.
    
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_data_get_default_obj(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_default_quat(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : quat</p>
    <hr/><h3>obs_data_get_default_string(data, name)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : string</p>
    <p><pre>const char *obs_data_get_default_string(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_default_vec2(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec2</p>
    <hr/><h3>obs_data_get_default_vec3(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec3</p>
    <hr/><h3>obs_data_get_default_vec4(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec4</p>
    <hr/><h3>obs_data_get_double(data, name)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : number</p>
    <p><pre>double obs_data_get_double(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_frames_per_second(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : media_frames_per_second</p>
    <p>param4 : p_char</p>
    <hr/><h3>obs_data_get_int(data, name)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : number</p>
    <p><pre>long long obs_data_get_int(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_json(data)</h3>
    <pre>
    :return: Json string for this object
    
    </pre>
    <p>data : obs_data</p>
    <p>Return : string</p>
    <p><pre>const char *obs_data_get_json(obs_data_t *data)</pre></p>
    <hr/><h3>obs_data_get_obj(data, name)</h3>
    <pre>
    :return: An incremented reference to a data object.
    
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_data_get_obj(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_quat(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : quat</p>
    <hr/><h3>obs_data_get_string(data, name)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>Return : string</p>
    <p><pre>const char *obs_data_get_string(obs_data_t *data, const char *name)</pre></p>
    <hr/><h3>obs_data_get_vec2(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec2</p>
    <hr/><h3>obs_data_get_vec3(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec3</p>
    <hr/><h3>obs_data_get_vec4(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec4</p>
    <hr/><h3>obs_data_has_autoselect_value(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <hr/><h3>obs_data_has_default_value(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <hr/><h3>obs_data_has_user_value(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <hr/><h3>obs_data_item_byname(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <hr/><h3>obs_data_item_get_array(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_autoselect_array(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_autoselect_bool(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_autoselect_double(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_autoselect_frames_per_second(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <p>param2 : media_frames_per_second</p>
    <p>param3 : p_char</p>
    <hr/><h3>obs_data_item_get_autoselect_int(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_autoselect_obj(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_autoselect_string(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_bool(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_default_array(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_default_bool(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_default_double(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_default_frames_per_second(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <p>param2 : media_frames_per_second</p>
    <p>param3 : p_char</p>
    <hr/><h3>obs_data_item_get_default_int(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_default_obj(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_default_string(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_double(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_frames_per_second(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <p>param2 : media_frames_per_second</p>
    <p>param3 : p_char</p>
    <hr/><h3>obs_data_item_get_int(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_name(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_obj(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_get_string(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_gettype(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_has_autoselect_value(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_has_default_value(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_has_user_value(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_next(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <hr/><h3>obs_data_item_numtype(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_release(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <hr/><h3>obs_data_item_remove(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <hr/><h3>obs_data_item_set_array(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : obs_data_array</p>
    <hr/><h3>obs_data_item_set_autoselect_array(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : obs_data_array</p>
    <hr/><h3>obs_data_item_set_autoselect_bool(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : boolean</p>
    <hr/><h3>obs_data_item_set_autoselect_double(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : number</p>
    <hr/><h3>obs_data_item_set_autoselect_frames_per_second(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : media_frames_per_second</p>
    <p>param3 : string</p>
    <hr/><h3>obs_data_item_set_autoselect_int(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : number</p>
    <hr/><h3>obs_data_item_set_autoselect_obj(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : obs_data</p>
    <hr/><h3>obs_data_item_set_autoselect_string(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : string</p>
    <hr/><h3>obs_data_item_set_bool(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : boolean</p>
    <hr/><h3>obs_data_item_set_default_array(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : obs_data_array</p>
    <hr/><h3>obs_data_item_set_default_bool(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : boolean</p>
    <hr/><h3>obs_data_item_set_default_double(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : number</p>
    <hr/><h3>obs_data_item_set_default_frames_per_second(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : media_frames_per_second</p>
    <p>param3 : string</p>
    <hr/><h3>obs_data_item_set_default_int(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : number</p>
    <hr/><h3>obs_data_item_set_default_obj(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : obs_data</p>
    <hr/><h3>obs_data_item_set_default_string(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : string</p>
    <hr/><h3>obs_data_item_set_double(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : number</p>
    <hr/><h3>obs_data_item_set_frames_per_second(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : media_frames_per_second</p>
    <p>param3 : string</p>
    <hr/><h3>obs_data_item_set_int(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : number</p>
    <hr/><h3>obs_data_item_set_obj(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : obs_data</p>
    <hr/><h3>obs_data_item_set_string(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : p_obs_data_item</p>
    <p>param2 : string</p>
    <hr/><h3>obs_data_item_unset_autoselect_value(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_unset_default_value(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_item_unset_user_value(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data_item</p>
    <hr/><h3>obs_data_newref(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <hr/><h3>obs_data_release(data)</h3>
    <pre>
    Adds/releases a reference to a data object.
    
    </pre>
    <p>data : obs_data</p>
    <p><pre>void obs_data_release(obs_data_t *data)</pre></p>
    <hr/><h3>obs_data_save_json(data, file)</h3>
    <pre>
    Saves the data to a file as Json text.
    
    :param file: The file to save to
    :return:     *true* if successful, *false* otherwise
    
    </pre>
    <p>data : obs_data</p>
    <p>file : string</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_data_save_json(obs_data_t *data, const char *file)</pre></p>
    <hr/><h3>obs_data_save_json_safe(data, file, temp_ext, backup_ext)</h3>
    <pre>
    Saves the data to a file as Json text, and if overwriting an old
    file, backs up that old file to help prevent potential file
    corruption.
    
    :param file:       The file to save to
    :param backup_ext: The backup extension to use for the overwritten
                       file if it exists
    :return:           *true* if successful, *false* otherwise
    
    </pre>
    <p>data : obs_data</p>
    <p>file : string</p>
    <p>temp_ext : string</p>
    <p>backup_ext : string</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_data_save_json_safe(obs_data_t *data, const char *file, const char *temp_ext, const char *backup_ext)</pre></p>
    <hr/><h3>obs_data_set_array(data, name, array)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>array : obs_data_array</p>
    <p><pre>void obs_data_set_array(obs_data_t *data, const char *name, obs_data_array_t *array)</pre></p>
    <hr/><h3>obs_data_set_autoselect_bool(data, name, val)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>val : boolean</p>
    <p><pre>void obs_data_set_autoselect_bool(obs_data_t *data, const char *name, bool val)</pre></p>
    <hr/><h3>obs_data_set_autoselect_double(data, name, val)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>val : number</p>
    <p><pre>void obs_data_set_autoselect_double(obs_data_t *data, const char *name, double val)</pre></p>
    <hr/><h3>obs_data_set_autoselect_frames_per_second(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : media_frames_per_second</p>
    <p>param4 : string</p>
    <hr/><h3>obs_data_set_autoselect_int(data, name, val)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>val : number</p>
    <p><pre>void obs_data_set_autoselect_int(obs_data_t *data, const char *name, long long val)</pre></p>
    <hr/><h3>obs_data_set_autoselect_obj(data, name, obj)</h3>
    <pre>
    :return: An incremented reference to a data object.
    
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>obj : obs_data</p>
    <p><pre>void obs_data_set_autoselect_obj(obs_data_t *data, const char *name, obs_data_t *obj)</pre></p>
    <hr/><h3>obs_data_set_autoselect_quat(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : quat</p>
    <hr/><h3>obs_data_set_autoselect_string(data, name, val)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>val : string</p>
    <p><pre>void obs_data_set_autoselect_string(obs_data_t *data, const char *name, const char *val)</pre></p>
    <hr/><h3>obs_data_set_autoselect_vec2(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec2</p>
    <hr/><h3>obs_data_set_autoselect_vec3(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec3</p>
    <hr/><h3>obs_data_set_autoselect_vec4(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec4</p>
    <hr/><h3>obs_data_set_bool(data, name, val)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>val : boolean</p>
    <p><pre>void obs_data_set_bool(obs_data_t *data, const char *name, bool val)</pre></p>
    <hr/><h3>obs_data_set_default_bool(data, name, val)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>val : boolean</p>
    <p><pre>void obs_data_set_default_bool(obs_data_t *data, const char *name, bool val)</pre></p>
    <hr/><h3>obs_data_set_default_double(data, name, val)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>val : number</p>
    <p><pre>void obs_data_set_default_double(obs_data_t *data, const char *name, double val)</pre></p>
    <hr/><h3>obs_data_set_default_frames_per_second(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : media_frames_per_second</p>
    <p>param4 : string</p>
    <hr/><h3>obs_data_set_default_int(data, name, val)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>val : number</p>
    <p><pre>void obs_data_set_default_int(obs_data_t *data, const char *name, long long val)</pre></p>
    <hr/><h3>obs_data_set_default_obj(data, name, obj)</h3>
    <pre>
    :return: An incremented reference to a data object.
    
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>obj : obs_data</p>
    <p><pre>void obs_data_set_default_obj(obs_data_t *data, const char *name, obs_data_t *obj)</pre></p>
    <hr/><h3>obs_data_set_default_quat(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : quat</p>
    <hr/><h3>obs_data_set_default_string(data, name, val)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>val : string</p>
    <p><pre>void obs_data_set_default_string(obs_data_t *data, const char *name, const char *val)</pre></p>
    <hr/><h3>obs_data_set_default_vec2(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec2</p>
    <hr/><h3>obs_data_set_default_vec3(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec3</p>
    <hr/><h3>obs_data_set_default_vec4(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec4</p>
    <hr/><h3>obs_data_set_double(data, name, val)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>val : number</p>
    <p><pre>void obs_data_set_double(obs_data_t *data, const char *name, double val)</pre></p>
    <hr/><h3>obs_data_set_frames_per_second(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : media_frames_per_second</p>
    <p>param4 : string</p>
    <hr/><h3>obs_data_set_int(data, name, val)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>val : number</p>
    <p><pre>void obs_data_set_int(obs_data_t *data, const char *name, long long val)</pre></p>
    <hr/><h3>obs_data_set_obj(data, name, obj)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>obj : obs_data</p>
    <p><pre>void obs_data_set_obj(obs_data_t *data, const char *name, obs_data_t *obj)</pre></p>
    <hr/><h3>obs_data_set_quat(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : quat</p>
    <hr/><h3>obs_data_set_string(data, name, val)</h3>
    <pre>
    </pre>
    <p>data : obs_data</p>
    <p>name : string</p>
    <p>val : string</p>
    <p><pre>void obs_data_set_string(obs_data_t *data, const char *name, const char *val)</pre></p>
    <hr/><h3>obs_data_set_vec2(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec2</p>
    <hr/><h3>obs_data_set_vec3(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec3</p>
    <hr/><h3>obs_data_set_vec4(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <p>param3 : vec4</p>
    <hr/><h3>obs_data_unset_autoselect_value(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <hr/><h3>obs_data_unset_default_value(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <hr/><h3>obs_data_unset_user_value(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <p>param2 : string</p>
    <hr/><h3>obs_display_add_draw_callback(display, draw, param)</h3>
    <pre>
    Adds a draw callback for a display context, which will be called
    whenever the display is rendered.
    
    :param  display: The display context
    :param  draw:    The draw callback which is called each time a frame
                     updates
    :param  param:   The user data to be associated with this draw callback
    
    </pre>
    <p>display : obs_display</p>
    <p>draw : f_p_void_unsigned_int_unsigned_int__void</p>
    <p>param : ref_void*</p>
    <p><pre>void obs_display_add_draw_callback(obs_display_t *display, void (*draw)(void *param, uint32_t cx, uint32_t cy), void *param)</pre></p>
    <hr/><h3>obs_display_create(graphics_data, param2)</h3>
    <pre>
    Adds a new window display linked to the main render pipeline.  This creates
    a new swap chain which updates every frame.
    
    *(Important note: do not use more than one display widget within the
    hierarchy of the same base window; this will cause presentation
    stalls on Macs.)*
    
    :param  graphics_data: The swap chain initialization data
    :return:               The new display context, or NULL if failed
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    enum gs_color_format {
            [...]
            GS_RGBA,
            GS_BGRX,
            GS_BGRA,
            GS_RGBA16F,
            GS_RGBA32F,
            [...]
    };
    
    enum gs_zstencil_format {
            GS_ZS_NONE,
            GS_Z16,
            GS_Z24_S8,
            GS_Z32F,
            GS_Z32F_S8X24
    };
    
    struct gs_window {
    #if defined(_WIN32)
            void                    *hwnd;
    #elif defined(__APPLE__)
            __unsafe_unretained id  view;
    #elif defined(__linux__) || defined(__FreeBSD__)
            uint32_t                id;
            void                    *display;
    #endif
    };
    
    struct gs_init_data {
            struct gs_window        window;
            uint32_t                cx, cy;
            uint32_t                num_backbuffers;
            enum gs_color_format    format;
            enum gs_zstencil_format zsformat;
            uint32_t                adapter;
    };
    
    </pre>
    <p>graphics_data : gs_init_data</p>
    <p>param2 : number</p>
    <p>Return : obs_display</p>
    <p><pre>obs_display_t *obs_display_create(const struct gs_init_data *graphics_data)</pre></p>
    <hr/><h3>obs_display_destroy(display)</h3>
    <pre>
    Destroys a display context.
    
    </pre>
    <p>display : obs_display</p>
    <p><pre>void obs_display_destroy(obs_display_t *display)</pre></p>
    <hr/><h3>obs_display_enabled(display)</h3>
    <pre>
    :return: *true* if the display is enabled, *false* otherwise
    
    </pre>
    <p>display : obs_display</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_display_enabled(obs_display_t *display)</pre></p>
    <hr/><h3>obs_display_remove_draw_callback(display, draw, param)</h3>
    <pre>
    Removes a draw callback for a display context.
    
    </pre>
    <p>display : obs_display</p>
    <p>draw : f_p_void_unsigned_int_unsigned_int__void</p>
    <p>param : ref_void*</p>
    <p><pre>void obs_display_remove_draw_callback(obs_display_t *display, void (*draw)(void *param, uint32_t cx, uint32_t cy), void *param)</pre></p>
    <hr/><h3>obs_display_resize(display, cx, cy)</h3>
    <pre>
    Changes the size of a display context.
    
    </pre>
    <p>display : obs_display</p>
    <p>cx : number</p>
    <p>cy : number</p>
    <p><pre>void obs_display_resize(obs_display_t *display, uint32_t cx, uint32_t cy)</pre></p>
    <hr/><h3>obs_display_set_background_color(display, color)</h3>
    <pre>
    Sets the background (clear) color for the display context.
    </pre>
    <p>display : obs_display</p>
    <p>color : number</p>
    <p><pre>void obs_display_set_background_color(obs_display_t *display, uint32_t color)</pre></p>
    <hr/><h3>obs_display_set_enabled(display, enable)</h3>
    <pre>
    Enables/disables a display context.
    
    </pre>
    <p>display : obs_display</p>
    <p>enable : boolean</p>
    <p><pre>void obs_display_set_enabled(obs_display_t *display, bool enable)</pre></p>
    <hr/><h3>obs_display_size(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_display</p>
    <p>param2 : unsigned_int</p>
    <p>param3 : unsigned_int</p>
    <hr/><h3>obs_encoder_active(encoder)</h3>
    <pre>
    :return: *true* if the encoder is active, *false* otherwise
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_encoder_active(const obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_addref(encoder)</h3>
    <pre>
    Adds/releases a reference to an encoder.  When the last reference is
    released, the encoder is destroyed.
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p><pre>void obs_encoder_addref(obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_audio(encoder)</h3>
    <pre>
    :return: The video/audio handler associated with this encoder, or
             *NULL* if none or not a matching encoder type
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>Return : audio_t</p>
    <p><pre>audio_t *obs_encoder_audio(const obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_create_rerouted(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_encoder</p>
    <p>param2 : string</p>
    <hr/><h3>obs_encoder_defaults(id)</h3>
    <pre>
    :return: An incremented reference to the encoder's default settings
    
    </pre>
    <p>id : string</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_encoder_defaults(const char *id)</pre></p>
    <hr/><h3>obs_encoder_get_caps(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_encoder</p>
    <hr/><h3>obs_encoder_get_codec(encoder)</h3>
    <pre>
    :return: The codec identifier of the encoder
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>Return : string</p>
    <p><pre>const char *obs_encoder_get_codec(const obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_get_defaults(encoder)</h3>
    <pre>
    :return: An incremented reference to the encoder's default settings
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_encoder_get_defaults(const obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_get_display_name(id)</h3>
    <pre>
    Calls the :c:member:`obs_encoder_info.get_name` callback to get the
    translated display name of an encoder type.
    
    :param    id:            The encoder type string identifier
    :return:                 The translated display name of an encoder type
    
    </pre>
    <p>id : string</p>
    <p>Return : string</p>
    <p><pre>const char *obs_encoder_get_display_name(const char *id)</pre></p>
    <hr/><h3>obs_encoder_get_extra_data(encoder, extra_data, size)</h3>
    <pre>
    Gets extra data (headers) associated with this encoder.
    
    :return: *true* if successful, *false* if no extra data associated
             with this encoder
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>extra_data : p_unsigned_char</p>
    <p>size : size_t</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_encoder_get_extra_data(const obs_encoder_t *encoder, uint8_t **extra_data, size_t *size)</pre></p>
    <hr/><h3>obs_encoder_get_height(encoder)</h3>
    <pre>
    :return: The width/height of a video encoder's encoded image
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_encoder_get_height(const obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_get_id(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_encoder</p>
    <hr/><h3>obs_encoder_get_last_error(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_encoder</p>
    <hr/><h3>obs_encoder_get_name(encoder)</h3>
    <pre>
    :return: The name of the encoder
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>Return : string</p>
    <p><pre>const char *obs_encoder_get_name(const obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_get_preferred_video_format(encoder)</h3>
    <pre>
    Sets the preferred video format for a video encoder.  If the encoder can use
    the format specified, it will force a conversion to that format if the
    obs output format does not match the preferred format.
    
    If the format is set to VIDEO_FORMAT_NONE, will revert to the default
    functionality of converting only when absolutely necessary.
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>Return : number</p>
    <p><pre>enum video_format obs_encoder_get_preferred_video_format(const obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_get_ref(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_encoder</p>
    <hr/><h3>obs_encoder_get_sample_rate(encoder)</h3>
    <pre>
    :return: The sample rate of an audio encoder's audio data
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_encoder_get_sample_rate(const obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_get_settings(encoder)</h3>
    <pre>
    :return: An incremented reference to the encoder's settings
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_encoder_get_settings(const obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_get_type(encoder)</h3>
    <pre>
    :return: The encoder type: OBS_ENCODER_VIDEO or OBS_ENCODER_AUDIO
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>Return : number</p>
    <p><pre>enum obs_encoder_type obs_encoder_get_type(const obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_get_type_data(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_encoder</p>
    <hr/><h3>obs_encoder_get_weak_encoder(encoder)</h3>
    <pre>
    These functions are used to get a weak reference from a strong encoder
    reference, or a strong encoder reference from a weak reference.  If
    the encoder is destroyed, *obs_weak_encoder_get_encoder* will return
    *NULL*.
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>Return : obs_weak_encoder</p>
    <p><pre>obs_weak_encoder_t *obs_encoder_get_weak_encoder(obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_get_width(encoder)</h3>
    <pre>
    :return: The width/height of a video encoder's encoded image
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_encoder_get_width(const obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_packet_ref(dst, src)</h3>
    <pre>
    Adds or releases a reference to an encoder packet.
    
    .. ---------------------------------------------------------------------------
    
    .. _libobs/obs-encoder.h: https://github.com/jp9000/obs-studio/blob/master/libobs/obs-encoder.h
    </pre>
    <p>dst : encoder_packet</p>
    <p>src : encoder_packet</p>
    <p><pre>void obs_encoder_packet_ref(struct encoder_packet *dst, struct encoder_packet *src)</pre></p>
    <hr/><h3>obs_encoder_packet_release(packet)</h3>
    <pre>
    Adds or releases a reference to an encoder packet.
    
    .. ---------------------------------------------------------------------------
    
    .. _libobs/obs-encoder.h: https://github.com/jp9000/obs-studio/blob/master/libobs/obs-encoder.h
    </pre>
    <p>packet : encoder_packet</p>
    <p><pre>void obs_encoder_packet_release(struct encoder_packet *packet)</pre></p>
    <hr/><h3>obs_encoder_paused(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_encoder</p>
    <hr/><h3>obs_encoder_properties(encoder)</h3>
    <pre>
    Use these functions to get the properties of an encoder or encoder
    type.  Properties are optionally used (if desired) to automatically
    generate user interface widgets to allow users to update settings.
    
    :return: The properties list for a specific existing encoder.  Free
             with :c:func:`obs_properties_destroy()`
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>Return : obs_properties</p>
    <p><pre>obs_properties_t *obs_encoder_properties(const obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_release(encoder)</h3>
    <pre>
    Adds/releases a reference to an encoder.  When the last reference is
    released, the encoder is destroyed.
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p><pre>void obs_encoder_release(obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_scaling_enabled(encoder)</h3>
    <pre>
    :return: *true* if pre-encode (CPU) scaling enabled, *false*
             otherwise.
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_encoder_scaling_enabled(const obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_encoder_set_audio(encoder, audio)</h3>
    <pre>
    Sets the video/audio handler to use with this video/audio encoder.
    This is used to capture the raw video/audio data.
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>audio : audio_t</p>
    <p><pre>void obs_encoder_set_audio(obs_encoder_t *encoder, audio_t *audio)</pre></p>
    <hr/><h3>obs_encoder_set_last_error(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_encoder</p>
    <p>param2 : string</p>
    <hr/><h3>obs_encoder_set_name(encoder, name)</h3>
    <pre>
    Sets the name of an encoder.  If the encoder is not private and the
    name is not unique, it will automatically be given a unique name.
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>name : string</p>
    <p><pre>void obs_encoder_set_name(obs_encoder_t *encoder, const char *name)</pre></p>
    <hr/><h3>obs_encoder_set_preferred_video_format(encoder, format)</h3>
    <pre>
    Sets the preferred video format for a video encoder.  If the encoder can use
    the format specified, it will force a conversion to that format if the
    obs output format does not match the preferred format.
    
    If the format is set to VIDEO_FORMAT_NONE, will revert to the default
    functionality of converting only when absolutely necessary.
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>format : number</p>
    <p><pre>void obs_encoder_set_preferred_video_format(obs_encoder_t *encoder, enum video_format format)</pre></p>
    <hr/><h3>obs_encoder_set_scaled_size(encoder, width, height)</h3>
    <pre>
    Sets the scaled resolution for a video encoder.  Set width and height to 0
    to disable scaling.  If the encoder is active, this function will trigger
    a warning, and do nothing.
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>width : number</p>
    <p>height : number</p>
    <p><pre>void obs_encoder_set_scaled_size(obs_encoder_t *encoder, uint32_t width, uint32_t height)</pre></p>
    <hr/><h3>obs_encoder_set_video(encoder, video)</h3>
    <pre>
    Sets the video/audio handler to use with this video/audio encoder.
    This is used to capture the raw video/audio data.
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>video : video_t</p>
    <p><pre>void obs_encoder_set_video(obs_encoder_t *encoder, video_t *video)</pre></p>
    <hr/><h3>obs_encoder_update(encoder, settings)</h3>
    <pre>
    Updates the settings for this encoder context.
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>settings : obs_data</p>
    <p><pre>void obs_encoder_update(obs_encoder_t *encoder, obs_data_t *settings)</pre></p>
    <hr/><h3>obs_encoder_video(encoder)</h3>
    <pre>
    :return: The video/audio handler associated with this encoder, or
             *NULL* if none or not a matching encoder type
    
    </pre>
    <p>encoder : obs_encoder</p>
    <p>Return : video_t</p>
    <p><pre>video_t *obs_encoder_video(const obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_enter_graphics()</h3>
    <pre>
    Helper function for entering the OBS graphics context.
    
    </pre>
    <p><pre>void obs_enter_graphics(void)</pre></p>
    <hr/><h3>obs_enum_audio_monitoring_devices(cb, data)</h3>
    <pre>
    Enumerates audio devices which can be used for audio monitoring.
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    typedef bool (*obs_enum_audio_device_cb)(void *data, const char *name, const char *id);
    
    </pre>
    <p>cb : f_p_void_p_q_const__char_p_q_const__char__bool</p>
    <p>data : ref_void*</p>
    <p><pre>void obs_enum_audio_monitoring_devices(obs_enum_audio_device_cb cb, void *data)</pre></p>
    <hr/><h3>obs_enum_encoder_types(idx, id)</h3>
    <pre>
    Enumerates all available encoder types.
    
    </pre>
    <p>idx : number</p>
    <p>id : p_char</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_enum_encoder_types(size_t idx, const char **id)</pre></p>
    <hr/><h3>obs_enum_encoders(enum_proc, param)</h3>
    <pre>
    Enumerates encoders.
    
    </pre>
    <p>enum_proc : f_p_void_p_struct_obs_encoder__bool</p>
    <p>param : ref_void*</p>
    <p><pre>void obs_enum_encoders(bool (*enum_proc)(void*, obs_encoder_t*), void *param)</pre></p>
    <hr/><h3>obs_enum_filter_types(idx, id)</h3>
    <pre>
    Enumerates all available filter source types.
    
    Filters are sources that are used to modify the video/audio output of
    other sources.
    
    </pre>
    <p>idx : number</p>
    <p>id : p_char</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_enum_filter_types(size_t idx, const char **id)</pre></p>
    <hr/><h3>obs_enum_hotkey_bindings(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : f_p_void_size_t_p_struct_obs_hotkey_binding__bool</p>
    <p>param2 : ref_void*</p>
    <hr/><h3>obs_enum_hotkeys(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : f_p_void_size_t_p_struct_obs_hotkey__bool</p>
    <p>param2 : ref_void*</p>
    <hr/><h3>obs_enum_input_types(idx, id)</h3>
    <pre>
    Enumerates all available inputs source types.
    
    Inputs are general source inputs (such as capture sources, device sources,
    etc).
    
    </pre>
    <p>idx : number</p>
    <p>id : p_char</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_enum_input_types(size_t idx, const char **id)</pre></p>
    <hr/><h3>obs_enum_input_types2(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : p_char</p>
    <p>param3 : p_char</p>
    <hr/><h3>obs_enum_modules(callback, param)</h3>
    <pre>
    Enumerates all loaded modules.
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    typedef void (*obs_enum_module_callback_t)(void *param, obs_module_t *module);
    
    </pre>
    <p>callback : f_p_void_p_struct_obs_module__void</p>
    <p>param : ref_void*</p>
    <p><pre>void obs_enum_modules(obs_enum_module_callback_t callback, void *param)</pre></p>
    <hr/><h3>obs_enum_output_types(idx, id)</h3>
    <pre>
    Enumerates all available output types.
    
    </pre>
    <p>idx : number</p>
    <p>id : p_char</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_enum_output_types(size_t idx, const char **id)</pre></p>
    <hr/><h3>obs_enum_outputs(enum_proc, param)</h3>
    <pre>
    Enumerates outputs.
    
    </pre>
    <p>enum_proc : f_p_void_p_struct_obs_output__bool</p>
    <p>param : ref_void*</p>
    <p><pre>void obs_enum_outputs(bool (*enum_proc)(void*, obs_output_t*), void *param)</pre></p>
    <hr/><h3>obs_enum_scenes(enum_proc, param)</h3>
    <pre>
    Enumerates all scenes.
    
    Callback function returns true to continue enumeration, or false to end
    enumeration.
    
    Use :c:func:`obs_source_get_ref()` or
    :c:func:`obs_source_get_weak_source()` if you want to retain a
    reference after obs_enum_scenes finishes.
    
    </pre>
    <p>enum_proc : f_p_void_p_struct_obs_source__bool</p>
    <p>param : ref_void*</p>
    <p><pre>void obs_enum_scenes(bool (*enum_proc)(void*, obs_source_t*), void *param)</pre></p>
    <hr/><h3>obs_enum_service_types(idx, id)</h3>
    <pre>
    Enumerates all available service types.
    
    </pre>
    <p>idx : number</p>
    <p>id : p_char</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_enum_service_types(size_t idx, const char **id)</pre></p>
    <hr/><h3>obs_enum_services(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : f_p_void_p_struct_obs_service__bool</p>
    <p>param2 : ref_void*</p>
    <hr/><h3>obs_enum_source_types(idx, id)</h3>
    <pre>
    Enumerates all source types (inputs, filters, transitions, etc).
    
    </pre>
    <p>idx : number</p>
    <p>id : p_char</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_enum_source_types(size_t idx, const char **id)</pre></p>
    <hr/><h3>obs_enum_sources()</h3>
    <pre>
    Enumerates all sources.
    
    :return: An array of reference-incremented sources.  Release with
             :py:func:`source_list_release()`.
    
    </pre>
    <p>Return : unknown</p>
    <hr/><h3>obs_enum_transition_types(idx, id)</h3>
    <pre>
    Enumerates all available transition source types.
    
    Transitions are sources used to transition between two or more other
    sources.
    
    </pre>
    <p>idx : number</p>
    <p>id : p_char</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_enum_transition_types(size_t idx, const char **id)</pre></p>
    <hr/><h3>obs_filter_get_parent(filter)</h3>
    <pre>
    If the source is a filter, returns the parent source of the filter.
    The parent source is the source being filtered.
    
    Only guaranteed to be valid inside of the video_render, filter_audio,
    filter_video, and filter_remove callbacks.
    
    </pre>
    <p>filter : obs_source</p>
    <p>Return : obs_source</p>
    <p><pre>obs_source_t *obs_filter_get_parent(const obs_source_t *filter)</pre></p>
    <hr/><h3>obs_filter_get_target(filter)</h3>
    <pre>
    If the source is a filter, returns the target source of the filter.
    The target source is the next source in the filter chain.
    
    Only guaranteed to be valid inside of the video_render, filter_audio,
    filter_video, and filter_remove callbacks.
    
    </pre>
    <p>filter : obs_source</p>
    <p>Return : obs_source</p>
    <p><pre>obs_source_t *obs_filter_get_target(const obs_source_t *filter)</pre></p>
    <hr/><h3>obs_find_data_file(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <hr/><h3>obs_find_module_file(module, file)</h3>
    <pre>
    Returns the location of a plugin module data file.
    
    Note:   Modules should use obs_module_file function defined in obs-module.h
            as a more elegant means of getting their files without having to
            specify the module parameter.
    
    :param  module: The module associated with the file to locate
    :param  file:   The file to locate
    :return:        Path string, or NULL if not found.  Use bfree to free string
    
    </pre>
    <p>module : obs_module</p>
    <p>file : string</p>
    <p>Return : string</p>
    <p><pre>char *obs_find_module_file(obs_module_t *module, const char *file)</pre></p>
    <hr/><h3>obs_frontend_add_event_callback(callback, private_data)</h3>
    <pre>
    Adds a callback that will be called when a frontend event occurs.
    See :c:type:`obs_frontend_event` on what sort of events can be
    triggered.
    
    :param callback:     Callback to use when a frontend event occurs.
    :param private_data: Private data associated with the callback.
    
    </pre>
    <p>callback : obs_frontend_event_cb</p>
    <p>private_data : void*</p>
    <p><pre>void obs_frontend_add_event_callback(obs_frontend_event_cb callback, void *private_data)</pre></p>
    <hr/><h3>obs_frontend_add_save_callback(callback, private_data)</h3>
    <pre>
    Adds a callback that will be called when the current scene collection
    is being saved/loaded.
    
    :param callback:     Callback to use when saving/loading a scene
                         collection.
    :param private_data: Private data associated with the callback.
    
    </pre>
    <p>callback : obs_frontend_save_cb</p>
    <p>private_data : void*</p>
    <p><pre>void obs_frontend_add_save_callback(obs_frontend_save_cb callback, void *private_data)</pre></p>
    <hr/><h3>obs_frontend_defer_save_begin()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_frontend_defer_save_end()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_frontend_get_current_preview_scene()</h3>
    <pre>
    :return: A new reference to the current preview scene if studio mode
             is active, or the current scene if studio mode is not
             active.
    
    </pre>
    <p>Return : obs_source</p>
    <p><pre>obs_source_t *obs_frontend_get_current_preview_scene(void)</pre></p>
    <hr/><h3>obs_frontend_get_current_profile()</h3>
    <pre>
    :return: A new pointer to the current profile name.  Free with
             :c:func:`bfree()`.
    
    </pre>
    <p>Return : char*</p>
    <p><pre>char *obs_frontend_get_current_profile(void)</pre></p>
    <hr/><h3>obs_frontend_get_current_scene()</h3>
    <pre>
    :return: A new reference to the currently active scene.
    
    </pre>
    <p>Return : obs_source_t*</p>
    <p><pre>obs_source_t *obs_frontend_get_current_scene(void)</pre></p>
    <hr/><h3>obs_frontend_get_current_scene_collection()</h3>
    <pre>
    :return: A new pointer to the current scene collection name.  Free
             with :c:func:`bfree()`.
    
    </pre>
    <p>Return : char*</p>
    <p><pre>char *obs_frontend_get_current_scene_collection(void)</pre></p>
    <hr/><h3>obs_frontend_get_current_transition()</h3>
    <pre>
    :return: A new reference to the currently active transition.
    
    </pre>
    <p>Return : obs_source_t*</p>
    <p><pre>obs_source_t *obs_frontend_get_current_transition(void)</pre></p>
    <hr/><h3>obs_frontend_get_global_config()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_frontend_get_profile_config()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_frontend_get_profiles()</h3>
    <pre>
    :return: The list of profile names, ending with NULL.  The list is
             stored within one contiguous segment of memory, so freeing
             the returned pointer with :c:func:`bfree()` will free the
             entire list.
    
    </pre>
    <p>Return : char**</p>
    <p><pre>char **obs_frontend_get_profiles(void)</pre></p>
    <hr/><h3>obs_frontend_get_recording_output()</h3>
    <pre>
    :return: A new reference to the current srecording output.
    
    </pre>
    <p>Return : obs_output</p>
    <p><pre>obs_output_t *obs_frontend_get_recording_output(void)</pre></p>
    <hr/><h3>obs_frontend_get_replay_buffer_output()</h3>
    <pre>
    :return: A new reference to the current replay buffer output.
    
    </pre>
    <p>Return : obs_output</p>
    <p><pre>obs_output_t *obs_frontend_get_replay_buffer_output(void)</pre></p>
    <hr/><h3>obs_frontend_get_scene_collections()</h3>
    <pre>
    :return: The list of profile names, ending with NULL.  The list is
             stored within one contiguous segment of memory, so freeing
             the returned pointer with :c:func:`bfree()` will free the
             entire list.
    
    </pre>
    <p>Return : char**</p>
    <p><pre>char **obs_frontend_get_scene_collections(void)</pre></p>
    <hr/><h3>obs_frontend_get_scene_names()</h3>
    <pre>
    :return: The scene name list, ending with NULL.  The list is stored
             within one contiguous segment of memory, so freeing the
             returned pointer with :c:func:`bfree()` will free the entire
             list.
    
    </pre>
    <p>Return : char**</p>
    <p><pre>char **obs_frontend_get_scene_names(void)</pre></p>
    <hr/><h3>obs_frontend_get_scenes(sources)</h3>
    <pre>
    :param sources: Pointer to a :c:type:`obs_frontend_source_list`
                    structure to receive the list of
                    reference-incremented scenes.  Release with
                    :c:func:`obs_frontend_source_list_free`.
    
    </pre>
    <p>sources : obs_frontend_source_list*</p>
    <p><pre>void obs_frontend_get_scenes(struct obs_frontend_source_list *sources)</pre></p>
    <hr/><h3>obs_frontend_get_streaming_output()</h3>
    <pre>
    :return: A new reference to the current streaming output.
    
    </pre>
    <p>Return : obs_output</p>
    <p><pre>obs_output_t *obs_frontend_get_streaming_output(void)</pre></p>
    <hr/><h3>obs_frontend_get_streaming_service()</h3>
    <pre>
    :return: A new reference to the current streaming service object.
    
    </pre>
    <p>Return : obs_service</p>
    <p><pre>obs_service_t *obs_frontend_get_streaming_service(void)</pre></p>
    <hr/><h3>obs_frontend_get_transitions(sources)</h3>
    <pre>
    :param sources: Pointer to a :c:type:`obs_frontend_source_list`
                    structure to receive the list of
                    reference-incremented transitions.  Release with
                    :c:func:`obs_frontend_source_list_free`.
    
    </pre>
    <p>sources : obs_frontend_source_list*</p>
    <p><pre>void obs_frontend_get_transitions(struct obs_frontend_source_list *sources)</pre></p>
    <hr/><h3>obs_frontend_open_projector(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <p>param2 : number</p>
    <p>param3 : string</p>
    <p>param4 : string</p>
    <hr/><h3>obs_frontend_preview_enabled()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_frontend_preview_program_mode_active()</h3>
    <pre>
    :return: *true* if studio mode is active, *false* otherwise.
    
    </pre>
    <p>Return : boolean</p>
    <p><pre>bool obs_frontend_preview_program_mode_active(void)</pre></p>
    <hr/><h3>obs_frontend_preview_program_trigger_transition()</h3>
    <pre>
    Triggers a preview-to-program transition if studio mode is active.
    
    </pre>
    <p><pre>void obs_frontend_preview_program_trigger_transition(void)</pre></p>
    <hr/><h3>obs_frontend_recording_active()</h3>
    <pre>
    :return: *true* if recording active, *false* otherwise.
    
    </pre>
    <p>Return : boolean</p>
    <p><pre>bool obs_frontend_recording_active(void)</pre></p>
    <hr/><h3>obs_frontend_recording_pause(pause)</h3>
    <pre>
    :pause: *true* to pause recording, *false* to unpause.
    
    </pre>
    <p>pause : boolean</p>
    <p><pre>void obs_frontend_recording_pause(bool pause)</pre></p>
    <hr/><h3>obs_frontend_recording_paused()</h3>
    <pre>
    :return: *true* if recording paused, *false* otherwise.
    
    </pre>
    <p>Return : boolean</p>
    <p><pre>bool obs_frontend_recording_paused(void)</pre></p>
    <hr/><h3>obs_frontend_recording_start()</h3>
    <pre>
    Starts recording.
    
    </pre>
    <p><pre>void obs_frontend_recording_start(void)</pre></p>
    <hr/><h3>obs_frontend_recording_stop()</h3>
    <pre>
    Stops recording.
    
    </pre>
    <p><pre>void obs_frontend_recording_stop(void)</pre></p>
    <hr/><h3>obs_frontend_remove_event_callback(callback, private_data)</h3>
    <pre>
    Removes an event callback.
    
    :param callback:     Callback to remove.
    :param private_data: Private data associated with the callback.
    
    </pre>
    <p>callback : obs_frontend_event_cb</p>
    <p>private_data : void*</p>
    <p><pre>void obs_frontend_remove_event_callback(obs_frontend_event_cb callback, void *private_data)</pre></p>
    <hr/><h3>obs_frontend_remove_save_callback(callback, private_data)</h3>
    <pre>
    Removes a save/load callback.
    
    :param callback:     Callback to remove.
    :param private_data: Private data associated with the callback.
    
    </pre>
    <p>callback : obs_frontend_save_cb</p>
    <p>private_data : void*</p>
    <p><pre>void obs_frontend_remove_save_callback(obs_frontend_save_cb callback, void *private_data)</pre></p>
    <hr/><h3>obs_frontend_replay_buffer_active()</h3>
    <pre>
    :return: *true* if replay buffer active, *false* otherwise.
    
    </pre>
    <p>Return : boolean</p>
    <p><pre>bool obs_frontend_replay_buffer_active(void)</pre></p>
    <hr/><h3>obs_frontend_replay_buffer_save()</h3>
    <pre>
    Saves a replay if the replay buffer is active.
    
    </pre>
    <p><pre>void obs_frontend_replay_buffer_save(void)</pre></p>
    <hr/><h3>obs_frontend_replay_buffer_start()</h3>
    <pre>
    Starts replay buffer.
    
    </pre>
    <p><pre>void obs_frontend_replay_buffer_start(void)</pre></p>
    <hr/><h3>obs_frontend_replay_buffer_stop()</h3>
    <pre>
    Stops replay buffer.
    
    </pre>
    <p><pre>void obs_frontend_replay_buffer_stop(void)</pre></p>
    <hr/><h3>obs_frontend_save()</h3>
    <pre>
    Saves the current scene collection.
    
    </pre>
    <p><pre>void obs_frontend_save(void)</pre></p>
    <hr/><h3>obs_frontend_save_streaming_service()</h3>
    <pre>
    Saves the current streaming service data.
    
    </pre>
    <p><pre>void obs_frontend_save_streaming_service(void)</pre></p>
    <hr/><h3>obs_frontend_set_current_preview_scene(scene)</h3>
    <pre>
    Sets the current preview scene in studio mode, or the currently
    active scene if not in studio mode.
    
    :param scene: The scene to set as the current preview.
    
    </pre>
    <p>scene : obs_source</p>
    <p><pre>void obs_frontend_set_current_preview_scene(obs_source_t *scene)</pre></p>
    <hr/><h3>obs_frontend_set_current_profile(profile)</h3>
    <pre>
    :param profile: Name of the profile to activate.
    
    </pre>
    <p>profile : char*</p>
    <p><pre>void obs_frontend_set_current_profile(const char *profile)</pre></p>
    <hr/><h3>obs_frontend_set_current_scene(scene)</h3>
    <pre>
    :param scene: The scene to set as the current scene.
    
    </pre>
    <p>scene : obs_source_t*</p>
    <p><pre>void obs_frontend_set_current_scene(obs_source_t *scene)</pre></p>
    <hr/><h3>obs_frontend_set_current_scene_collection(collection)</h3>
    <pre>
    :param profile: Name of the scene collection to activate.
    
    </pre>
    <p>collection : char*</p>
    <p><pre>void obs_frontend_set_current_scene_collection(const char *collection)</pre></p>
    <hr/><h3>obs_frontend_set_current_transition(transition)</h3>
    <pre>
    :param transition: The transition to set as the current transition.
    
    </pre>
    <p>transition : obs_source_t*</p>
    <p><pre>void obs_frontend_set_current_transition(obs_source_t *transition)</pre></p>
    <hr/><h3>obs_frontend_set_preview_enabled(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : boolean</p>
    <hr/><h3>obs_frontend_set_preview_program_mode(enable)</h3>
    <pre>
    Activates/deactivates studio mode.
    
    :param enable: *true* to activate studio mode, *false* to deactivate
                   studio mode.
    
    </pre>
    <p>enable : boolean</p>
    <p><pre>void obs_frontend_set_preview_program_mode(bool enable)</pre></p>
    <hr/><h3>obs_frontend_set_streaming_service(service)</h3>
    <pre>
    Sets the current streaming service to stream with.
    
    :param service: The streaming service to set.
    
    </pre>
    <p>service : obs_service</p>
    <p><pre>void obs_frontend_set_streaming_service(obs_service_t *service)</pre></p>
    <hr/><h3>obs_frontend_streaming_active()</h3>
    <pre>
    :return: *true* if streaming active, *false* otherwise.
    
    </pre>
    <p>Return : boolean</p>
    <p><pre>bool obs_frontend_streaming_active(void)</pre></p>
    <hr/><h3>obs_frontend_streaming_start()</h3>
    <pre>
    Starts streaming.
    
    </pre>
    <p><pre>void obs_frontend_streaming_start(void)</pre></p>
    <hr/><h3>obs_frontend_streaming_stop()</h3>
    <pre>
    Stops streaming.
    
    </pre>
    <p><pre>void obs_frontend_streaming_stop(void)</pre></p>
    <hr/><h3>obs_frontend_take_screenshot()</h3>
    <pre>
    Takes a screenshot of the main OBS output.
    
    </pre>
    <p>Return : void*</p>
    <p><pre>void *obs_frontend_take_screenshot(void)</pre></p>
    <hr/><h3>obs_frontend_take_source_screenshot(source)</h3>
    <pre>
    Takes a screenshot of the specified source.
    
    :param source: The source to take screenshot of.
    </pre>
    <p>source : obs_source</p>
    <p>Return : void*</p>
    <p><pre>void *obs_frontend_take_source_screenshot(obs_source_t *source)</pre></p>
    <hr/><h3>obs_get_active_fps()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_get_audio()</h3>
    <pre>
    :return: The main audio output handler for this OBS context
    
    </pre>
    <p>Return : audio_t</p>
    <p><pre>audio_t *obs_get_audio(void)</pre></p>
    <hr/><h3>obs_get_audio_info(oai)</h3>
    <pre>
    Gets the current audio settings.
    
    :return: *false* if no audio
    
    </pre>
    <p>oai : obs_audio_info</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_get_audio_info(struct obs_audio_info *oai)</pre></p>
    <hr/><h3>obs_get_audio_monitoring_device(name, id)</h3>
    <pre>
    Gets the current audio device for audio monitoring.
    
    </pre>
    <p>name : p_char</p>
    <p>id : p_char</p>
    <p><pre>void obs_get_audio_monitoring_device(const char **name, const char **id)</pre></p>
    <hr/><h3>obs_get_average_frame_time_ns()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_get_base_effect(effect)</h3>
    <pre>
    Returns a commoinly used base effect.
    
    :param effect: | Can be one of the following values:
                   | OBS_EFFECT_DEFAULT             - RGB/YUV
                   | OBS_EFFECT_DEFAULT_RECT        - RGB/YUV (using texture_rect)
                   | OBS_EFFECT_OPAQUE              - RGB/YUV (alpha set to 1.0)
                   | OBS_EFFECT_SOLID               - RGB/YUV (solid color only)
                   | OBS_EFFECT_BICUBIC             - Bicubic downscale
                   | OBS_EFFECT_LANCZOS             - Lanczos downscale
                   | OBS_EFFECT_BILINEAR_LOWRES     - Bilinear low resolution downscale
                   | OBS_EFFECT_PREMULTIPLIED_ALPHA - Premultiplied alpha
    
    </pre>
    <p>effect : number</p>
    <p>Return : gs_effect</p>
    <p><pre>gs_effect_t *obs_get_base_effect(enum obs_base_effect effect)</pre></p>
    <hr/><h3>obs_get_cmdline_args()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_get_encoder_by_name(name)</h3>
    <pre>
    Gets an encoder by its name.
    
    Increments the encoder reference counter, use
    :c:func:`obs_encoder_release()` to release it when complete.
    
    </pre>
    <p>name : string</p>
    <p>Return : obs_encoder</p>
    <p><pre>obs_encoder_t *obs_get_encoder_by_name(const char *name)</pre></p>
    <hr/><h3>obs_get_encoder_caps(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <hr/><h3>obs_get_encoder_codec(id)</h3>
    <pre>
    :return: The codec identifier of the encoder
    
    </pre>
    <p>id : string</p>
    <p>Return : string</p>
    <p><pre>const char *obs_get_encoder_codec(const char *id)</pre></p>
    <hr/><h3>obs_get_encoder_properties(id)</h3>
    <pre>
    Use these functions to get the properties of an encoder or encoder
    type.  Properties are optionally used (if desired) to automatically
    generate user interface widgets to allow users to update settings.
    
    :return: The properties list for a specific existing encoder.  Free
             with :c:func:`obs_properties_destroy()`
    
    </pre>
    <p>id : string</p>
    <p>Return : obs_properties</p>
    <p><pre>obs_properties_t *obs_get_encoder_properties(const char *id)</pre></p>
    <hr/><h3>obs_get_encoder_type(id)</h3>
    <pre>
    :return: The encoder type: OBS_ENCODER_VIDEO or OBS_ENCODER_AUDIO
    
    </pre>
    <p>id : string</p>
    <p>Return : number</p>
    <p><pre>enum obs_encoder_type obs_get_encoder_type(const char *id)</pre></p>
    <hr/><h3>obs_get_frame_interval_ns()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_get_lagged_frames()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_get_latest_input_type_id(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <hr/><h3>obs_get_locale()</h3>
    <pre>
    :return: The current locale
    
    </pre>
    <p>Return : string</p>
    <p><pre>const char *obs_get_locale(void)</pre></p>
    <hr/><h3>obs_get_main_texture()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_get_master_volume()</h3>
    <pre>
    :return: The master user volume
    
    </pre>
    <p>Return : number</p>
    <p><pre>float obs_get_master_volume(void)</pre></p>
    <hr/><h3>obs_get_module(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <hr/><h3>obs_get_module_author(module)</h3>
    <pre>
    :return: The module author(s)
    
    </pre>
    <p>module : obs_module</p>
    <p><pre>void obs_get_module_author(obs_module_t *module)</pre></p>
    <hr/><h3>obs_get_module_binary_path(module)</h3>
    <pre>
    :return: The module binary path
    
    </pre>
    <p>module : obs_module</p>
    <p>Return : string</p>
    <p><pre>const char *obs_get_module_binary_path(obs_module_t *module)</pre></p>
    <hr/><h3>obs_get_module_data_path(module)</h3>
    <pre>
    :return: The module data path
    
    </pre>
    <p>module : obs_module</p>
    <p>Return : string</p>
    <p><pre>const char *obs_get_module_data_path(obs_module_t *module)</pre></p>
    <hr/><h3>obs_get_module_description(module)</h3>
    <pre>
    :return: The module description
    
    </pre>
    <p>module : obs_module</p>
    <p>Return : string</p>
    <p><pre>const char *obs_get_module_description(obs_module_t *module)</pre></p>
    <hr/><h3>obs_get_module_file_name(module)</h3>
    <pre>
    :return: The module file name
    
    </pre>
    <p>module : obs_module</p>
    <p>Return : string</p>
    <p><pre>const char *obs_get_module_file_name(obs_module_t *module)</pre></p>
    <hr/><h3>obs_get_module_name(module)</h3>
    <pre>
    :return: The module full name (or *NULL* if none)
    
    </pre>
    <p>module : obs_module</p>
    <p>Return : string</p>
    <p><pre>const char *obs_get_module_name(obs_module_t *module)</pre></p>
    <hr/><h3>obs_get_output_by_name(name)</h3>
    <pre>
    Gets an output by its name.
    
    Increments the output reference counter, use
    :c:func:`obs_output_release()` to release it when complete.
    
    </pre>
    <p>name : string</p>
    <p>Return : obs_output</p>
    <p><pre>obs_output_t *obs_get_output_by_name(const char *name)</pre></p>
    <hr/><h3>obs_get_output_flags(id)</h3>
    <pre>
    :return: The output capability flags
    
    </pre>
    <p>id : string</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_get_output_flags(const char *id)</pre></p>
    <hr/><h3>obs_get_output_properties(id)</h3>
    <pre>
    Use these functions to get the properties of an output or output
    type.  Properties are optionally used (if desired) to automatically
    generate user interface widgets to allow users to update settings.
    
    :return: The properties list for a specific existing output.  Free
             with :c:func:`obs_properties_destroy()`
    
    </pre>
    <p>id : string</p>
    <p>Return : obs_properties</p>
    <p><pre>obs_properties_t *obs_get_output_properties(const char *id)</pre></p>
    <hr/><h3>obs_get_output_source(channel)</h3>
    <pre>
    Gets the primary output source for a channel and increments the reference
    counter for that source.  Use :c:func:`obs_source_release()` to release.
    
    </pre>
    <p>channel : number</p>
    <p>Return : obs_source</p>
    <p><pre>obs_source_t *obs_get_output_source(uint32_t channel)</pre></p>
    <hr/><h3>obs_get_private_data()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_get_proc_handler()</h3>
    <pre>
    :return: The primary obs procedure handler
    
    .. _core_signal_handler_reference:
    
    Core OBS Signals
    </pre>
    <p>Return : proc_handler</p>
    <p><pre>proc_handler_t *obs_get_proc_handler(void)</pre></p>
    <hr/><h3>obs_get_profiler_name_store()</h3>
    <pre>
    :return: The profiler name store (see util/profiler.h) used by OBS,
             which is either a name store passed to obs_startup, an
             internal name store, or NULL in case obs_initialized()
             returns false.
    
    </pre>
    <p>Return : profiler_name_store_t</p>
    <p><pre>profiler_name_store_t *obs_get_profiler_name_store(void)</pre></p>
    <hr/><h3>obs_get_service_by_name(name)</h3>
    <pre>
    Gets an service by its name.
    
    Increments the service reference counter, use
    :c:func:`obs_service_release()` to release it when complete.
    
    </pre>
    <p>name : string</p>
    <p>Return : obs_service</p>
    <p><pre>obs_service_t *obs_get_service_by_name(const char *name)</pre></p>
    <hr/><h3>obs_get_service_properties(id)</h3>
    <pre>
    Use these functions to get the properties of a service or service
    type.  Properties are optionally used (if desired) to automatically
    generate user interface widgets to allow users to update settings.
    
    :return: The properties list for a specific existing service.  Free
             with :c:func:`obs_properties_destroy()`
    
    </pre>
    <p>id : string</p>
    <p>Return : obs_properties</p>
    <p><pre>obs_properties_t *obs_get_service_properties(const char *id)</pre></p>
    <hr/><h3>obs_get_signal_handler()</h3>
    <pre>
    :return: The primary obs signal handler
    
    See :ref:`core_signal_handler_reference` for more information on
    core signals.
    
    </pre>
    <p>Return : signal_handler</p>
    <p><pre>signal_handler_t *obs_get_signal_handler(void)</pre></p>
    <hr/><h3>obs_get_source_by_name(name)</h3>
    <pre>
    Gets a source by its name.
    
    Increments the source reference counter, use
    :c:func:`obs_source_release()` to release it when complete.
    
    </pre>
    <p>name : string</p>
    <p>Return : obs_source</p>
    <p><pre>obs_source_t *obs_get_source_by_name(const char *name)</pre></p>
    <hr/><h3>obs_get_source_defaults(id)</h3>
    <pre>
    Calls :c:member:`obs_source_info.get_defaults` to get the defaults
    settings of the source type.
    
    :return: The default settings for a source type
    
    </pre>
    <p>id : string</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_get_source_defaults(const char *id)</pre></p>
    <hr/><h3>obs_get_source_output_flags(id)</h3>
    <pre>
    :return: Capability flags of a source
    
    Author's Note: "Output flags" is poor wording in retrospect; this
    should have been named "Capability flags", and the OBS_SOURCE_*
    macros should really be OBS_SOURCE_CAP_* macros instead.
    
    See :c:member:`obs_source_info.output_flags` for more information.
    
    </pre>
    <p>id : string</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_get_source_output_flags(const char *id)</pre></p>
    <hr/><h3>obs_get_source_properties(id)</h3>
    <pre>
    Use these functions to get the properties of a source or source type.
    Properties are optionally used (if desired) to automatically generate
    user interface widgets to allow users to update settings.
    
    :return: The properties list for a specific existing source.  Free with
             :c:func:`obs_properties_destroy()`
    
    </pre>
    <p>id : string</p>
    <p>Return : obs_properties</p>
    <p><pre>obs_properties_t *obs_get_source_properties(const char *id)</pre></p>
    <hr/><h3>obs_get_total_frames()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_get_version()</h3>
    <pre>
    :return: The current core version
    
    </pre>
    <p>Return : number</p>
    <p><pre>uint32_t obs_get_version(void)</pre></p>
    <hr/><h3>obs_get_version_string()</h3>
    <pre>
    :return: The current core version string
    
    </pre>
    <p>Return : string</p>
    <p><pre>const char *obs_get_version_string(void)</pre></p>
    <hr/><h3>obs_get_video()</h3>
    <pre>
    :return: The main video output handler for this OBS context
    
    </pre>
    <p>Return : video_t</p>
    <p><pre>video_t *obs_get_video(void)</pre></p>
    <hr/><h3>obs_get_video_frame_time()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_get_video_info(ovi)</h3>
    <pre>
    Gets the current video settings.
    
    :return: *false* if no video
    
    </pre>
    <p>ovi : obs_video_info</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_get_video_info(struct obs_video_info *ovi)</pre></p>
    <hr/><h3>obs_group_from_source(source)</h3>
    <pre>
    :return: The group context, or *NULL* if not a group.  Does not
             increase the reference
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : obs_scene</p>
    <p><pre>obs_scene_t *obs_group_from_source(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_hotkey_binding_get_hotkey(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_hotkey_binding</p>
    <hr/><h3>obs_hotkey_binding_get_hotkey_id(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_hotkey_binding</p>
    <hr/><h3>obs_hotkey_binding_get_key_combination(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_hotkey_binding</p>
    <hr/><h3>obs_hotkey_enable_background_press(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : boolean</p>
    <hr/><h3>obs_hotkey_enable_callback_rerouting(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : boolean</p>
    <hr/><h3>obs_hotkey_enable_strict_modifiers(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : boolean</p>
    <hr/><h3>obs_hotkey_get_description(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_hotkey</p>
    <hr/><h3>obs_hotkey_get_id(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_hotkey</p>
    <hr/><h3>obs_hotkey_get_name(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_hotkey</p>
    <hr/><h3>obs_hotkey_get_pair_partner_id(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_hotkey</p>
    <hr/><h3>obs_hotkey_get_registerer(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_hotkey</p>
    <hr/><h3>obs_hotkey_get_registerer_type(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_hotkey</p>
    <hr/><h3>obs_hotkey_inject_event(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_key_combination</p>
    <p>param2 : boolean</p>
    <hr/><h3>obs_hotkey_load(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : obs_data_array</p>
    <hr/><h3>obs_hotkey_load_bindings(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : obs_key_combination</p>
    <p>param3 : number</p>
    <hr/><h3>obs_hotkey_pair_load(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : obs_data_array</p>
    <p>param3 : obs_data_array</p>
    <hr/><h3>obs_hotkey_pair_save(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : p_obs_data_array</p>
    <p>param3 : p_obs_data_array</p>
    <hr/><h3>obs_hotkey_pair_set_descriptions(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : string</p>
    <p>param3 : string</p>
    <hr/><h3>obs_hotkey_pair_set_names(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : string</p>
    <p>param3 : string</p>
    <hr/><h3>obs_hotkey_pair_unregister(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <hr/><h3>obs_hotkey_register_frontend(name, description, callback)</h3>
    <pre>
    Adds a frontend hotkey.  The callback takes one parameter: a boolean
    'pressed' parameter.
    
    :param name:        Unique name identifier string of the hotkey.
    :param description: Hotkey description shown to the user.
    :param callback:    Callback for the hotkey.  Use
                        :py:func:`obs_hotkey_unregister()` or
                        :py:func:`remove_current_callback()` to remove
                        the callback.
    
    </pre>
    <p>name : unknown</p>
    <p>description : unknown</p>
    <p>callback : unknown</p>
    <p>Return : unknown</p>
    <hr/><h3>obs_hotkey_save(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <hr/><h3>obs_hotkey_set_callback_routing_func(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : f_p_void_size_t_bool__void</p>
    <p>param2 : ref_void*</p>
    <hr/><h3>obs_hotkey_set_description(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : string</p>
    <hr/><h3>obs_hotkey_set_name(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : string</p>
    <hr/><h3>obs_hotkey_trigger_routed_callback(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : boolean</p>
    <hr/><h3>obs_hotkey_unregister(callback)</h3>
    <pre>
    Unregisters the hotkey associated with the specified callback.
    
    :param callback: Callback of the hotkey to unregister.
    
    </pre>
    <p>callback : number</p>
    <p>Return : unknown</p>
    <hr/><h3>obs_hotkey_update_atomic(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : f_p_void__void</p>
    <p>param2 : ref_void*</p>
    <hr/><h3>obs_hotkeys_load_encoder(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_encoder</p>
    <p>param2 : obs_data</p>
    <hr/><h3>obs_hotkeys_load_output(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_output</p>
    <p>param2 : obs_data</p>
    <hr/><h3>obs_hotkeys_load_service(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_service</p>
    <p>param2 : obs_data</p>
    <hr/><h3>obs_hotkeys_load_source(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : obs_data</p>
    <hr/><h3>obs_hotkeys_save_encoder(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_encoder</p>
    <hr/><h3>obs_hotkeys_save_output(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_output</p>
    <hr/><h3>obs_hotkeys_save_service(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_service</p>
    <hr/><h3>obs_hotkeys_save_source(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_hotkeys_set_audio_hotkeys_translations(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <p>param2 : string</p>
    <p>param3 : string</p>
    <p>param4 : string</p>
    <hr/><h3>obs_hotkeys_set_sceneitem_hotkeys_translations(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <p>param2 : string</p>
    <hr/><h3>obs_init_module(module)</h3>
    <pre>
    Initializes the module, which calls its obs_module_load export.
    
    :return: *true* if the module was loaded successfully
    
    </pre>
    <p>module : obs_module</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_init_module(obs_module_t *module)</pre></p>
    <hr/><h3>obs_initialized()</h3>
    <pre>
    :return: true if the main OBS context has been initialized
    
    </pre>
    <p>Return : boolean</p>
    <p><pre>bool obs_initialized(void)</pre></p>
    <hr/><h3>obs_is_source_configurable(id)</h3>
    <pre>
    :return: *true* if the the source has custom properties, *false*
             otherwise
    
    </pre>
    <p>id : string</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_is_source_configurable(const char *id)</pre></p>
    <hr/><h3>obs_key_combination_is_empty(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_key_combination</p>
    <hr/><h3>obs_key_combination_to_str(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_key_combination</p>
    <p>param2 : dstr</p>
    <hr/><h3>obs_key_from_name(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <hr/><h3>obs_key_from_virtual_key(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <hr/><h3>obs_key_to_name(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <hr/><h3>obs_key_to_str(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : dstr</p>
    <hr/><h3>obs_key_to_virtual_key(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <hr/><h3>obs_leave_graphics()</h3>
    <pre>
    Helper function for leaving the OBS graphics context.
    
    </pre>
    <p><pre>void obs_leave_graphics(void)</pre></p>
    <hr/><h3>obs_load_all_modules()</h3>
    <pre>
    Automatically loads all modules from module paths (convenience function).
    
    </pre>
    <p><pre>void obs_load_all_modules(void)</pre></p>
    <hr/><h3>obs_load_source(data)</h3>
    <pre>
    :return: A source created from saved data
    
    </pre>
    <p>data : obs_data</p>
    <p>Return : obs_source</p>
    <p><pre>obs_source_t *obs_load_source(obs_data_t *data)</pre></p>
    <hr/><h3>obs_load_sources(array, cb, private_data)</h3>
    <pre>
    Helper function to load active sources from a data array.
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    typedef void (*obs_load_source_cb)(void *private_data, obs_source_t *source);
    
    </pre>
    <p>array : obs_data_array</p>
    <p>cb : f_p_void_p_struct_obs_source__void</p>
    <p>private_data : ref_void*</p>
    <p><pre>void obs_load_sources(obs_data_array_t *array, obs_load_source_cb cb, void *private_data)</pre></p>
    <hr/><h3>obs_log_loaded_modules()</h3>
    <pre>
    Logs loaded modules.
    
    </pre>
    <p><pre>void obs_log_loaded_modules(void)</pre></p>
    <hr/><h3>obs_module_get_config_path(module, file)</h3>
    <pre>
    Returns the path of a plugin module config file (whether it exists or not).
    
    Note:   Modules should use obs_module_config_path function defined in
            obs-module.h as a more elegant means of getting their files without
            having to specify the module parameter.
    
    :param  module: The module associated with the path
    :param  file:   The file to get a path to
    :return:        Path string, or NULL if not found.  Use bfree to free string
    </pre>
    <p>module : obs_module</p>
    <p>file : string</p>
    <p>Return : string</p>
    <p><pre>char *obs_module_get_config_path(obs_module_t *module, const char *file)</pre></p>
    <hr/><h3>obs_module_get_locale_string(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_module</p>
    <p>param2 : string</p>
    <p>param3 : p_char</p>
    <hr/><h3>obs_module_get_locale_text(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_module</p>
    <p>param2 : string</p>
    <hr/><h3>obs_module_load_locale(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_module</p>
    <p>param2 : string</p>
    <p>param3 : string</p>
    <hr/><h3>obs_nv12_tex_active()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_obj_get_data(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : ref_void*</p>
    <hr/><h3>obs_obj_get_id(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : ref_void*</p>
    <hr/><h3>obs_obj_get_type(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : ref_void*</p>
    <hr/><h3>obs_obj_invalid(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : ref_void*</p>
    <hr/><h3>obs_open_module(module, path, data_path)</h3>
    <pre>
    Opens a plugin module directly from a specific path.
    
    If the module already exists then the function will return successful, and
    the module parameter will be given the pointer to the existing
    module.
    
    This does not initialize the module, it only loads the module image.  To
    initialize the module, call :c:func:`obs_init_module()`.
    
    :param  module:    The pointer to the created module
    :param  path:      Specifies the path to the module library file.  If the
                       extension is not specified, it will use the extension
                       appropriate to the operating system
    :param  data_path: Specifies the path to the directory where the module's
                       data files are stored (or *NULL* if none)
    :returns:          | MODULE_SUCCESS          - Successful
                       | MODULE_ERROR            - A generic error occurred
                       | MODULE_FILE_NOT_FOUND   - The module was not found
                       | MODULE_MISSING_EXPORTS  - Required exports are missing
                       | MODULE_INCOMPATIBLE_VER - Incompatible version
    
    </pre>
    <p>module : p_obs_module</p>
    <p>path : string</p>
    <p>data_path : string</p>
    <p>Return : number</p>
    <p><pre>int obs_open_module(obs_module_t **module, const char *path, const char *data_path)</pre></p>
    <hr/><h3>obs_output_active(output)</h3>
    <pre>
    :return: *true* if the output is currently active, *false* otherwise
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_output_active(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_addref(output)</h3>
    <pre>
    Adds/releases a reference to an output.  When the last reference is
    released, the output is destroyed.
    
    </pre>
    <p>output : obs_output</p>
    <p><pre>void obs_output_addref(obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_audio(output)</h3>
    <pre>
    Gets the current video/audio handlers for the output.
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : audio_t</p>
    <p><pre>audio_t *obs_output_audio(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_begin_data_capture(output, flags)</h3>
    <pre>
    Begins data capture from raw media or encoders.  This is typically
    when the output actually activates (starts) internally.  Video/audio
    data will start being sent to the callbacks of the output.
    
    :param flags: Set to 0 to initialize both audio/video, otherwise a
                  bitwise OR combination of OBS_OUTPUT_VIDEO and/or
                  OBS_OUTPUT_AUDIO
    :return:      *true* if successful, *false* otherwise.  Typically the
                  return value does not need to be checked if
                  :c:func:`obs_output_can_begin_data_capture()` was
                  called
    
    </pre>
    <p>output : obs_output</p>
    <p>flags : number</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_output_begin_data_capture(obs_output_t *output, uint32_t flags)</pre></p>
    <hr/><h3>obs_output_can_begin_data_capture(output, flags)</h3>
    <pre>
    Determines whether video/audio capture (encoded or raw) is able to
    start.  Call this before initializing any output data to ensure that
    the output can start.
    
    :param flags: Set to 0 to initialize both audio/video, otherwise a
                  bitwise OR combination of OBS_OUTPUT_VIDEO and/or
                  OBS_OUTPUT_AUDIO
    :return:      *true* if data capture can begin
    
    </pre>
    <p>output : obs_output</p>
    <p>flags : number</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_output_can_begin_data_capture(const obs_output_t *output, uint32_t flags)</pre></p>
    <hr/><h3>obs_output_can_pause(output)</h3>
    <pre>
    :return: *true* if the output can be paused, *false* otherwise
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_output_can_pause(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_create(id, name, settings, hotkey_data)</h3>
    <pre>
    Creates an output with the specified settings.
    
    The "output" context is used for anything related to outputting the
    final video/audio mix (E.g. streaming or recording).  Use
    obs_output_release to release it.
    
    :param   id:             The output type string identifier
    :param   name:           The desired name of the output.  If this is
                             not unique, it will be made to be unique
    :param   settings:       The settings for the output, or *NULL* if
                             none
    :param   hotkey_data:    Saved hotkey data for the output, or *NULL*
                             if none
    :return:                 A reference to the newly created output, or
                             *NULL* if failed
    
    </pre>
    <p>id : string</p>
    <p>name : string</p>
    <p>settings : obs_data</p>
    <p>hotkey_data : obs_data</p>
    <p>Return : obs_output</p>
    <p><pre>obs_output_t *obs_output_create(const char *id, const char *name, obs_data_t *settings, obs_data_t *hotkey_data)</pre></p>
    <hr/><h3>obs_output_defaults(id)</h3>
    <pre>
    :return: An incremented reference to the output's default settings
    
    </pre>
    <p>id : string</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_output_defaults(const char *id)</pre></p>
    <hr/><h3>obs_output_end_data_capture(output)</h3>
    <pre>
    Ends data capture of an output.  This is typically when the output
    actually intentionally deactivates (stops).  Video/audio data will
    stop being sent to the callbacks of the output.  The output will
    trigger the "stop" signal with the OBS_OUTPUT_SUCCESS code to
    indicate that the output has stopped successfully.  See
    :ref:`output_signal_handler_reference` for more information on output
    signals.
    
    </pre>
    <p>output : obs_output</p>
    <p><pre>void obs_output_end_data_capture(obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_force_stop(output)</h3>
    <pre>
    Attempts to get the output to stop immediately without waiting for
    data to send.
    
    </pre>
    <p>output : obs_output</p>
    <p><pre>void obs_output_force_stop(obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_active_delay(output)</h3>
    <pre>
    If delay is active, gets the currently active delay value, in
    seconds.  The active delay can increase if the
    OBS_OUTPUT_DELAY_PRESERVE flag was set when setting a delay.
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_output_get_active_delay(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_audio_encoder(output, idx)</h3>
    <pre>
    Gets the video/audio encoders for an encoded output.
    
    :param idx:     The audio encoder index if the output supports
                    multiple audio streams at once
    :return:        The video/audio encoder.  The reference is not
                    incremented
    
    </pre>
    <p>output : obs_output</p>
    <p>idx : number</p>
    <p>Return : obs_encoder</p>
    <p><pre>obs_encoder_t *obs_output_get_audio_encoder(const obs_output_t *output, size_t idx)</pre></p>
    <hr/><h3>obs_output_get_congestion(output)</h3>
    <pre>
    :return: The congestion value.  This value is used to visualize the
             current congestion of a network output.  For example, if
             there is no congestion, the value will be 0.0f, if it's
             fully congested, the value will be 1.0f
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : number</p>
    <p><pre>float obs_output_get_congestion(obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_connect_time_ms(output)</h3>
    <pre>
    :return: How long the output took to connect to a server, in
             milliseconds
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : number</p>
    <p><pre>int obs_output_get_connect_time_ms(obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_delay(output)</h3>
    <pre>
    Gets the currently set delay value, in seconds.
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_output_get_delay(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_display_name(id)</h3>
    <pre>
    Calls the :c:member:`obs_output_info.get_name` callback to get the
    translated display name of an output type.
    
    :param    id:            The output type string identifier
    :return:                 The translated display name of an output type
    
    </pre>
    <p>id : string</p>
    <p>Return : string</p>
    <p><pre>const char *obs_output_get_display_name(const char *id)</pre></p>
    <hr/><h3>obs_output_get_flags(output)</h3>
    <pre>
    :return: The output capability flags
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_output_get_flags(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_frames_dropped(output)</h3>
    <pre>
    :return: Number of frames that were dropped due to network congestion
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : number</p>
    <p><pre>int obs_output_get_frames_dropped(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_height(output)</h3>
    <pre>
    :return: The width/height of the output
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_output_get_height(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_id(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_output</p>
    <hr/><h3>obs_output_get_last_error(output)</h3>
    <pre>
    Sets/gets the translated error message that is presented to a user in
    case of disconnection, inability to connect, etc.
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : string</p>
    <p><pre>const char *obs_output_get_last_error(obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_mixer(output)</h3>
    <pre>
    Sets/gets the current audio mixer for non-encoded outputs.  For
    multi-track outputs, this would be the equivalent of setting the mask
    only for the specified mixer index.
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : number</p>
    <p><pre>size_t obs_output_get_mixer(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_mixers(output)</h3>
    <pre>
    Sets/gets the current audio mixers (via mask) for non-encoded
    multi-track outputs.  If used with single-track outputs, the
    single-track output will use either the first set mixer track in the
    bitmask, or the first track if none is set in the bitmask.
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : number</p>
    <p><pre>size_t obs_output_get_mixers(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_name(output)</h3>
    <pre>
    :return: The name of the output
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : string</p>
    <p><pre>const char *obs_output_get_name(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_pause_offset(output)</h3>
    <pre>
    Returns the current pause offset of the output.  Used with raw
    outputs to calculate system timestamps when using calculated
    timestamps (see FFmpeg output for an example).
    
    .. ---------------------------------------------------------------------------
    
    .. _libobs/obs-output.h: https://github.com/jp9000/obs-studio/blob/master/libobs/obs-output.h
    </pre>
    <p>output : obs_output</p>
    <p>Return : number</p>
    <p><pre>uint64_t obs_output_get_pause_offset(obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_proc_handler(output)</h3>
    <pre>
    :return: The procedure handler of the output
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : proc_handler</p>
    <p><pre>proc_handler_t *obs_output_get_proc_handler(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_ref(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_output</p>
    <hr/><h3>obs_output_get_service(output)</h3>
    <pre>
    Sets/gets the service for outputs that require services (such as RTMP
    outputs).  *obs_output_get_service* does not return an incremented
    reference.
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : obs_service</p>
    <p><pre>obs_service_t *obs_output_get_service(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_settings(output)</h3>
    <pre>
    :return: An incremented reference to the output's settings
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_output_get_settings(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_signal_handler(output)</h3>
    <pre>
    :return: The signal handler of the output
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : signal_handler</p>
    <p><pre>signal_handler_t *obs_output_get_signal_handler(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_supported_audio_codecs(output)</h3>
    <pre>
    :return: Supported video/audio codecs of an encoded output, separated
             by semicolen
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : string</p>
    <p><pre>const char *obs_output_get_supported_audio_codecs(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_supported_video_codecs(output)</h3>
    <pre>
    :return: Supported video/audio codecs of an encoded output, separated
             by semicolen
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : string</p>
    <p><pre>const char *obs_output_get_supported_video_codecs(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_total_bytes(output)</h3>
    <pre>
    :return: Total bytes sent/processed
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : number</p>
    <p><pre>uint64_t obs_output_get_total_bytes(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_total_frames(output)</h3>
    <pre>
    :return: Total frames sent/processed
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : number</p>
    <p><pre>int obs_output_get_total_frames(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_type_data(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_output</p>
    <hr/><h3>obs_output_get_video_encoder(output)</h3>
    <pre>
    Gets the video/audio encoders for an encoded output.
    
    :param idx:     The audio encoder index if the output supports
                    multiple audio streams at once
    :return:        The video/audio encoder.  The reference is not
                    incremented
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : obs_encoder</p>
    <p><pre>obs_encoder_t *obs_output_get_video_encoder(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_weak_output(output)</h3>
    <pre>
    These functions are used to get a weak reference from a strong output
    reference, or a strong output reference from a weak reference.  If
    the output is destroyed, *obs_weak_output_get_output* will return
    *NULL*.
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : obs_weak_output</p>
    <p><pre>obs_weak_output_t *obs_output_get_weak_output(obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_get_width(output)</h3>
    <pre>
    :return: The width/height of the output
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_output_get_width(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_initialize_encoders(output, flags)</h3>
    <pre>
    Initializes any encoders/services associated with the output.  This
    must be called for encoded outputs before calling
    :c:func:`obs_output_begin_data_capture()`.
    
    :param flags: Set to 0 to initialize both audio/video, otherwise a
                  bitwise OR combination of OBS_OUTPUT_VIDEO and/or
                  OBS_OUTPUT_AUDIO
    :return:      *true* if successful, *false* otherwise
    
    </pre>
    <p>output : obs_output</p>
    <p>flags : number</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_output_initialize_encoders(obs_output_t *output, uint32_t flags)</pre></p>
    <hr/><h3>obs_output_pause(output, pause)</h3>
    <pre>
    Pause an output (if supported by the output).
    
    :return: *true* if the output was paused successfully, *false*
             otherwise
    
    </pre>
    <p>output : obs_output</p>
    <p>pause : boolean</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_output_pause(obs_output_t *output, bool pause)</pre></p>
    <hr/><h3>obs_output_paused(output)</h3>
    <pre>
    :return: *true* if the output is paused, *false* otherwise
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_output_paused(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_properties(output)</h3>
    <pre>
    Use these functions to get the properties of an output or output
    type.  Properties are optionally used (if desired) to automatically
    generate user interface widgets to allow users to update settings.
    
    :return: The properties list for a specific existing output.  Free
             with :c:func:`obs_properties_destroy()`
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : obs_properties</p>
    <p><pre>obs_properties_t *obs_output_properties(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_reconnecting(output)</h3>
    <pre>
    :return: *true* if the output is currently reconnecting to a server,
             *false* otherwise
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_output_reconnecting(const obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_release(output)</h3>
    <pre>
    Adds/releases a reference to an output.  When the last reference is
    released, the output is destroyed.
    
    </pre>
    <p>output : obs_output</p>
    <p><pre>void obs_output_release(obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_set_audio_conversion(output, conversion)</h3>
    <pre>
    Optionally sets the audio conversion information.  Only used by raw
    outputs.
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    enum audio_format {
            AUDIO_FORMAT_UNKNOWN,
    
            AUDIO_FORMAT_U8BIT,
            AUDIO_FORMAT_16BIT,
            AUDIO_FORMAT_32BIT,
            AUDIO_FORMAT_FLOAT,
    
            AUDIO_FORMAT_U8BIT_PLANAR,
            AUDIO_FORMAT_16BIT_PLANAR,
            AUDIO_FORMAT_32BIT_PLANAR,
            AUDIO_FORMAT_FLOAT_PLANAR,
    };
    
    enum speaker_layout {
            SPEAKERS_UNKNOWN,
            SPEAKERS_MONO,
            SPEAKERS_STEREO,
            SPEAKERS_2POINT1,
            SPEAKERS_QUAD,
            SPEAKERS_4POINT1,
            SPEAKERS_5POINT1,
            SPEAKERS_5POINT1_SURROUND,
            SPEAKERS_7POINT1,
            SPEAKERS_7POINT1_SURROUND,
            SPEAKERS_SURROUND,
    };
    
    struct audio_convert_info {
            uint32_t            samples_per_sec;
            enum audio_format   format;
            enum speaker_layout speakers;
    };
    
    </pre>
    <p>output : obs_output</p>
    <p>conversion : audio_convert_info</p>
    <p><pre>void obs_output_set_audio_conversion(obs_output_t *output, const struct audio_convert_info *conversion)</pre></p>
    <hr/><h3>obs_output_set_audio_encoder(output, encoder, idx)</h3>
    <pre>
    Sets the video/audio encoders for an encoded output.
    
    :param encoder: The video/audio encoder
    :param idx:     The audio encoder index if the output supports
                    multiple audio streams at once
    
    </pre>
    <p>output : obs_output</p>
    <p>encoder : obs_encoder</p>
    <p>idx : number</p>
    <p><pre>void obs_output_set_audio_encoder(obs_output_t *output, obs_encoder_t *encoder, size_t idx)</pre></p>
    <hr/><h3>obs_output_set_delay(output, delay_sec, flags)</h3>
    <pre>
    Sets the current output delay, in seconds (if the output supports delay)
    
    If delay is currently active, it will set the delay value, but will not
    affect the current delay, it will only affect the next time the output is
    activated.
    
    :param delay_sec: Amount to delay the output, in seconds
    :param flags:      | Can be 0 or a combination of one of the following values:
                       | OBS_OUTPUT_DELAY_PRESERVE - On reconnection, start where it left of on reconnection.  Note however that this option will consume extra memory to continually increase delay while waiting to reconnect
    
    </pre>
    <p>output : obs_output</p>
    <p>delay_sec : number</p>
    <p>flags : number</p>
    <p><pre>void obs_output_set_delay(obs_output_t *output, uint32_t delay_sec, uint32_t flags)</pre></p>
    <hr/><h3>obs_output_set_last_error(output, message)</h3>
    <pre>
    Sets/gets the translated error message that is presented to a user in
    case of disconnection, inability to connect, etc.
    
    </pre>
    <p>output : obs_output</p>
    <p>message : string</p>
    <p><pre>void obs_output_set_last_error(obs_output_t *output, const char *message)</pre></p>
    <hr/><h3>obs_output_set_media(output, video, audio)</h3>
    <pre>
    Sets the current video/audio handlers for the output (typically
    :c:func:`obs_get_video()` and :c:func:`obs_get_audio()`).  Only used
    with raw outputs so they can catch the raw video/audio frames.
    
    </pre>
    <p>output : obs_output</p>
    <p>video : video_t</p>
    <p>audio : audio_t</p>
    <p><pre>void obs_output_set_media(obs_output_t *output, video_t *video, audio_t *audio)</pre></p>
    <hr/><h3>obs_output_set_mixer(output, mixer_idx)</h3>
    <pre>
    Sets/gets the current audio mixer for non-encoded outputs.  For
    multi-track outputs, this would be the equivalent of setting the mask
    only for the specified mixer index.
    
    </pre>
    <p>output : obs_output</p>
    <p>mixer_idx : number</p>
    <p><pre>void obs_output_set_mixer(obs_output_t *output, size_t mixer_idx)</pre></p>
    <hr/><h3>obs_output_set_mixers(output, mixers)</h3>
    <pre>
    Sets/gets the current audio mixers (via mask) for non-encoded
    multi-track outputs.  If used with single-track outputs, the
    single-track output will use either the first set mixer track in the
    bitmask, or the first track if none is set in the bitmask.
    
    </pre>
    <p>output : obs_output</p>
    <p>mixers : number</p>
    <p><pre>void obs_output_set_mixers(obs_output_t *output, size_t mixers)</pre></p>
    <hr/><h3>obs_output_set_preferred_size(output, width, height)</h3>
    <pre>
    Sets the preferred scaled resolution for this output.  Set width and height
    to 0 to disable scaling.
    
    If this output uses an encoder, it will call obs_encoder_set_scaled_size on
    the encoder before the stream is started.  If the encoder is already active,
    then this function will trigger a warning and do nothing.
    
    </pre>
    <p>output : obs_output</p>
    <p>width : number</p>
    <p>height : number</p>
    <p><pre>void obs_output_set_preferred_size(obs_output_t *output, uint32_t width, uint32_t height)</pre></p>
    <hr/><h3>obs_output_set_reconnect_settings(output, retry_count, retry_sec)</h3>
    <pre>
    Sets the auto-reconnect settings for outputs that support it.  The
    retry time will double on each retry to prevent overloading services.
    
    :param retry_count: Maximum retry count.  Set to 0 to disable
                        reconnecting
    :param retry_sec:   Starting retry wait duration, in seconds
    
    </pre>
    <p>output : obs_output</p>
    <p>retry_count : number</p>
    <p>retry_sec : number</p>
    <p><pre>void obs_output_set_reconnect_settings(obs_output_t *output, int retry_count, int retry_sec)</pre></p>
    <hr/><h3>obs_output_set_service(output, service)</h3>
    <pre>
    Sets/gets the service for outputs that require services (such as RTMP
    outputs).  *obs_output_get_service* does not return an incremented
    reference.
    
    </pre>
    <p>output : obs_output</p>
    <p>service : obs_service</p>
    <p><pre>void obs_output_set_service(obs_output_t *output, obs_service_t *service)</pre></p>
    <hr/><h3>obs_output_set_video_conversion(output, conversion)</h3>
    <pre>
    Optionally sets the video conversion information.  Only used by raw
    outputs.
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    enum video_format {
            VIDEO_FORMAT_NONE,
    
            /* planar 420 format */
            VIDEO_FORMAT_I420, /* three-plane */
            VIDEO_FORMAT_NV12, /* two-plane, luma and packed chroma */
    
            /* packed 422 formats */
            VIDEO_FORMAT_YVYU,
            VIDEO_FORMAT_YUY2, /* YUYV */
            VIDEO_FORMAT_UYVY,
    
            /* packed uncompressed formats */
            VIDEO_FORMAT_RGBA,
            VIDEO_FORMAT_BGRA,
            VIDEO_FORMAT_BGRX,
            VIDEO_FORMAT_Y800, /* grayscale */
    
            /* planar 4:4:4 */
            VIDEO_FORMAT_I444,
    };
    
    enum video_colorspace {
            VIDEO_CS_DEFAULT,
            VIDEO_CS_601,
            VIDEO_CS_709,
            VIDEO_CS_SRGB,
    };
    
    enum video_range_type {
            VIDEO_RANGE_DEFAULT,
            VIDEO_RANGE_PARTIAL,
            VIDEO_RANGE_FULL
    };
    
    struct video_scale_info {
            enum video_format     format;
            uint32_t              width;
            uint32_t              height;
            enum video_range_type range;
            enum video_colorspace colorspace;
    };
    
    </pre>
    <p>output : obs_output</p>
    <p>conversion : video_scale_info</p>
    <p><pre>void obs_output_set_video_conversion(obs_output_t *output, const struct video_scale_info *conversion)</pre></p>
    <hr/><h3>obs_output_set_video_encoder(output, encoder)</h3>
    <pre>
    Sets the video/audio encoders for an encoded output.
    
    :param encoder: The video/audio encoder
    :param idx:     The audio encoder index if the output supports
                    multiple audio streams at once
    
    </pre>
    <p>output : obs_output</p>
    <p>encoder : obs_encoder</p>
    <p><pre>void obs_output_set_video_encoder(obs_output_t *output, obs_encoder_t *encoder)</pre></p>
    <hr/><h3>obs_output_signal_stop(output, code)</h3>
    <pre>
    Ends data capture of an output with an output code, indicating that
    the output stopped unexpectedly.  This is typically used if for
    example the server was disconnected for some reason, or if there was
    an error saving to file.  The output will trigger the "stop" signal
    with the the desired code to indicate that the output has stopped
    successfully.  See :ref:`output_signal_handler_reference` for more
    information on output signals.
    
    :c:func:`obs_output_set_last_error()` may be used in conjunction with
    these error codes to optionally relay more detailed error information
    to the user
    
    :param code: | Can be one of the following values:
                 | OBS_OUTPUT_SUCCESS        - Successfully stopped
                 | OBS_OUTPUT_BAD_PATH       - The specified path was invalid
                 | OBS_OUTPUT_CONNECT_FAILED - Failed to connect to a server
                 | OBS_OUTPUT_INVALID_STREAM - Invalid stream path
                 | OBS_OUTPUT_ERROR          - Generic error
                 | OBS_OUTPUT_DISCONNECTED   - Unexpectedly disconnected
                 | OBS_OUTPUT_UNSUPPORTED    - The settings, video/audio format, or codecs are unsupported by this output
                 | OBS_OUTPUT_NO_SPACE       - Ran out of disk space
    
    </pre>
    <p>output : obs_output</p>
    <p>code : number</p>
    <p><pre>void obs_output_signal_stop(obs_output_t *output, int code)</pre></p>
    <hr/><h3>obs_output_start(output)</h3>
    <pre>
    Starts the output.
    
    :return: *true* if output successfully started, *false* otherwise.  If
             the output failed to start,
             :c:func:`obs_output_get_last_error()` may contain a specific
             error string related to the reason
    
    </pre>
    <p>output : obs_output</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_output_start(obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_stop(output)</h3>
    <pre>
    Requests the output to stop.  The output will wait until all data is
    sent up until the time the call was made, then when the output has
    successfully stopped, it will send the "stop" signal.  See
    :ref:`output_signal_handler_reference` for more information on output
    signals.
    
    </pre>
    <p>output : obs_output</p>
    <p><pre>void obs_output_stop(obs_output_t *output)</pre></p>
    <hr/><h3>obs_output_update(output, settings)</h3>
    <pre>
    Updates the settings for this output context.
    
    </pre>
    <p>output : obs_output</p>
    <p>settings : obs_data</p>
    <p><pre>void obs_output_update(obs_output_t *output, obs_data_t *settings)</pre></p>
    <hr/><h3>obs_post_load_modules()</h3>
    <pre>
    Notifies modules that all modules have been loaded.
    
    </pre>
    <p><pre>void obs_post_load_modules(void)</pre></p>
    <hr/><h3>obs_properties_add_bool(props, name, description)</h3>
    <pre>
    Adds a boolean property.
    
    :param    name:        Setting identifier string
    :param    description: Localized name shown to user
    :return:               The property
    
    </pre>
    <p>props : obs_properties</p>
    <p>name : string</p>
    <p>description : string</p>
    <p>Return : obs_property</p>
    <p><pre>obs_property_t *obs_properties_add_bool(obs_properties_t *props, const char *name, const char *description)</pre></p>
    <hr/><h3>obs_properties_add_button(properties, setting_name, text, callback)</h3>
    <pre>
    Adds a button property to an obs_properties_t object.  The callback
    takes two parameters:  the first parameter is the obs_properties_t
    object, and the second parameter is the obs_property_t for the
    button.
    
    :param properties:   An obs_properties_t object.
    :param setting_name: A setting identifier string.
    :param text:         Button text.
    :param callback:     Button callback.  This callback is automatically
                         cleaned up.
    
    </pre>
    <p>properties : unknown</p>
    <p>setting_name : unknown</p>
    <p>text : unknown</p>
    <p>callback : unknown</p>
    <p>Return : unknown</p>
    <hr/><h3>obs_properties_add_button2(param1, param2, param3, param4, param5)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_properties</p>
    <p>param2 : string</p>
    <p>param3 : string</p>
    <p>param4 : f_p_struct_obs_properties_p_struct_obs_property_p_void__bool</p>
    <p>param5 : ref_void*</p>
    <hr/><h3>obs_properties_add_color(props, name, description)</h3>
    <pre>
    Adds a color property.
    
    :param    name:        Setting identifier string
    :param    description: Localized name shown to user
    :return:               The property
    
    </pre>
    <p>props : obs_properties</p>
    <p>name : string</p>
    <p>description : string</p>
    <p>Return : obs_property</p>
    <p><pre>obs_property_t *obs_properties_add_color(obs_properties_t *props, const char *name, const char *description)</pre></p>
    <hr/><h3>obs_properties_add_editable_list(props, name, description, type, filter, default_path)</h3>
    <pre>
    Adds a list in which the user can add/insert/remove items.
    
    :param    name:         Setting identifier string
    :param    description:  Localized name shown to user
    :param    type:         Can be one of the following values:
    
                            - **OBS_EDITABLE_LIST_TYPE_STRINGS** - An
                              editable list of strings.
                            - **OBS_EDITABLE_LIST_TYPE_FILES** - An
                              editable list of files.
                            - **OBS_EDITABLE_LIST_TYPE_FILES_AND_URLS** -
                              An editable list of files and URLs.
    
    :param    filter:       File filter to use if a file list
    :param    default_path: Default path if a file list
    :return:                The property
    
    </pre>
    <p>props : obs_properties</p>
    <p>name : string</p>
    <p>description : string</p>
    <p>type : number</p>
    <p>filter : string</p>
    <p>default_path : string</p>
    <p>Return : obs_property</p>
    <p><pre>obs_property_t *obs_properties_add_editable_list(obs_properties_t *props, const char *name, const char *description, enum obs_editable_list_type type, const char *filter, const char *default_path)</pre></p>
    <hr/><h3>obs_properties_add_float(props, name, description, min, max, step)</h3>
    <pre>
    :param    name:        Setting identifier string
    :param    description: Localized name shown to user
    :param    min:         Minimum value
    :param    max:         Maximum value
    :param    step:        Step value
    :return:               The property
    
    </pre>
    <p>props : obs_properties</p>
    <p>name : string</p>
    <p>description : string</p>
    <p>min : number</p>
    <p>max : number</p>
    <p>step : number</p>
    <p>Return : obs_property</p>
    <p><pre>obs_property_t *obs_properties_add_float(obs_properties_t *props, const char *name, const char *description, double min, double max, double step)</pre></p>
    <hr/><h3>obs_properties_add_float_slider(props, name, description, min, max, step)</h3>
    <pre>
    :param    name:        Setting identifier string
    :param    description: Localized name shown to user
    :param    min:         Minimum value
    :param    max:         Maximum value
    :param    step:        Step value
    :return:               The property
    
    </pre>
    <p>props : obs_properties</p>
    <p>name : string</p>
    <p>description : string</p>
    <p>min : number</p>
    <p>max : number</p>
    <p>step : number</p>
    <p>Return : obs_property</p>
    <p><pre>obs_property_t *obs_properties_add_float_slider(obs_properties_t *props, const char *name, const char *description, double min, double max, double step)</pre></p>
    <hr/><h3>obs_properties_add_font(props, name, description)</h3>
    <pre>
    Adds a font property.
    
    :param    name:        Setting identifier string
    :param    description: Localized name shown to user
    :return:               The property
    
    </pre>
    <p>props : obs_properties</p>
    <p>name : string</p>
    <p>description : string</p>
    <p>Return : obs_property</p>
    <p><pre>obs_property_t *obs_properties_add_font(obs_properties_t *props, const char *name, const char *description)</pre></p>
    <hr/><h3>obs_properties_add_frame_rate(props, name, description)</h3>
    <pre>
    Adds a frame rate property.
    
    :param    name:        Setting identifier string
    :param    description: Localized name shown to user
    :return:               The property
    
    Important Related Functions:
    
    - :c:func:`obs_property_frame_rate_option_add`
    - :c:func:`obs_property_frame_rate_fps_range_add`
    - :c:func:`obs_property_frame_rate_option_insert`
    - :c:func:`obs_property_frame_rate_fps_range_insert`
    
    </pre>
    <p>props : obs_properties</p>
    <p>name : string</p>
    <p>description : string</p>
    <p>Return : obs_property</p>
    <p><pre>obs_property_t *obs_properties_add_frame_rate(obs_properties_t *props, const char *name, const char *description)</pre></p>
    <hr/><h3>obs_properties_add_group(props, name, description, type, group)</h3>
    <pre>
    Adds a property group.
    
    :param    name:        Setting identifier string
    :param    description: Localized name shown to user
    :param    type:        Can be one of the following values:
    
                           - **OBS_GROUP_NORMAL** - A normal group with just a name and content.
                           - **OBS_GROUP_CHECKABLE** - A checkable group with a checkbox, name and content.
    
    :param    group:       Group to add
    
    :return:               The property
    
    Important Related Functions:
    
    - :c:func:`obs_property_group_type`
    - :c:func:`obs_property_group_content`
    - :c:func:`obs_properties_get_parent`
    
    </pre>
    <p>props : obs_properties</p>
    <p>name : string</p>
    <p>description : string</p>
    <p>type : number</p>
    <p>group : obs_properties</p>
    <p>Return : obs_property</p>
    <p><pre>obs_property_t *obs_properties_add_group(obs_properties_t *props, const char *name, const char *description, enum obs_group_type type, obs_properties_t *group)</pre></p>
    <hr/><h3>obs_properties_add_int(props, name, description, min, max, step)</h3>
    <pre>
    Adds an integer property.
    
    :param    name:        Setting identifier string
    :param    description: Localized name shown to user
    :param    min:         Minimum value
    :param    max:         Maximum value
    :param    step:        Step value
    :return:               The property
    
    </pre>
    <p>props : obs_properties</p>
    <p>name : string</p>
    <p>description : string</p>
    <p>min : number</p>
    <p>max : number</p>
    <p>step : number</p>
    <p>Return : obs_property</p>
    <p><pre>obs_property_t *obs_properties_add_int(obs_properties_t *props, const char *name, const char *description, int min, int max, int step)</pre></p>
    <hr/><h3>obs_properties_add_int_slider(props, name, description, min, max, step)</h3>
    <pre>
    :param    name:        Setting identifier string
    :param    description: Localized name shown to user
    :param    min:         Minimum value
    :param    max:         Maximum value
    :param    step:        Step value
    :return:               The property
    
    </pre>
    <p>props : obs_properties</p>
    <p>name : string</p>
    <p>description : string</p>
    <p>min : number</p>
    <p>max : number</p>
    <p>step : number</p>
    <p>Return : obs_property</p>
    <p><pre>obs_property_t *obs_properties_add_int_slider(obs_properties_t *props, const char *name, const char *description, int min, int max, int step)</pre></p>
    <hr/><h3>obs_properties_add_list(props, name, description, type, format)</h3>
    <pre>
    Adds an integer/string/floating point item list.  This would be
    implemented as a combo box in user interface.
    
    :param    name:        Setting identifier string
    :param    description: Localized name shown to user
    :param    type:        Can be one of the following values:
    
                           - **OBS_COMBO_TYPE_EDITABLE** - Can be edited.
                             Only used with string lists.
                           - **OBS_COMBO_TYPE_LIST** - Not editable.
    
    :param    format:      Can be one of the following values:
    
                           - **OBS_COMBO_FORMAT_INT** - Integer list
                           - **OBS_COMBO_FORMAT_FLOAT** - Floating point
                             list
                           - **OBS_COMBO_FORMAT_STRING** - String list
    
    :return:               The property
    
    Important Related Functions:
    
    - :c:func:`obs_property_list_add_string`
    - :c:func:`obs_property_list_add_int`
    - :c:func:`obs_property_list_add_float`
    - :c:func:`obs_property_list_insert_string`
    - :c:func:`obs_property_list_insert_int`
    - :c:func:`obs_property_list_insert_float`
    - :c:func:`obs_property_list_item_remove`
    - :c:func:`obs_property_list_clear`
    
    </pre>
    <p>props : obs_properties</p>
    <p>name : string</p>
    <p>description : string</p>
    <p>type : number</p>
    <p>format : number</p>
    <p>Return : obs_property</p>
    <p><pre>obs_property_t *obs_properties_add_list(obs_properties_t *props, const char *name, const char *description, enum obs_combo_type type, enum obs_combo_format format)</pre></p>
    <hr/><h3>obs_properties_add_path(props, name, description, type, filter, default_path)</h3>
    <pre>
    Adds a 'path' property.  Can be a directory or a file.
    
    If target is a file path, the filters should be this format, separated by
    double semi-colens, and extensions separated by space::
    
      "Example types 1 and 2 (*.ex1 *.ex2);;Example type 3 (*.ex3)"
    
    :param    name:         Setting identifier string
    :param    description:  Localized name shown to user
    :param    type:         Can be one of the following values:
    
                            - **OBS_PATH_FILE** - File (for reading)
                            - **OBS_PATH_FILE_SAVE** - File (for writing)
                            - **OBS_PATH_DIRECTORY** - Directory
    
    :param    filter:       If type is a file path, then describes the file filter
                            that the user can browse.  Items are separated via
                            double semi-colens.  If multiple file types in a
                            filter, separate with space.
    :param    default_path: The default path to start in, or *NULL*
    :return:                The property
    
    </pre>
    <p>props : obs_properties</p>
    <p>name : string</p>
    <p>description : string</p>
    <p>type : number</p>
    <p>filter : string</p>
    <p>default_path : string</p>
    <p>Return : obs_property</p>
    <p><pre>obs_property_t *obs_properties_add_path(obs_properties_t *props, const char *name, const char *description, enum obs_path_type type, const char *filter, const char *default_path)</pre></p>
    <hr/><h3>obs_properties_add_text(props, name, description, type)</h3>
    <pre>
    :param    name:        Setting identifier string
    :param    description: Localized name shown to user
    :param    type:        Can be one of the following values:
    
                           - **OBS_TEXT_DEFAULT** - Single line of text
                           - **OBS_TEXT_PASSWORD** - Single line of text (passworded)
                           - **OBS_TEXT_MULTILINE** - Multi-line text
    
    :return:               The property
    
    </pre>
    <p>props : obs_properties</p>
    <p>name : string</p>
    <p>description : string</p>
    <p>type : number</p>
    <p>Return : obs_property</p>
    <p><pre>obs_property_t *obs_properties_add_text(obs_properties_t *props, const char *name, const char *description, enum obs_text_type type)</pre></p>
    <hr/><h3>obs_properties_apply_settings(props, settings)</h3>
    <pre>
    Applies settings to the properties by calling all the necessary
    modification callbacks
    
    </pre>
    <p>props : obs_properties</p>
    <p>settings : obs_data</p>
    <p><pre>void obs_properties_apply_settings(obs_properties_t *props, obs_data_t *settings)</pre></p>
    <hr/><h3>obs_properties_create()</h3>
    <pre>
    :return: A new properties object.
    
    </pre>
    <p>Return : obs_properties</p>
    <p><pre>obs_properties_t *obs_properties_create(void)</pre></p>
    <hr/><h3>obs_properties_create_param(param, destroy)</h3>
    <pre>
    Creates a new properties object with specific private data *param*
    associated with the object, and is automatically freed with the
    object when the properties are destroyed via the *destroy* function.
    
    :return: A new properties object.
    
    </pre>
    <p>param : ref_void*</p>
    <p>destroy : f_p_void__void</p>
    <p>Return : obs_properties</p>
    <p><pre>obs_properties_t *obs_properties_create_param(void *param, void (*destroy)(void *param))</pre></p>
    <hr/><h3>obs_properties_destroy(props)</h3>
    <pre>
    </pre>
    <p>props : obs_properties</p>
    <p><pre>void obs_properties_destroy(obs_properties_t *props)</pre></p>
    <hr/><h3>obs_properties_first(props)</h3>
    <pre>
    :return: The first property in the properties object.
    
    </pre>
    <p>props : obs_properties</p>
    <p>Return : obs_property</p>
    <p><pre>obs_property_t *obs_properties_first(obs_properties_t *props)</pre></p>
    <hr/><h3>obs_properties_get(props, property)</h3>
    <pre>
    :param property: The name of the property to get
    :return:         A specific property or *NULL* if not found
    
    </pre>
    <p>props : obs_properties</p>
    <p>property : string</p>
    <p>Return : obs_property</p>
    <p><pre>obs_property_t *obs_properties_get(obs_properties_t *props, const char *property)</pre></p>
    <hr/><h3>obs_properties_get_flags(props)</h3>
    <pre>
    :param flags: 0 or a bitwise OR combination of one of the following
                  values:
    
                  - OBS_PROPERTIES_DEFER_UPDATE - A hint that tells the
                    front-end to defers updating the settings until the
                    user has finished editing all properties rather than
                    immediately updating any settings
    
    </pre>
    <p>props : obs_properties</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_properties_get_flags(obs_properties_t *props)</pre></p>
    <hr/><h3>obs_properties_get_param(props)</h3>
    <pre>
    Sets custom data associated with this properties object.  If private
    data is already associated with the object, that private data will be
    destroyed before assigning new private data to it.
    
    </pre>
    <p>props : obs_properties</p>
    <p>Return : void</p>
    <p><pre>void *obs_properties_get_param(obs_properties_t *props)</pre></p>
    <hr/><h3>obs_properties_get_parent(props)</h3>
    <pre>
    </pre>
    <p>props : obs_properties</p>
    <p>Return : obs_properties</p>
    <p><pre>obs_properties_t *obs_properties_get_parent(obs_properties_t *props)</pre></p>
    <hr/><h3>obs_properties_remove_by_name(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_properties</p>
    <p>param2 : string</p>
    <hr/><h3>obs_properties_set_flags(props, flags)</h3>
    <pre>
    :param flags: 0 or a bitwise OR combination of one of the following
                  values:
    
                  - OBS_PROPERTIES_DEFER_UPDATE - A hint that tells the
                    front-end to defers updating the settings until the
                    user has finished editing all properties rather than
                    immediately updating any settings
    
    </pre>
    <p>props : obs_properties</p>
    <p>flags : number</p>
    <p><pre>void obs_properties_set_flags(obs_properties_t *props, uint32_t flags)</pre></p>
    <hr/><h3>obs_properties_set_param(props, param, destroy)</h3>
    <pre>
    Sets custom data associated with this properties object.  If private
    data is already associated with the object, that private data will be
    destroyed before assigning new private data to it.
    
    </pre>
    <p>props : obs_properties</p>
    <p>param : ref_void*</p>
    <p>destroy : f_p_void__void</p>
    <p><pre>void obs_properties_set_param(obs_properties_t *props, void *param, void (*destroy)(void *param))</pre></p>
    <hr/><h3>obs_property_button_clicked(p, obj)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>obj : ref_void*</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_property_button_clicked(obs_property_t *p, void *obj)</pre></p>
    <hr/><h3>obs_property_description(p)</h3>
    <pre>
    :return: The actual localized display name of the property
    
    *(Author's note: This one should have been the "name")*
    
    </pre>
    <p>p : obs_property</p>
    <p>Return : string</p>
    <p><pre>const char *           obs_property_description(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_editable_list_default_path(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : string</p>
    <p><pre>const char *obs_property_editable_list_default_path(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_editable_list_filter(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : string</p>
    <p><pre>const char *obs_property_editable_list_filter(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_editable_list_type(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>enum obs_editable_list_type obs_property_editable_list_type(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_enabled(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : boolean</p>
    <p><pre>bool                   obs_property_enabled(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_float_max(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>double                 obs_property_float_max(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_float_min(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>double                 obs_property_float_min(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_float_set_limits(p, min, max, step)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>min : number</p>
    <p>max : number</p>
    <p>step : number</p>
    <p><pre>void obs_property_float_set_limits(obs_property_t *p, double min, double max, double step)</pre></p>
    <hr/><h3>obs_property_float_set_suffix(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_property</p>
    <p>param2 : string</p>
    <hr/><h3>obs_property_float_step(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>double                 obs_property_float_step(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_float_suffix(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_property</p>
    <hr/><h3>obs_property_float_type(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>enum obs_number_type   obs_property_float_type(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_frame_rate_clear(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p><pre>void obs_property_frame_rate_clear(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_frame_rate_fps_range_add(p, min, max)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>min : media_frames_per_second</p>
    <p>max : media_frames_per_second</p>
    <p>Return : number</p>
    <p><pre>size_t obs_property_frame_rate_fps_range_add(obs_property_t *p, struct media_frames_per_second min, struct media_frames_per_second max)</pre></p>
    <hr/><h3>obs_property_frame_rate_fps_range_insert(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_property</p>
    <p>param2 : number</p>
    <p>param3 : media_frames_per_second</p>
    <p>param4 : media_frames_per_second</p>
    <hr/><h3>obs_property_frame_rate_fps_range_max(p, idx)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>idx : number</p>
    <p>Return : media_frames_per_second</p>
    <p><pre>struct media_frames_per_second obs_property_frame_rate_fps_range_max( obs_property_t *p, size_t idx)</pre></p>
    <hr/><h3>obs_property_frame_rate_fps_range_min(p, idx)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>idx : number</p>
    <p>Return : media_frames_per_second</p>
    <p><pre>struct media_frames_per_second obs_property_frame_rate_fps_range_min( obs_property_t *p, size_t idx)</pre></p>
    <hr/><h3>obs_property_frame_rate_fps_ranges_clear(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p><pre>void obs_property_frame_rate_fps_ranges_clear(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_frame_rate_fps_ranges_count(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>size_t      obs_property_frame_rate_fps_ranges_count(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_frame_rate_option_add(p, name, description)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>name : string</p>
    <p>description : string</p>
    <p>Return : number</p>
    <p><pre>size_t obs_property_frame_rate_option_add(obs_property_t *p, const char *name, const char *description)</pre></p>
    <hr/><h3>obs_property_frame_rate_option_description(p, idx)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>idx : number</p>
    <p>Return : string</p>
    <p><pre>const char *obs_property_frame_rate_option_description( obs_property_t *p, size_t idx)</pre></p>
    <hr/><h3>obs_property_frame_rate_option_insert(p, idx, name, description)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>idx : number</p>
    <p>name : string</p>
    <p>description : string</p>
    <p><pre>void obs_property_frame_rate_option_insert(obs_property_t *p, size_t idx, const char *name, const char *description)</pre></p>
    <hr/><h3>obs_property_frame_rate_option_name(p, idx)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>idx : number</p>
    <p>Return : string</p>
    <p><pre>const char *obs_property_frame_rate_option_name(obs_property_t *p, size_t idx)</pre></p>
    <hr/><h3>obs_property_frame_rate_options_clear(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p><pre>void obs_property_frame_rate_options_clear(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_frame_rate_options_count(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>size_t      obs_property_frame_rate_options_count(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_get_type(p)</h3>
    <pre>
    :return: One of the following values:
    
             - OBS_PROPERTY_INVALID
             - OBS_PROPERTY_BOOL
             - OBS_PROPERTY_INT
             - OBS_PROPERTY_FLOAT
             - OBS_PROPERTY_TEXT
             - OBS_PROPERTY_PATH
             - OBS_PROPERTY_LIST
             - OBS_PROPERTY_COLOR
             - OBS_PROPERTY_BUTTON
             - OBS_PROPERTY_FONT
             - OBS_PROPERTY_EDITABLE_LIST
             - OBS_PROPERTY_FRAME_RATE
             - OBS_PROPERTY_GROUP
    
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>enum obs_property_type obs_property_get_type(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_group_content(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : obs_properties</p>
    <p><pre>obs_properties_t *obs_property_group_content(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_group_type(p)</h3>
    <pre>
      :return: One of the following values:
    
             - OBS_COMBO_INVALID
             - OBS_GROUP_NORMAL
             - OBS_GROUP_CHECKABLE
    
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>enum obs_group_type obs_property_group_type(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_int_max(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>int                    obs_property_int_max(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_int_min(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>int                    obs_property_int_min(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_int_set_limits(p, min, max, step)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>min : number</p>
    <p>max : number</p>
    <p>step : number</p>
    <p><pre>void obs_property_int_set_limits(obs_property_t *p, int min, int max, int step)</pre></p>
    <hr/><h3>obs_property_int_set_suffix(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_property</p>
    <p>param2 : string</p>
    <hr/><h3>obs_property_int_step(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>int                    obs_property_int_step(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_int_suffix(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_property</p>
    <hr/><h3>obs_property_int_type(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>enum obs_number_type   obs_property_int_type(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_list_add_float(p, name, val)</h3>
    <pre>
    Adds a floating point to a floating point list.
    
    </pre>
    <p>p : obs_property</p>
    <p>name : string</p>
    <p>val : number</p>
    <p>Return : number</p>
    <p><pre>size_t obs_property_list_add_float(obs_property_t *p, const char *name, double val)</pre></p>
    <hr/><h3>obs_property_list_add_int(p, name, val)</h3>
    <pre>
    Adds an integer to a integer list.
    
    </pre>
    <p>p : obs_property</p>
    <p>name : string</p>
    <p>val : number</p>
    <p>Return : number</p>
    <p><pre>size_t obs_property_list_add_int(obs_property_t *p, const char *name, long long val)</pre></p>
    <hr/><h3>obs_property_list_add_string(p, name, val)</h3>
    <pre>
    Adds a string to a string list.
    
    </pre>
    <p>p : obs_property</p>
    <p>name : string</p>
    <p>val : string</p>
    <p>Return : number</p>
    <p><pre>size_t obs_property_list_add_string(obs_property_t *p, const char *name, const char *val)</pre></p>
    <hr/><h3>obs_property_list_clear(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p><pre>void obs_property_list_clear(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_list_format(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>enum obs_combo_format  obs_property_list_format(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_list_insert_float(p, idx, name, val)</h3>
    <pre>
    Inserts a floating point in to a floating point list.
    
    </pre>
    <p>p : obs_property</p>
    <p>idx : number</p>
    <p>name : string</p>
    <p>val : number</p>
    <p><pre>void obs_property_list_insert_float(obs_property_t *p, size_t idx, const char *name, double val)</pre></p>
    <hr/><h3>obs_property_list_insert_int(p, idx, name, val)</h3>
    <pre>
    Inserts an integer in to an integer list.
    
    </pre>
    <p>p : obs_property</p>
    <p>idx : number</p>
    <p>name : string</p>
    <p>val : number</p>
    <p><pre>void obs_property_list_insert_int(obs_property_t *p, size_t idx, const char *name, long long val)</pre></p>
    <hr/><h3>obs_property_list_insert_string(p, idx, name, val)</h3>
    <pre>
    Inserts a string in to a string list.
    
    </pre>
    <p>p : obs_property</p>
    <p>idx : number</p>
    <p>name : string</p>
    <p>val : string</p>
    <p><pre>void obs_property_list_insert_string(obs_property_t *p, size_t idx, const char *name, const char *val)</pre></p>
    <hr/><h3>obs_property_list_item_count(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>size_t      obs_property_list_item_count(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_list_item_disable(p, idx, disabled)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>idx : number</p>
    <p>disabled : boolean</p>
    <p><pre>void obs_property_list_item_disable(obs_property_t *p, size_t idx, bool disabled)</pre></p>
    <hr/><h3>obs_property_list_item_disabled(p, idx)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>idx : number</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_property_list_item_disabled(obs_property_t *p, size_t idx)</pre></p>
    <hr/><h3>obs_property_list_item_float(p, idx)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>idx : number</p>
    <p>Return : number</p>
    <p><pre>double      obs_property_list_item_float(obs_property_t *p, size_t idx)</pre></p>
    <hr/><h3>obs_property_list_item_int(p, idx)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>idx : number</p>
    <p>Return : number</p>
    <p><pre>long long   obs_property_list_item_int(obs_property_t *p, size_t idx)</pre></p>
    <hr/><h3>obs_property_list_item_name(p, idx)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>idx : number</p>
    <p>Return : string</p>
    <p><pre>const char *obs_property_list_item_name(obs_property_t *p, size_t idx)</pre></p>
    <hr/><h3>obs_property_list_item_remove(p, idx)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>idx : number</p>
    <p><pre>void obs_property_list_item_remove(obs_property_t *p, size_t idx)</pre></p>
    <hr/><h3>obs_property_list_item_string(p, idx)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>idx : number</p>
    <p>Return : string</p>
    <p><pre>const char *obs_property_list_item_string(obs_property_t *p, size_t idx)</pre></p>
    <hr/><h3>obs_property_list_type(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>enum obs_combo_type    obs_property_list_type(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_long_description(p)</h3>
    <pre>
    :return: A detailed description of what the setting is used for.
             Usually used with things like tooltips.
    
    </pre>
    <p>p : obs_property</p>
    <p>Return : string</p>
    <p><pre>const char *           obs_property_long_description(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_modified(p, settings)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>settings : obs_data</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_property_modified(obs_property_t *p, obs_data_t *settings)</pre></p>
    <hr/><h3>obs_property_name(p)</h3>
    <pre>
    :return: The setting identifier string of the property
    
    *(Author's Note: "name" was a bad name to use here.  Should have been
    "setting")*
    
    </pre>
    <p>p : obs_property</p>
    <p>Return : string</p>
    <p><pre>const char *           obs_property_name(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_next(p)</h3>
    <pre>
    :param p: Pointer to the pointer of the next property
    :return: *true* if successful, *false* if no more properties
    
    </pre>
    <p>p : p_obs_property</p>
    <p>Return : boolean</p>
    <p><pre>bool                   obs_property_next(obs_property_t **p)</pre></p>
    <hr/><h3>obs_property_path_default_path(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : string</p>
    <p><pre>const char *           obs_property_path_default_path(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_path_filter(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : string</p>
    <p><pre>const char *           obs_property_path_filter(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_path_type(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>enum obs_path_type     obs_property_path_type(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_set_description(p, description)</h3>
    <pre>
    Sets the displayed localized name of the property, shown to the user.
    
    </pre>
    <p>p : obs_property</p>
    <p>description : string</p>
    <p><pre>void obs_property_set_description(obs_property_t *p, const char *description)</pre></p>
    <hr/><h3>obs_property_set_enabled(p, enabled)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>enabled : boolean</p>
    <p><pre>void obs_property_set_enabled(obs_property_t *p, bool enabled)</pre></p>
    <hr/><h3>obs_property_set_long_description(p, long_description)</h3>
    <pre>
    Sets the localized long description of the property, usually shown to
    a user via tooltip.
    
    </pre>
    <p>p : obs_property</p>
    <p>long_description : string</p>
    <p><pre>void obs_property_set_long_description(obs_property_t *p, const char *long_description)</pre></p>
    <hr/><h3>obs_property_set_modified_callback(p, modified)</h3>
    <pre>
    Allows the ability to change the properties depending on what
    settings are used by the user.
    
    Relevant data types used with these functions:
    
    .. code:: cpp
    
    typedef bool (*obs_property_modified_t)(obs_properties_t *props,
                    obs_property_t *property, obs_data_t *settings);
    typedef bool (*obs_property_modified2_t)(void *priv,
                    obs_properties_t *props, obs_property_t *property,
                    obs_data_t *settings);
    
    </pre>
    <p>p : obs_property_t*</p>
    <p>modified : obs_property_modified_t</p>
    <p><pre>void obs_property_set_modified_callback(obs_property_t *p, obs_property_modified_t modified)</pre></p>
    <hr/><h3>obs_property_set_modified_callback2(p, modified2, priv)</h3>
    <pre>
    Allows the ability to change the properties depending on what
    settings are used by the user.
    
    Relevant data types used with these functions:
    
    .. code:: cpp
    
    typedef bool (*obs_property_modified_t)(obs_properties_t *props,
                    obs_property_t *property, obs_data_t *settings);
    typedef bool (*obs_property_modified2_t)(void *priv,
                    obs_properties_t *props, obs_property_t *property,
                    obs_data_t *settings);
    
    </pre>
    <p>p : obs_property</p>
    <p>modified2 : f_p_void_p_struct_obs_properties_p_struct_obs_property_p_struct_obs_data__bool</p>
    <p>priv : ref_void*</p>
    <p><pre>void obs_property_set_modified_callback2(obs_property_t *p, obs_property_modified2_t modified2, void *priv)</pre></p>
    <hr/><h3>obs_property_set_visible(p, visible)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>visible : boolean</p>
    <p><pre>void obs_property_set_visible(obs_property_t *p, bool visible)</pre></p>
    <hr/><h3>obs_property_text_monospace(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_property</p>
    <hr/><h3>obs_property_text_set_monospace(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_property</p>
    <p>param2 : boolean</p>
    <hr/><h3>obs_property_text_type(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : number</p>
    <p><pre>enum obs_text_type     obs_property_text_type(obs_property_t *p)</pre></p>
    <hr/><h3>obs_property_visible(p)</h3>
    <pre>
    </pre>
    <p>p : obs_property</p>
    <p>Return : boolean</p>
    <p><pre>bool                   obs_property_visible(obs_property_t *p)</pre></p>
    <hr/><h3>obs_queue_task(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : f_p_void__void</p>
    <p>param3 : ref_void*</p>
    <p>param4 : boolean</p>
    <hr/><h3>obs_register_source(info)</h3>
    <pre>
    Registers a source type.  Typically used in
    :c:func:`obs_module_load()` or in the program's initialization phase.
    
    </pre>
    <p>info : obs_source_info*</p>
    <p><pre>void obs_register_source(struct obs_source_info *info)</pre></p>
    <hr/><h3>obs_remove_data_path(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <hr/><h3>obs_remove_main_render_callback(callback)</h3>
    <pre>
    **Lua only:** Removes a primary output render callback.
    
    :param callback: Render callback.
    
    </pre>
    <p>callback : unknown</p>
    <p>Return : unknown</p>
    <hr/><h3>obs_remove_raw_video_callback(callback, param)</h3>
    <pre>
    Adds/removes a raw video callback.  Allows the ability to obtain raw
    video frames without necessarily using an output.
    
    :param conversion: Specifies conversion requirements.  Can be NULL.
    :param callback:   The callback that receives raw video frames.
    :param param:      The private data associated with the callback.
    
    Primary signal/procedure handlers
    </pre>
    <p>callback : f_p_void_p_struct_video_data__void</p>
    <p>param : ref_void*</p>
    <p><pre>void obs_remove_raw_video_callback(void (*callback)(void *param, struct video_data *frame), void *param)</pre></p>
    <hr/><h3>obs_render_main_texture()</h3>
    <pre>
    Renders the main output texture.  Useful for rendering a preview pane
    of the main output.
    
    </pre>
    <p><pre>void obs_render_main_texture(void)</pre></p>
    <hr/><h3>obs_render_main_texture_src_color_only()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_reset_audio(oai)</h3>
    <pre>
    Sets base audio output format/channels/samples/etc.
    
    Note: Cannot reset base audio if an output is currently active.
    
    :return: *true* if successful, *false* otherwise
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    struct obs_audio_info {
            uint32_t            samples_per_sec;
            enum speaker_layout speakers;
    };
    
    </pre>
    <p>oai : obs_audio_info</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_reset_audio(const struct obs_audio_info *oai)</pre></p>
    <hr/><h3>obs_reset_video(ovi)</h3>
    <pre>
    Sets base video output base resolution/fps/format.
    
    Note: This data cannot be changed if an output is currently active.
    
    Note: The graphics module cannot be changed without fully destroying
    the OBS context.
    
    :param   ovi: Pointer to an obs_video_info structure containing the
                  specification of the graphics subsystem,
    :return:      | OBS_VIDEO_SUCCESS          - Success
                  | OBS_VIDEO_NOT_SUPPORTED    - The adapter lacks capabilities
                  | OBS_VIDEO_INVALID_PARAM    - A parameter is invalid
                  | OBS_VIDEO_CURRENTLY_ACTIVE - Video is currently active
                  | OBS_VIDEO_MODULE_NOT_FOUND - The graphics module is not found
                  | OBS_VIDEO_FAIL             - Generic failure
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    struct obs_video_info {
            /**
             * Graphics module to use (usually "libobs-opengl" or "libobs-d3d11")
             */
            const char          *graphics_module;
    
            uint32_t            fps_num;       /**< Output FPS numerator */
            uint32_t            fps_den;       /**< Output FPS denominator */
    
            uint32_t            base_width;    /**< Base compositing width */
            uint32_t            base_height;   /**< Base compositing height */
    
            uint32_t            output_width;  /**< Output width */
            uint32_t            output_height; /**< Output height */
            enum video_format   output_format; /**< Output format */
    
            /** Video adapter index to use (NOTE: avoid for optimus laptops) */
            uint32_t            adapter;
    
            /** Use shaders to convert to different color formats */
            bool                gpu_conversion;
    
            enum video_colorspace colorspace;  /**< YUV type (if YUV) */
            enum video_range_type range;       /**< YUV range (if YUV) */
    
            enum obs_scale_type scale_type;    /**< How to scale if scaling */
    };
    
    </pre>
    <p>ovi : obs_video_info</p>
    <p>Return : number</p>
    <p><pre>int obs_reset_video(struct obs_video_info *ovi)</pre></p>
    <hr/><h3>obs_save_source(source)</h3>
    <pre>
    :return: A new reference to a source's saved data
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_save_source(obs_source_t *source)</pre></p>
    <hr/><h3>obs_save_sources()</h3>
    <pre>
    :return: A data array with the saved data of all active sources
    
    </pre>
    <p>Return : obs_data_array</p>
    <p><pre>obs_data_array_t *obs_save_sources(void)</pre></p>
    <hr/><h3>obs_save_sources_filtered(cb, data)</h3>
    <pre>
    :return: A data array with the saved data of all active sources,
             filtered by the *cb* function
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    typedef bool (*obs_save_source_filter_cb)(void *data, obs_source_t *source);
    
    </pre>
    <p>cb : f_p_void_p_struct_obs_source__bool</p>
    <p>data : ref_void*</p>
    <p>Return : obs_data_array</p>
    <p><pre>obs_data_array_t *obs_save_sources_filtered(obs_save_source_filter_cb cb, void *data)</pre></p>
    <hr/><h3>obs_scene_add(scene, source)</h3>
    <pre>
    :return: A new scene item for a source within a scene.  Does not
             increment the reference
    
    </pre>
    <p>scene : obs_scene</p>
    <p>source : obs_source</p>
    <p>Return : obs_scene_item</p>
    <p><pre>obs_sceneitem_t *obs_scene_add(obs_scene_t *scene, obs_source_t *source)</pre></p>
    <hr/><h3>obs_scene_add_group(scene, name)</h3>
    <pre>
    Adds a group with the specified name.  Does not signal the scene with
    the *refresh* signal.
    
    :param scene: Scene to add the group to
    :param name:  Name of the group
    :return:      The new group's scene item
    
    </pre>
    <p>scene : obs_scene</p>
    <p>name : string</p>
    <p>Return : obs_scene_item</p>
    <p><pre>obs_sceneitem_t *obs_scene_add_group(obs_scene_t *scene, const char *name)</pre></p>
    <hr/><h3>obs_scene_add_group2(scene, name, signal)</h3>
    <pre>
    Adds a group with the specified name.
    
    :param scene:  Scene to add the group to
    :param name:   Name of the group
    :param signal: If *true*, signals the scene with the *refresh*
                   signal
    :return:       The new group's scene item
    
    </pre>
    <p>scene : obs_scene</p>
    <p>name : string</p>
    <p>signal : boolean</p>
    <p>Return : obs_scene_item</p>
    <p><pre>obs_sceneitem_t *obs_scene_add_group2(obs_scene_t *scene, const char *name, bool signal)</pre></p>
    <hr/><h3>obs_scene_addref(scene)</h3>
    <pre>
    Adds/releases a reference to a scene.
    
    </pre>
    <p>scene : obs_scene</p>
    <p><pre>void obs_scene_addref(obs_scene_t *scene)</pre></p>
    <hr/><h3>obs_scene_atomic_update(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_scene</p>
    <p>param2 : f_p_void_p_struct_obs_scene__void</p>
    <p>param3 : ref_void*</p>
    <hr/><h3>obs_scene_create(name)</h3>
    <pre>
    :param name: Name of the scene source.  If it's not unique, it will
                 be made unique
    :return:     A reference to a scene
    
    </pre>
    <p>name : string</p>
    <p>Return : obs_scene</p>
    <p><pre>obs_scene_t *obs_scene_create(const char *name)</pre></p>
    <hr/><h3>obs_scene_create_private(name)</h3>
    <pre>
    :param name: Name of the scene source.  Does not have to be unique,
                 or can be *NULL*
    :return:     A reference to a private scene
    
    </pre>
    <p>name : string</p>
    <p>Return : obs_scene</p>
    <p><pre>obs_scene_t *obs_scene_create_private(const char *name)</pre></p>
    <hr/><h3>obs_scene_duplicate(scene, name, type)</h3>
    <pre>
    Duplicates a scene.  When a scene is duplicated, its sources can be
    just referenced, or fully duplicated.
    
    :param name: Name of the new scene source
    
    :param type:  | Type of duplication:
                  | OBS_SCENE_DUP_REFS         - Duplicates the scene, but scene items are only duplicated with references
                  | OBS_SCENE_DUP_COPY         - Duplicates the scene, and scene items are also fully duplicated when possible
                  | OBS_SCENE_DUP_PRIVATE_REFS - Duplicates with references, but the scene is a private source
                  | OBS_SCENE_DUP_PRIVATE_COPY - Fully duplicates scene items when possible, but the scene and duplicates sources are private sources
    
    :return:     A reference to a new scene
    
    </pre>
    <p>scene : obs_scene</p>
    <p>name : string</p>
    <p>type : number</p>
    <p>Return : obs_scene</p>
    <p><pre>obs_scene_t *obs_scene_duplicate(obs_scene_t *scene, const char *name, enum obs_scene_duplicate_type type)</pre></p>
    <hr/><h3>obs_scene_enum_items(scene, param2, param3)</h3>
    <pre>
    Enumerates scene items within a scene.
    
    :param scene: obs_scene_t object to enumerate items from.
    :return:      List of scene items.  Release with
                  :py:func:`sceneitem_list_release()`.
    
    </pre>
    <p>scene : obs_scene</p>
    <p>param2 : f_p_struct_obs_scene_p_struct_obs_scene_item_p_void__bool</p>
    <p>param3 : ref_void*</p>
    <p>Return : unknown</p>
    <hr/><h3>obs_scene_find_sceneitem_by_id(scene, id)</h3>
    <pre>
    :param id: The unique numeric identifier of the scene item
    :return:   The scene item if found, otherwise *NULL* if not found
    
    </pre>
    <p>scene : obs_scene</p>
    <p>id : number</p>
    <p>Return : obs_scene_item</p>
    <p><pre>obs_sceneitem_t *obs_scene_find_sceneitem_by_id(obs_scene_t *scene, int64_t id)</pre></p>
    <hr/><h3>obs_scene_find_source(scene, name)</h3>
    <pre>
    :param name: The name of the source to find
    :return:     The scene item if found, otherwise *NULL* if not found
    
    </pre>
    <p>scene : obs_scene</p>
    <p>name : string</p>
    <p>Return : obs_scene_item</p>
    <p><pre>obs_sceneitem_t *obs_scene_find_source(obs_scene_t *scene, const char *name)</pre></p>
    <hr/><h3>obs_scene_find_source_recursive(scene, name)</h3>
    <pre>
    Same as obs_scene_find_source, but also searches groups within the
    scene.
    
    :param name: The name of the source to find
    :return:     The scene item if found, otherwise *NULL* if not found
    
    </pre>
    <p>scene : obs_scene</p>
    <p>name : string</p>
    <p>Return : obs_scene_item</p>
    <p><pre>obs_sceneitem_t *obs_scene_find_source_recursive(obs_scene_t *scene, const char *name)</pre></p>
    <hr/><h3>obs_scene_from_source(source)</h3>
    <pre>
    :return: The scene context, or *NULL* if not a scene.  Does not
             increase the reference
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : obs_scene</p>
    <p><pre>obs_scene_t *obs_scene_from_source(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_scene_get_group(scene, name)</h3>
    <pre>
    Finds a group within a scene by its name.
    
    :param scene: Scene to find the group within
    :param name:  The name of the group to find
    :return:      The group scene item, or *NULL* if not found
    
    </pre>
    <p>scene : obs_scene</p>
    <p>name : string</p>
    <p>Return : obs_scene_item</p>
    <p><pre>obs_sceneitem_t *obs_scene_get_group(obs_scene_t *scene, const char *name)</pre></p>
    <hr/><h3>obs_scene_get_source(scene)</h3>
    <pre>
    :return: The scene's source.  Does not increment the reference
    
    </pre>
    <p>scene : obs_scene</p>
    <p>Return : obs_source</p>
    <p><pre>obs_source_t *obs_scene_get_source(const obs_scene_t *scene)</pre></p>
    <hr/><h3>obs_scene_insert_group(scene, name, items, count)</h3>
    <pre>
    Creates a group out of the specified scene items.  The group will be
    inserted at the top scene item.  Does not signal the scene with the
    *refresh* signal.
    
    :param scene: Scene to add the group to
    :param name:  Name of the group
    :param items: Array of scene items to put in a group
    :param count: Number of scene items in the array
    :return:      The new group's scene item
    
    </pre>
    <p>scene : obs_scene</p>
    <p>name : string</p>
    <p>items : p_obs_scene_item</p>
    <p>count : number</p>
    <p>Return : obs_scene_item</p>
    <p><pre>obs_sceneitem_t *obs_scene_insert_group(obs_scene_t *scene, const char *name, obs_sceneitem_t **items, size_t count)</pre></p>
    <hr/><h3>obs_scene_insert_group2(scene, name, items, count, signal)</h3>
    <pre>
    Creates a group out of the specified scene items.  The group will be
    inserted at the top scene item.  Does not signal a refresh.
    
    :param scene: Scene to add the group to
    :param name:  Name of the group
    :param items: Array of scene items to put in a group
    :param count: Number of scene items in the array
    :param signal: If *true*, signals the scene with the *refresh*
                   signal
    :return:      The new group's scene item
    
    </pre>
    <p>scene : obs_scene</p>
    <p>name : string</p>
    <p>items : p_obs_scene_item</p>
    <p>count : number</p>
    <p>signal : boolean</p>
    <p>Return : obs_scene_item</p>
    <p><pre>obs_sceneitem_t *obs_scene_insert_group2(obs_scene_t *scene, const char *name, obs_sceneitem_t **items, size_t count, bool signal)</pre></p>
    <hr/><h3>obs_scene_is_group(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_scene</p>
    <hr/><h3>obs_scene_release(scene)</h3>
    <pre>
    Adds/releases a reference to a scene.
    
    </pre>
    <p>scene : obs_scene</p>
    <p><pre>void obs_scene_release(obs_scene_t *scene)</pre></p>
    <hr/><h3>obs_scene_reorder_items(scene, item_order, item_order_size)</h3>
    <pre>
    Reorders items within a scene.
    
    </pre>
    <p>scene : obs_scene</p>
    <p>item_order : p_obs_scene_item</p>
    <p>item_order_size : number</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_scene_reorder_items(obs_scene_t *scene, obs_sceneitem_t * const *item_order, size_t item_order_size)</pre></p>
    <hr/><h3>obs_scene_reorder_items2(scene, item_order, item_order_size)</h3>
    <pre>
    Reorders items within a scene with groups and group sub-items.
    
    </pre>
    <p>scene : obs_scene</p>
    <p>item_order : obs_sceneitem_order_info</p>
    <p>item_order_size : number</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_scene_reorder_items2(obs_scene_t *scene, struct obs_sceneitem_order_info *item_order, size_t item_order_size)</pre></p>
    <hr/><h3>obs_sceneitem_addref(item)</h3>
    <pre>
    Adds/releases a reference to a scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p><pre>void obs_sceneitem_addref(obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_defer_group_resize_begin(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_scene_item</p>
    <hr/><h3>obs_sceneitem_defer_group_resize_end(item)</h3>
    <pre>
    Allows the ability to call any one of the transform functions on
    scene items within a group without updating the internal matrices of
    the group until obs_sceneitem_defer_group_resize_end has been called.
    
    This is necessary if the user is resizing items while they are within
    a group, as the group's transform will automatically update its
    transform every frame otherwise.
    </pre>
    <p>item : obs_scene_item</p>
    <p><pre>void obs_sceneitem_defer_group_resize_end(obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_defer_update_begin(item)</h3>
    <pre>
    Allows the ability to call any one of the transform functions without
    updating the internal matrices until obs_sceneitem_defer_update_end
    has been called.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p><pre>void obs_sceneitem_defer_update_begin(obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_defer_update_end(item)</h3>
    <pre>
    Allows the ability to call any one of the transform functions without
    updating the internal matrices until obs_sceneitem_defer_update_end
    has been called.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p><pre>void obs_sceneitem_defer_update_end(obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_force_update_transform(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_scene_item</p>
    <hr/><h3>obs_sceneitem_get_alignment(item)</h3>
    <pre>
    Sets/gets the alignment of the scene item relative to its position.
    
    :param alignment: | Can be any bitwise OR combination of:
                      | OBS_ALIGN_CENTER
                      | OBS_ALIGN_LEFT
                      | OBS_ALIGN_RIGHT
                      | OBS_ALIGN_TOP
                      | OBS_ALIGN_BOTTOM
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_sceneitem_get_alignment(const obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_get_bounds(item, bounds)</h3>
    <pre>
    Sets/gets the bounding box width/height of the scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>bounds : vec2</p>
    <p><pre>void obs_sceneitem_get_bounds(const obs_sceneitem_t *item, struct vec2 *bounds)</pre></p>
    <hr/><h3>obs_sceneitem_get_bounds_alignment(item)</h3>
    <pre>
    Sets/gets the alignment of the source within the bounding box.
    
    :param alignment: | Can be any bitwise OR combination of:
                      | OBS_ALIGN_CENTER
                      | OBS_ALIGN_LEFT
                      | OBS_ALIGN_RIGHT
                      | OBS_ALIGN_TOP
                      | OBS_ALIGN_BOTTOM
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_sceneitem_get_bounds_alignment(const obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_get_bounds_type(item)</h3>
    <pre>
    Sets/gets the bounding box type of a scene item.  Bounding boxes are
    used to stretch/position the source relative to a specific bounding
    box of a specific size.
    
    :param type: | Can be one of the following values:
                 | OBS_BOUNDS_NONE            - No bounding box
                 | OBS_BOUNDS_STRETCH         - Stretch to the bounding box without preserving aspect ratio
                 | OBS_BOUNDS_SCALE_INNER     - Scales with aspect ratio to inner bounding box rectangle
                 | OBS_BOUNDS_SCALE_OUTER     - Scales with aspect ratio to outer bounding box rectangle
                 | OBS_BOUNDS_SCALE_TO_WIDTH  - Scales with aspect ratio to the bounding box width
                 | OBS_BOUNDS_SCALE_TO_HEIGHT - Scales with aspect ratio to the bounding box height
                 | OBS_BOUNDS_MAX_ONLY        - Scales with aspect ratio, but only to the size of the source maximum
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>Return : number</p>
    <p><pre>enum obs_bounds_type obs_sceneitem_get_bounds_type(const obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_get_box_scale(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_scene_item</p>
    <p>param2 : vec2</p>
    <hr/><h3>obs_sceneitem_get_box_transform(item, transform)</h3>
    <pre>
    Gets the transform matrix of the scene item used for the bounding box
    or edges of the scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>transform : matrix4</p>
    <p><pre>void obs_sceneitem_get_box_transform(const obs_sceneitem_t *item, struct matrix4 *transform)</pre></p>
    <hr/><h3>obs_sceneitem_get_crop(item, crop)</h3>
    <pre>
    Sets/gets the cropping of the scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>crop : obs_sceneitem_crop</p>
    <p><pre>void obs_sceneitem_get_crop(const obs_sceneitem_t *item, struct obs_sceneitem_crop *crop)</pre></p>
    <hr/><h3>obs_sceneitem_get_draw_transform(item, transform)</h3>
    <pre>
    Gets the transform matrix of the scene item used for drawing the
    source.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>transform : matrix4</p>
    <p><pre>void obs_sceneitem_get_draw_transform(const obs_sceneitem_t *item, struct matrix4 *transform)</pre></p>
    <hr/><h3>obs_sceneitem_get_group(item, param2)</h3>
    <pre>
    Returns the parent group of a scene item.
    
    :param item: Scene item to get the group of
    :return:     The parent group of the scene item, or *NULL* if not in
                 a group
    
    </pre>
    <p>item : obs_scene</p>
    <p>param2 : obs_scene_item</p>
    <p>Return : obs_scene_item</p>
    <p><pre>obs_sceneitem_t *obs_sceneitem_get_group(obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_get_id(item)</h3>
    <pre>
    :return: The unique numeric identifier of the scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>Return : number</p>
    <p><pre>int64_t obs_sceneitem_get_id(const obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_get_info(item, info)</h3>
    <pre>
    Sets/gets the transform information of the scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>info : obs_transform_info</p>
    <p><pre>void obs_sceneitem_get_info(const obs_sceneitem_t *item, struct obs_transform_info *info)</pre></p>
    <hr/><h3>obs_sceneitem_get_pos(item, pos)</h3>
    <pre>
    Sets/gets the position of a scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>pos : vec2</p>
    <p><pre>void obs_sceneitem_get_pos(const obs_sceneitem_t *item, struct vec2 *pos)</pre></p>
    <hr/><h3>obs_sceneitem_get_private_settings(item)</h3>
    <pre>
    :return: An incremented reference to the private settings of the
             scene item.  Allows the front-end to set custom information
             which is saved with the scene item
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_sceneitem_get_private_settings(obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_get_rot(item)</h3>
    <pre>
    Sets/gets the rotation of a scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>Return : number</p>
    <p><pre>float obs_sceneitem_get_rot(const obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_get_scale(item, scale)</h3>
    <pre>
    Sets/gets the scaling of the scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>scale : vec2</p>
    <p><pre>void obs_sceneitem_get_scale(const obs_sceneitem_t *item, struct vec2 *scale)</pre></p>
    <hr/><h3>obs_sceneitem_get_scale_filter(item)</h3>
    <pre>
    Sets/gets the scale filter used for the scene item.
    
    :param filter: | Can be one of the following values:
                   | OBS_SCALE_DISABLE
                   | OBS_SCALE_POINT
                   | OBS_SCALE_BICUBIC
                   | OBS_SCALE_BILINEAR
                   | OBS_SCALE_LANCZOS
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>Return : number</p>
    <p><pre>enum obs_scale_type obs_sceneitem_get_scale_filter( obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_get_scene(item)</h3>
    <pre>
    :return: The scene associated with the scene item.  Does not
             increment the reference
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>Return : obs_scene</p>
    <p><pre>obs_scene_t *obs_sceneitem_get_scene(const obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_get_source(item)</h3>
    <pre>
    :return: The source associated with the scene item.  Does not
             increment the reference
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>Return : obs_source</p>
    <p><pre>obs_source_t *obs_sceneitem_get_source(const obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_group_add_item(group, item)</h3>
    <pre>
    Adds a scene item to a group.
    
    </pre>
    <p>group : obs_scene_item</p>
    <p>item : obs_scene_item</p>
    <p><pre>void obs_sceneitem_group_add_item(obs_sceneitem_t *group, obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_group_enum_items(group, callback, param)</h3>
    <pre>
    Enumerates scene items within a group.
    
    </pre>
    <p>group : obs_scene_item</p>
    <p>callback : f_p_struct_obs_scene_p_struct_obs_scene_item_p_void__bool</p>
    <p>param : ref_void*</p>
    <p><pre>void obs_sceneitem_group_enum_items(obs_sceneitem_t *group, bool (*callback)(obs_scene_t*, obs_sceneitem_t*, void*), void *param)</pre></p>
    <hr/><h3>obs_sceneitem_group_get_scene(group)</h3>
    <pre>
    :param group: Group scene item
    :return:      Scene of the group, or *NULL* if not a group
    
    </pre>
    <p>group : obs_scene_item</p>
    <p>Return : obs_scene</p>
    <p><pre>obs_scene_t *obs_sceneitem_group_get_scene(const obs_sceneitem_t *group)</pre></p>
    <hr/><h3>obs_sceneitem_group_remove_item(item, param2)</h3>
    <pre>
    Removes a scene item from a group.  The item will be placed before
    the group in the main scene.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>param2 : obs_scene_item</p>
    <p><pre>void obs_sceneitem_group_remove_item(obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_group_ungroup(group)</h3>
    <pre>
    Ungroups the specified group.  Scene items within the group will be
    placed where the group was.  Does not signal the scene with the
    *refresh* signal.
    
    </pre>
    <p>group : obs_scene_item</p>
    <p><pre>void obs_sceneitem_group_ungroup(obs_sceneitem_t *group)</pre></p>
    <hr/><h3>obs_sceneitem_group_ungroup2(group, signal)</h3>
    <pre>
    Ungroups the specified group.  Scene items within the group will be
    placed where the group was.
    
    :param group: Group scene item
    :param signal: If *true*, signals the scene with the *refresh*
                   signal
    
    </pre>
    <p>group : obs_scene_item</p>
    <p>signal : boolean</p>
    <p><pre>void obs_sceneitem_group_ungroup2(obs_sceneitem_t *group, bool signal)</pre></p>
    <hr/><h3>obs_sceneitem_is_group(item)</h3>
    <pre>
    :param item: Scene item
    :return:     *true* if scene item is a group, *false* otherwise
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_sceneitem_is_group(obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_locked(item)</h3>
    <pre>
    Sets/gets the locked/unlocked state of the scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_sceneitem_locked(const obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_release(item)</h3>
    <pre>
    Adds/releases a reference to a scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p><pre>void obs_sceneitem_release(obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_remove(item)</h3>
    <pre>
    Removes the scene item from the scene.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p><pre>void obs_sceneitem_remove(obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_sceneitem_select(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_scene_item</p>
    <p>param2 : boolean</p>
    <hr/><h3>obs_sceneitem_selected(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_scene_item</p>
    <hr/><h3>obs_sceneitem_set_alignment(item, alignment)</h3>
    <pre>
    Sets/gets the alignment of the scene item relative to its position.
    
    :param alignment: | Can be any bitwise OR combination of:
                      | OBS_ALIGN_CENTER
                      | OBS_ALIGN_LEFT
                      | OBS_ALIGN_RIGHT
                      | OBS_ALIGN_TOP
                      | OBS_ALIGN_BOTTOM
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>alignment : number</p>
    <p><pre>void obs_sceneitem_set_alignment(obs_sceneitem_t *item, uint32_t alignment)</pre></p>
    <hr/><h3>obs_sceneitem_set_bounds(item, bounds)</h3>
    <pre>
    Sets/gets the bounding box width/height of the scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>bounds : vec2</p>
    <p><pre>void obs_sceneitem_set_bounds(obs_sceneitem_t *item, const struct vec2 *bounds)</pre></p>
    <hr/><h3>obs_sceneitem_set_bounds_alignment(item, alignment)</h3>
    <pre>
    Sets/gets the alignment of the source within the bounding box.
    
    :param alignment: | Can be any bitwise OR combination of:
                      | OBS_ALIGN_CENTER
                      | OBS_ALIGN_LEFT
                      | OBS_ALIGN_RIGHT
                      | OBS_ALIGN_TOP
                      | OBS_ALIGN_BOTTOM
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>alignment : number</p>
    <p><pre>void obs_sceneitem_set_bounds_alignment(obs_sceneitem_t *item, uint32_t alignment)</pre></p>
    <hr/><h3>obs_sceneitem_set_bounds_type(item, type)</h3>
    <pre>
    Sets/gets the bounding box type of a scene item.  Bounding boxes are
    used to stretch/position the source relative to a specific bounding
    box of a specific size.
    
    :param type: | Can be one of the following values:
                 | OBS_BOUNDS_NONE            - No bounding box
                 | OBS_BOUNDS_STRETCH         - Stretch to the bounding box without preserving aspect ratio
                 | OBS_BOUNDS_SCALE_INNER     - Scales with aspect ratio to inner bounding box rectangle
                 | OBS_BOUNDS_SCALE_OUTER     - Scales with aspect ratio to outer bounding box rectangle
                 | OBS_BOUNDS_SCALE_TO_WIDTH  - Scales with aspect ratio to the bounding box width
                 | OBS_BOUNDS_SCALE_TO_HEIGHT - Scales with aspect ratio to the bounding box height
                 | OBS_BOUNDS_MAX_ONLY        - Scales with aspect ratio, but only to the size of the source maximum
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>type : number</p>
    <p><pre>void obs_sceneitem_set_bounds_type(obs_sceneitem_t *item, enum obs_bounds_type type)</pre></p>
    <hr/><h3>obs_sceneitem_set_crop(item, crop)</h3>
    <pre>
    Sets/gets the cropping of the scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>crop : obs_sceneitem_crop</p>
    <p><pre>void obs_sceneitem_set_crop(obs_sceneitem_t *item, const struct obs_sceneitem_crop *crop)</pre></p>
    <hr/><h3>obs_sceneitem_set_info(item, info)</h3>
    <pre>
    Sets/gets the transform information of the scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>info : obs_transform_info</p>
    <p><pre>void obs_sceneitem_set_info(obs_sceneitem_t *item, const struct obs_transform_info *info)</pre></p>
    <hr/><h3>obs_sceneitem_set_locked(item, locked)</h3>
    <pre>
    Sets/gets the locked/unlocked state of the scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>locked : boolean</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_sceneitem_set_locked(obs_sceneitem_t *item, bool locked)</pre></p>
    <hr/><h3>obs_sceneitem_set_order(item, movement)</h3>
    <pre>
    Changes the scene item's order relative to the other scene items
    within the scene.
    
    :param movement: | Can be one of the following:
                     | OBS_ORDER_MOVE_UP
                     | OBS_ORDER_MOVE_DOWN
                     | OBS_ORDER_MOVE_TOP
                     | OBS_ORDER_MOVE_BOTTOM
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>movement : number</p>
    <p><pre>void obs_sceneitem_set_order(obs_sceneitem_t *item, enum obs_order_movement movement)</pre></p>
    <hr/><h3>obs_sceneitem_set_order_position(item, position)</h3>
    <pre>
    Changes the scene item's order index.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>position : number</p>
    <p><pre>void obs_sceneitem_set_order_position(obs_sceneitem_t *item, int position)</pre></p>
    <hr/><h3>obs_sceneitem_set_pos(item, pos)</h3>
    <pre>
    Sets/gets the position of a scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>pos : vec2</p>
    <p><pre>void obs_sceneitem_set_pos(obs_sceneitem_t *item, const struct vec2 *pos)</pre></p>
    <hr/><h3>obs_sceneitem_set_rot(item, rot_deg)</h3>
    <pre>
    Sets/gets the rotation of a scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>rot_deg : number</p>
    <p><pre>void obs_sceneitem_set_rot(obs_sceneitem_t *item, float rot_deg)</pre></p>
    <hr/><h3>obs_sceneitem_set_scale(item, scale)</h3>
    <pre>
    Sets/gets the scaling of the scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>scale : vec2</p>
    <p><pre>void obs_sceneitem_set_scale(obs_sceneitem_t *item, const struct vec2 *scale)</pre></p>
    <hr/><h3>obs_sceneitem_set_scale_filter(item, filter)</h3>
    <pre>
    Sets/gets the scale filter used for the scene item.
    
    :param filter: | Can be one of the following values:
                   | OBS_SCALE_DISABLE
                   | OBS_SCALE_POINT
                   | OBS_SCALE_BICUBIC
                   | OBS_SCALE_BILINEAR
                   | OBS_SCALE_LANCZOS
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>filter : number</p>
    <p><pre>void obs_sceneitem_set_scale_filter(obs_sceneitem_t *item, enum obs_scale_type filter)</pre></p>
    <hr/><h3>obs_sceneitem_set_visible(item, visible)</h3>
    <pre>
    Sets/gets the visibility state of the scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>visible : boolean</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_sceneitem_set_visible(obs_sceneitem_t *item, bool visible)</pre></p>
    <hr/><h3>obs_sceneitem_visible(item)</h3>
    <pre>
    Sets/gets the visibility state of the scene item.
    
    </pre>
    <p>item : obs_scene_item</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_sceneitem_visible(const obs_sceneitem_t *item)</pre></p>
    <hr/><h3>obs_service_addref(service)</h3>
    <pre>
    Adds/releases a reference to a service.  When the last reference is
    released, the service is destroyed.
    
    </pre>
    <p>service : obs_service</p>
    <p><pre>void obs_service_addref(obs_service_t *service)</pre></p>
    <hr/><h3>obs_service_apply_encoder_settings(service, video_encoder_settings, audio_encoder_settings)</h3>
    <pre>
    Applies service-specific video encoder settings.
    
    :param  video_encoder_settings: Video encoder settings.  Can be *NULL*
    :param  audio_encoder_settings: Audio encoder settings.  Can be *NULL*
    
    .. ---------------------------------------------------------------------------
    
    .. _libobs/obs-service.h: https://github.com/jp9000/obs-studio/blob/master/libobs/obs-service.h
    </pre>
    <p>service : obs_service</p>
    <p>video_encoder_settings : obs_data</p>
    <p>audio_encoder_settings : obs_data</p>
    <p><pre>void obs_service_apply_encoder_settings(obs_service_t *service, obs_data_t *video_encoder_settings, obs_data_t *audio_encoder_settings)</pre></p>
    <hr/><h3>obs_service_create(id, name, settings, hotkey_data)</h3>
    <pre>
    Creates a service with the specified settings.
    
    The "service" context is used for encoding video/audio data.  Use
    obs_service_release to release it.
    
    :param   id:             The service type string identifier
    :param   name:           The desired name of the service.  If this is
                             not unique, it will be made to be unique
    :param   settings:       The settings for the service, or *NULL* if
                             none
    :param   hotkey_data:    Saved hotkey data for the service, or *NULL*
                             if none
    :return:                 A reference to the newly created service, or
                             *NULL* if failed
    
    </pre>
    <p>id : string</p>
    <p>name : string</p>
    <p>settings : obs_data</p>
    <p>hotkey_data : obs_data</p>
    <p>Return : obs_service</p>
    <p><pre>obs_service_t *obs_service_create(const char *id, const char *name, obs_data_t *settings, obs_data_t *hotkey_data)</pre></p>
    <hr/><h3>obs_service_create_private(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <p>param2 : string</p>
    <p>param3 : obs_data</p>
    <hr/><h3>obs_service_defaults(id)</h3>
    <pre>
    :return: An incremented reference to the service's default settings
    
    </pre>
    <p>id : string</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_service_defaults(const char *id)</pre></p>
    <hr/><h3>obs_service_get_display_name(id)</h3>
    <pre>
    Calls the :c:member:`obs_service_info.get_name` callback to get the
    translated display name of a service type.
    
    :param    id:            The service type string identifier
    :return:                 The translated display name of a service type
    
    </pre>
    <p>id : string</p>
    <p>Return : string</p>
    <p><pre>const char *obs_service_get_display_name(const char *id)</pre></p>
    <hr/><h3>obs_service_get_id(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_service</p>
    <hr/><h3>obs_service_get_key(service)</h3>
    <pre>
      :return: Stream key (if any) currently used for this service
    
    </pre>
    <p>service : obs_service</p>
    <p>Return : string</p>
    <p><pre>const char *obs_service_get_key(const obs_service_t *service)</pre></p>
    <hr/><h3>obs_service_get_name(service)</h3>
    <pre>
    :return: The name of the service
    
    </pre>
    <p>service : obs_service</p>
    <p>Return : string</p>
    <p><pre>const char *obs_service_get_name(const obs_service_t *service)</pre></p>
    <hr/><h3>obs_service_get_output_type(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_service</p>
    <hr/><h3>obs_service_get_password(service)</h3>
    <pre>
    :return: Password (if any) currently used for this service
    
    </pre>
    <p>service : obs_service</p>
    <p>Return : string</p>
    <p><pre>const char *obs_service_get_password(const obs_service_t *service)</pre></p>
    <hr/><h3>obs_service_get_ref(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_service</p>
    <hr/><h3>obs_service_get_settings(service)</h3>
    <pre>
    :return: An incremented reference to the service's settings
    
    </pre>
    <p>service : obs_service</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_service_get_settings(const obs_service_t *service)</pre></p>
    <hr/><h3>obs_service_get_type(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_service</p>
    <hr/><h3>obs_service_get_type_data(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_service</p>
    <hr/><h3>obs_service_get_url(service)</h3>
    <pre>
      :return: The URL currently used for this service
    
    </pre>
    <p>service : obs_service</p>
    <p>Return : string</p>
    <p><pre>const char *obs_service_get_url(const obs_service_t *service)</pre></p>
    <hr/><h3>obs_service_get_username(service)</h3>
    <pre>
    :return: User name (if any) currently used for this service
    
    </pre>
    <p>service : obs_service</p>
    <p>Return : string</p>
    <p><pre>const char *obs_service_get_username(const obs_service_t *service)</pre></p>
    <hr/><h3>obs_service_get_weak_service(service)</h3>
    <pre>
    These functions are used to get a weak reference from a strong service
    reference, or a strong service reference from a weak reference.  If
    the service is destroyed, *obs_weak_service_get_service* will return
    *NULL*.
    
    </pre>
    <p>service : obs_service</p>
    <p>Return : obs_weak_service</p>
    <p><pre>obs_weak_service_t *obs_service_get_weak_service(obs_service_t *service)</pre></p>
    <hr/><h3>obs_service_properties(service)</h3>
    <pre>
    Use these functions to get the properties of a service or service
    type.  Properties are optionally used (if desired) to automatically
    generate user interface widgets to allow users to update settings.
    
    :return: The properties list for a specific existing service.  Free
             with :c:func:`obs_properties_destroy()`
    
    </pre>
    <p>service : obs_service</p>
    <p>Return : obs_properties</p>
    <p><pre>obs_properties_t *obs_service_properties(const obs_service_t *service)</pre></p>
    <hr/><h3>obs_service_release(service)</h3>
    <pre>
    Adds/releases a reference to a service.  When the last reference is
    released, the service is destroyed.
    
    </pre>
    <p>service : obs_service</p>
    <p><pre>void obs_service_release(obs_service_t *service)</pre></p>
    <hr/><h3>obs_service_update(service, settings)</h3>
    <pre>
    Updates the settings for this service context.
    
    </pre>
    <p>service : obs_service</p>
    <p>settings : obs_data</p>
    <p><pre>void obs_service_update(obs_service_t *service, obs_data_t *settings)</pre></p>
    <hr/><h3>obs_set_audio_monitoring_device(name, id)</h3>
    <pre>
    Sets the current audio device for audio monitoring.
    
    </pre>
    <p>name : string</p>
    <p>id : string</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_set_audio_monitoring_device(const char *name, const char *id)</pre></p>
    <hr/><h3>obs_set_cmdline_args(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : p_char</p>
    <hr/><h3>obs_set_locale(locale)</h3>
    <pre>
    Sets a new locale to use for modules.  This will call
    obs_module_set_locale for each module with the new locale.
    
    :param  locale: The locale to use for modules
    
    </pre>
    <p>locale : string</p>
    <p><pre>void obs_set_locale(const char *locale)</pre></p>
    <hr/><h3>obs_set_master_volume(volume)</h3>
    <pre>
    Sets the master user volume.
    
    </pre>
    <p>volume : number</p>
    <p><pre>void obs_set_master_volume(float volume)</pre></p>
    <hr/><h3>obs_set_output_source(channel, source)</h3>
    <pre>
    Sets the primary output source for a channel.
    
    </pre>
    <p>channel : number</p>
    <p>source : obs_source</p>
    <p><pre>void obs_set_output_source(uint32_t channel, obs_source_t *source)</pre></p>
    <hr/><h3>obs_set_private_data(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_data</p>
    <hr/><h3>obs_set_ui_task_handler(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : f_p_f_p_void__void_p_void_bool__void</p>
    <hr/><h3>obs_shutdown()</h3>
    <pre>
    Releases all data associated with OBS and terminates the OBS context.
    
    </pre>
    <p><pre>void obs_shutdown(void)</pre></p>
    <hr/><h3>obs_source_active(source)</h3>
    <pre>
    :return: *true* if active, *false* if not.  A source is only
             considered active if it's being shown on the final mix
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_source_active(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_add_active_child(parent, child)</h3>
    <pre>
    Adds an active child source.  Must be called by parent sources on child
    sources when the child is added and active.  This ensures that the source is
    properly activated if the parent is active.
    
    :return: *true* if source can be added, *false* if it causes recursion
    
    </pre>
    <p>parent : obs_source</p>
    <p>child : obs_source</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_source_add_active_child(obs_source_t *parent, obs_source_t *child)</pre></p>
    <hr/><h3>obs_source_add_audio_capture_callback(source, callback, param)</h3>
    <pre>
    Adds/removes an audio capture callback for a source.  This allows the
    ability to get the raw audio data of a source as it comes in.
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    typedef void (*obs_source_audio_capture_t)(void *param, obs_source_t *source,
                    const struct audio_data *audio_data, bool muted);
    
    </pre>
    <p>source : obs_source</p>
    <p>callback : f_p_void_p_struct_obs_source_p_q_const__struct_audio_data_bool__void</p>
    <p>param : ref_void*</p>
    <p><pre>void obs_source_add_audio_capture_callback(obs_source_t *source, obs_source_audio_capture_t callback, void *param)</pre></p>
    <hr/><h3>obs_source_addref(source)</h3>
    <pre>
    Adds/releases a reference to a source.  When the last reference is
    released, the source is destroyed.
    
    </pre>
    <p>source : obs_source</p>
    <p><pre>void obs_source_addref(obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_async_decoupled(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_async_unbuffered(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_audio_active(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_audio_pending(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_configurable(source)</h3>
    <pre>
    :return: *true* if the the source has custom properties, *false*
             otherwise
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_source_configurable(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_copy_filters(dst, src)</h3>
    <pre>
    Copies filters from the source to the destination.  If filters by the
    same name already exist in the destination source, the newer filters
    will be given unique names.
    
    </pre>
    <p>dst : obs_source</p>
    <p>src : obs_source</p>
    <p><pre>void obs_source_copy_filters(obs_source_t *dst, obs_source_t *src)</pre></p>
    <hr/><h3>obs_source_create(id, name, settings, hotkey_data)</h3>
    <pre>
    Creates a source of the specified type with the specified settings.
    
    The "source" context is used for anything related to presenting
    or modifying video/audio.  Use obs_source_release to release it.
    
    :param   id:             The source type string identifier
    :param   name:           The desired name of the source.  If this is
                             not unique, it will be made to be unique
    :param   settings:       The settings for the source, or *NULL* if
                             none
    :param   hotkey_data:    Saved hotkey data for the source, or *NULL*
                             if none
    :return:                 A reference to the newly created source, or
                             *NULL* if failed
    
    </pre>
    <p>id : string</p>
    <p>name : string</p>
    <p>settings : obs_data</p>
    <p>hotkey_data : obs_data</p>
    <p>Return : obs_source</p>
    <p><pre>obs_source_t *obs_source_create(const char *id, const char *name, obs_data_t *settings, obs_data_t *hotkey_data)</pre></p>
    <hr/><h3>obs_source_create_private(id, name, settings)</h3>
    <pre>
    Creates a 'private' source which is not enumerated by
    :c:func:`obs_enum_sources()`, and is not saved by
    :c:func:`obs_save_sources()`.
    
    Author's Note: The existence of this function is a result of design
    flaw: the front-end should control saving/loading of sources, and
    functions like :c:func:`obs_enum_sources()` and
    :c:func:`obs_save_sources()` should not exist in the back-end.
    
    :param   id:             The source type string identifier
    :param   name:           The desired name of the source.  For private
                             sources, this does not have to be unique,
                             and can additionally be *NULL* if desired
    :param   settings:       The settings for the source, or *NULL* if
                             none
    :return:                 A reference to the newly created source, or
                             *NULL* if failed
    
    </pre>
    <p>id : string</p>
    <p>name : string</p>
    <p>settings : obs_data</p>
    <p>Return : obs_source</p>
    <p><pre>obs_source_t *obs_source_create_private(const char *id, const char *name, obs_data_t *settings)</pre></p>
    <hr/><h3>obs_source_dec_active(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_dec_showing(source)</h3>
    <pre>
    Increments/decrements a source's "showing" state.  Typically used
    when drawing a source on a display manually.
    
    </pre>
    <p>source : obs_source</p>
    <p><pre>void obs_source_dec_showing(obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_default_render(source)</h3>
    <pre>
    Can be used by filters to directly render a non-async parent source
    without any filter processing.
    
    </pre>
    <p>source : obs_source</p>
    <p><pre>void obs_source_default_render(obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_draw(image, x, y, cx, cy, flip)</h3>
    <pre>
    Helper function to draw sprites for a source (synchronous video).
    
    :param  image:  The sprite texture to draw.  Assigns to the 'image' variable
                    of the current effect.
    :param  x:      X position of the sprite.
    :param  y:      Y position of the sprite.
    :param  cx:     Width of the sprite.  If 0, uses the texture width.
    :param  cy:     Height of the sprite.  If 0, uses the texture height.
    :param  flip:   Specifies whether to flip the image vertically.
    
    </pre>
    <p>image : gs_texture</p>
    <p>x : number</p>
    <p>y : number</p>
    <p>cx : number</p>
    <p>cy : number</p>
    <p>flip : boolean</p>
    <p><pre>void obs_source_draw(gs_texture_t *image, int x, int y, uint32_t cx, uint32_t cy, bool flip)</pre></p>
    <hr/><h3>obs_source_draw_set_color_matrix(color_matrix, color_range_min, color_range_max)</h3>
    <pre>
    Helper function to set the color matrix information when drawing the
    source.
    
    :param  color_matrix:    The color matrix.  Assigns to the 'color_matrix'
                             effect variable.
    :param  color_range_min: The minimum color range.  Assigns to the
                             'color_range_min' effect variable.  If NULL,
                             {0.0f, 0.0f, 0.0f} is used.
    :param  color_range_max: The maximum color range.  Assigns to the
                             'color_range_max' effect variable.  If NULL,
                             {1.0f, 1.0f, 1.0f} is used.
    
    </pre>
    <p>color_matrix : matrix4</p>
    <p>color_range_min : vec3</p>
    <p>color_range_max : vec3</p>
    <p><pre>void obs_source_draw_set_color_matrix(const struct matrix4 *color_matrix, const struct vec3 *color_range_min, const struct vec3 *color_range_max)</pre></p>
    <hr/><h3>obs_source_duplicate(source, desired_name, create_private)</h3>
    <pre>
    Duplicates a source.  If the source has the
    OBS_SOURCE_DO_NOT_DUPLICATE output flag set, this only returns a
    new reference to the same source.
    
    :param source:         The source to duplicate
    :param desired_name:   The desired name of the new source.  If this is
                           not a private source and the name is not unique,
                           it will be made to be unique
    :param create_private: If *true*, the new source will be a private
                           source if fully duplicated
    :return:               A new source reference
    
    </pre>
    <p>source : obs_source</p>
    <p>desired_name : string</p>
    <p>create_private : boolean</p>
    <p>Return : obs_source</p>
    <p><pre>obs_source_t *obs_source_duplicate(obs_source_t *source, const char *desired_name, bool create_private)</pre></p>
    <hr/><h3>obs_source_enable_push_to_mute(source, enabled)</h3>
    <pre>
    Sets/gets whether push-to-mute is enabled.
    
    </pre>
    <p>source : obs_source</p>
    <p>enabled : boolean</p>
    <p><pre>void obs_source_enable_push_to_mute(obs_source_t *source, bool enabled)</pre></p>
    <hr/><h3>obs_source_enable_push_to_talk(source, enabled)</h3>
    <pre>
    Sets/gets whether push-to-talk is enabled.
    
    </pre>
    <p>source : obs_source</p>
    <p>enabled : boolean</p>
    <p><pre>void obs_source_enable_push_to_talk(obs_source_t *source, bool enabled)</pre></p>
    <hr/><h3>obs_source_enabled(source)</h3>
    <pre>
    Enables/disables a source, or returns the enabled state.
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_source_enabled(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_enum_active_sources(source, enum_callback, param)</h3>
    <pre>
    Enumerates active child sources or source tree used by this source.
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    typedef void (*obs_source_enum_proc_t)(obs_source_t *parent,
                    obs_source_t *child, void *param);
    
    </pre>
    <p>source : obs_source</p>
    <p>enum_callback : f_p_struct_obs_source_p_struct_obs_source_p_void__void</p>
    <p>param : ref_void*</p>
    <p><pre>void obs_source_enum_active_sources(obs_source_t *source, obs_source_enum_proc_t enum_callback, void *param)</pre></p>
    <hr/><h3>obs_source_enum_active_tree(source, enum_callback, param)</h3>
    <pre>
    Enumerates active child sources or source tree used by this source.
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    typedef void (*obs_source_enum_proc_t)(obs_source_t *parent,
                    obs_source_t *child, void *param);
    
    </pre>
    <p>source : obs_source</p>
    <p>enum_callback : f_p_struct_obs_source_p_struct_obs_source_p_void__void</p>
    <p>param : ref_void*</p>
    <p><pre>void obs_source_enum_active_tree(obs_source_t *source, obs_source_enum_proc_t enum_callback, void *param)</pre></p>
    <hr/><h3>obs_source_enum_filters(source, callback, param)</h3>
    <pre>
    Enumerates active filters on a source.
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    typedef void (*obs_source_enum_proc_t)(obs_source_t *parent,
                    obs_source_t *child, void *param);
    
    </pre>
    <p>source : obs_source_t*</p>
    <p>callback : obs_source_enum_proc_t</p>
    <p>param : void*</p>
    <p><pre>void obs_source_enum_filters(obs_source_t *source, obs_source_enum_proc_t callback, void *param)</pre></p>
    <hr/><h3>obs_source_filter_add(source, filter)</h3>
    <pre>
    Adds/removes a filter to/from a source.
    
    </pre>
    <p>source : obs_source</p>
    <p>filter : obs_source</p>
    <p><pre>void obs_source_filter_add(obs_source_t *source, obs_source_t *filter)</pre></p>
    <hr/><h3>obs_source_filter_remove(source, filter)</h3>
    <pre>
    Adds/removes a filter to/from a source.
    
    </pre>
    <p>source : obs_source</p>
    <p>filter : obs_source</p>
    <p><pre>void obs_source_filter_remove(obs_source_t *source, obs_source_t *filter)</pre></p>
    <hr/><h3>obs_source_filter_set_order(source, filter, movement)</h3>
    <pre>
    Modifies the order of a specific filter.
    
    :param movement: | Can be one of the following:
                     | OBS_ORDER_MOVE_UP
                     | OBS_ORDER_MOVE_DOWN
                     | OBS_ORDER_MOVE_TOP
                     | OBS_ORDER_MOVE_BOTTOM
    
    </pre>
    <p>source : obs_source</p>
    <p>filter : obs_source</p>
    <p>movement : number</p>
    <p><pre>void obs_source_filter_set_order(obs_source_t *source, obs_source_t *filter, enum obs_order_movement movement)</pre></p>
    <hr/><h3>obs_source_frame_copy(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source_frame</p>
    <p>param2 : obs_source_frame</p>
    <hr/><h3>obs_source_frame_create(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : number</p>
    <p>param2 : number</p>
    <p>param3 : number</p>
    <hr/><h3>obs_source_frame_destroy(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source_frame</p>
    <hr/><h3>obs_source_frame_free(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source_frame</p>
    <hr/><h3>obs_source_frame_init(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source_frame</p>
    <p>param2 : number</p>
    <p>param3 : number</p>
    <p>param4 : number</p>
    <hr/><h3>obs_source_get_audio_mix(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : obs_source_audio_mix</p>
    <hr/><h3>obs_source_get_audio_mixers(source)</h3>
    <pre>
    Sets/gets the audio mixer channels that a source outputs to
    (depending on what bits are set).  Audio mixers allow filtering
    specific using multiple audio encoders to mix different sources
    together depending on what mixer channel they're set to.
    
    For example, to output to mixer 1 and 3, you would perform a bitwise
    OR on bits 0 and 2:  (1<<0) | (1<<2), or 0x5.
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_source_get_audio_mixers(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_audio_timestamp(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_get_balance_value(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_get_base_height(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_get_base_width(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_get_deinterlace_field_order(source)</h3>
    <pre>
    Sets/gets the deinterlace field order.
    
    :param order: | OBS_DEINTERLACE_FIELD_ORDER_TOP - Start from top
                  | OBS_DEINTERLACE_FIELD_ORDER_BOTTOM - Start from bottom
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : number</p>
    <p><pre>enum obs_deinterlace_field_order obs_source_get_deinterlace_field_order(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_deinterlace_mode(source)</h3>
    <pre>
    Sets/gets the deinterlace mode.
    
    :param mode:   | OBS_DEINTERLACE_MODE_DISABLE    - Disables deinterlacing
                   | OBS_DEINTERLACE_MODE_DISCARD    - Discard
                   | OBS_DEINTERLACE_MODE_RETRO      - Retro
                   | OBS_DEINTERLACE_MODE_BLEND      - Blend
                   | OBS_DEINTERLACE_MODE_BLEND_2X   - Blend 2x
                   | OBS_DEINTERLACE_MODE_LINEAR     - Linear
                   | OBS_DEINTERLACE_MODE_LINEAR_2X  - Linear 2x
                   | OBS_DEINTERLACE_MODE_YADIF      - Yadif
                   | OBS_DEINTERLACE_MODE_YADIF_2X   - Yadif 2x
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : number</p>
    <p><pre>enum obs_deinterlace_mode obs_source_get_deinterlace_mode(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_display_name(id)</h3>
    <pre>
    Calls the :c:member:`obs_source_info.get_name` callback to get the
    translated display name of a source type.
    
    :param    id:            The source type string identifier
    :return:                 The translated display name of a source type
    
    </pre>
    <p>id : string</p>
    <p>Return : string</p>
    <p><pre>const char *obs_source_get_display_name(const char *id)</pre></p>
    <hr/><h3>obs_source_get_filter_by_name(source, name)</h3>
    <pre>
    :return: The desired filter, or *NULL* if not found.  The reference
             of the filter is incremented
    
    </pre>
    <p>source : obs_source</p>
    <p>name : string</p>
    <p>Return : obs_source</p>
    <p><pre>obs_source_t *obs_source_get_filter_by_name(obs_source_t *source, const char *name)</pre></p>
    <hr/><h3>obs_source_get_flags(source)</h3>
    <pre>
    :param flags: OBS_SOURCE_FLAG_FORCE_MONO Forces audio to mono
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_source_get_flags(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_frame(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_get_height(source)</h3>
    <pre>
    Calls the :c:member:`obs_source_info.get_width` or
    :c:member:`obs_source_info.get_height` of the source to get its width
    and/or height.
    
    Author's Note: These functions should be consolidated in to a single
    function/callback rather than having a function for both width and
    height.
    
    :return: The width or height of the source
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_source_get_height(obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_icon_type(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <hr/><h3>obs_source_get_id(source)</h3>
    <pre>
    :return: The source's type identifier string
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : string</p>
    <p><pre>const char *obs_source_get_id(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_last_obs_version(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_get_monitoring_type(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_get_name(source)</h3>
    <pre>
    :return: The name of the source
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : string</p>
    <p><pre>const char *obs_source_get_name(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_output_flags(source)</h3>
    <pre>
    :return: Capability flags of a source
    
    Author's Note: "Output flags" is poor wording in retrospect; this
    should have been named "Capability flags", and the OBS_SOURCE_*
    macros should really be OBS_SOURCE_CAP_* macros instead.
    
    See :c:member:`obs_source_info.output_flags` for more information.
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_source_get_output_flags(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_private_settings(item)</h3>
    <pre>
    Gets private front-end settings data.  This data is saved/loaded
    automatically.  Returns an incremented reference.
    
    </pre>
    <p>item : obs_source</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_source_get_private_settings(obs_source_t *item)</pre></p>
    <hr/><h3>obs_source_get_proc_handler(source)</h3>
    <pre>
    :return: The procedure handler for a source
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : proc_handler</p>
    <p><pre>proc_handler_t *obs_source_get_proc_handler(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_push_to_mute_delay(source)</h3>
    <pre>
    Sets/gets the push-to-mute delay.
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : number</p>
    <p><pre>uint64_t obs_source_get_push_to_mute_delay(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_push_to_talk_delay(source)</h3>
    <pre>
    Sets/gets the push-to-talk delay.
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : number</p>
    <p><pre>uint64_t obs_source_get_push_to_talk_delay(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_ref(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_get_settings(source)</h3>
    <pre>
    :return: The settings string for a source.  The reference counter of the
             returned settings data is incremented, so
             :c:func:`obs_data_release()` must be called when the
             settings are no longer used
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : obs_data</p>
    <p><pre>obs_data_t *obs_source_get_settings(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_signal_handler(source)</h3>
    <pre>
    :return: The source's signal handler
    
    See the :ref:`source_signal_handler_reference` for more information
    on signals that are available for sources.
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : signal_handler</p>
    <p><pre>signal_handler_t *obs_source_get_signal_handler(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_speaker_layout(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_get_sync_offset(source)</h3>
    <pre>
    Sets/gets the audio sync offset (in nanoseconds) for a source.
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : number</p>
    <p><pre>int64_t obs_source_get_sync_offset(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_type(source)</h3>
    <pre>
    :return: | OBS_SOURCE_TYPE_INPUT for inputs
             | OBS_SOURCE_TYPE_FILTER for filters
             | OBS_SOURCE_TYPE_TRANSITION for transitions
             | OBS_SOURCE_TYPE_SCENE for scenes
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : number</p>
    <p><pre>enum obs_source_type obs_source_get_type(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_type_data(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_get_unversioned_id(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_get_volume(source)</h3>
    <pre>
    Sets/gets the user volume for a source that has audio output.
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : number</p>
    <p><pre>float obs_source_get_volume(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_weak_source(source)</h3>
    <pre>
    These functions are used to get a weak reference from a strong source
    reference, or a strong source reference from a weak reference.  If
    the source is destroyed, *obs_weak_source_get_source* will return
    *NULL*.
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : obs_weak_source</p>
    <p><pre>obs_weak_source_t *obs_source_get_weak_source(obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_get_width(source)</h3>
    <pre>
    Calls the :c:member:`obs_source_info.get_width` or
    :c:member:`obs_source_info.get_height` of the source to get its width
    and/or height.
    
    Author's Note: These functions should be consolidated in to a single
    function/callback rather than having a function for both width and
    height.
    
    :return: The width or height of the source
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_source_get_width(obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_inc_active(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_inc_showing(source)</h3>
    <pre>
    Increments/decrements a source's "showing" state.  Typically used
    when drawing a source on a display manually.
    
    </pre>
    <p>source : obs_source</p>
    <p><pre>void obs_source_inc_showing(obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_is_group(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_load(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_media_ended(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_media_get_duration(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_media_get_state(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_media_get_time(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_media_next(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_media_play_pause(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : boolean</p>
    <hr/><h3>obs_source_media_previous(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_media_restart(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_media_set_time(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : number</p>
    <hr/><h3>obs_source_media_started(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_media_stop(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_muted(source)</h3>
    <pre>
    Sets/gets whether the source's audio is muted.
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_source_muted(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_output_audio(source, audio)</h3>
    <pre>
    Outputs audio data.
    
    </pre>
    <p>source : obs_source</p>
    <p>audio : obs_source_audio</p>
    <p><pre>void obs_source_output_audio(obs_source_t *source, const struct obs_source_audio *audio)</pre></p>
    <hr/><h3>obs_source_output_video(source, frame)</h3>
    <pre>
    Outputs asynchronous video data.  Set to NULL to deactivate the texture.
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    enum video_format {
            VIDEO_FORMAT_NONE,
    
            /* planar 420 format */
            VIDEO_FORMAT_I420, /* three-plane */
            VIDEO_FORMAT_NV12, /* two-plane, luma and packed chroma */
    
            /* packed 422 formats */
            VIDEO_FORMAT_YVYU,
            VIDEO_FORMAT_YUY2, /* YUYV */
            VIDEO_FORMAT_UYVY,
    
            /* packed uncompressed formats */
            VIDEO_FORMAT_RGBA,
            VIDEO_FORMAT_BGRA,
            VIDEO_FORMAT_BGRX,
            VIDEO_FORMAT_Y800, /* grayscale */
    
            /* planar 4:4:4 */
            VIDEO_FORMAT_I444,
    };
    
    struct obs_source_frame {
            uint8_t             *data[MAX_AV_PLANES];
            uint32_t            linesize[MAX_AV_PLANES];
            uint32_t            width;
            uint32_t            height;
            uint64_t            timestamp;
    
            enum video_format   format;
            float               color_matrix[16];
            bool                full_range;
            float               color_range_min[3];
            float               color_range_max[3];
            bool                flip;
    };
    
    </pre>
    <p>source : obs_source</p>
    <p>frame : obs_source_frame</p>
    <p><pre>void obs_source_output_video(obs_source_t *source, const struct obs_source_frame *frame)</pre></p>
    <hr/><h3>obs_source_output_video2(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : obs_source_frame2</p>
    <hr/><h3>obs_source_preload_video(source, frame)</h3>
    <pre>
    Preloads a video frame to ensure a frame is ready for playback as
    soon as video playback starts.
    
    </pre>
    <p>source : obs_source</p>
    <p>frame : obs_source_frame</p>
    <p><pre>void obs_source_preload_video(obs_source_t *source, const struct obs_source_frame *frame)</pre></p>
    <hr/><h3>obs_source_preload_video2(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : obs_source_frame2</p>
    <hr/><h3>obs_source_process_filter_begin(filter, format, allow_direct)</h3>
    <pre>
    Default RGB filter handler for generic effect filters.  Processes the
    filter chain and renders them to texture if needed, then the filter is
    drawn with.
    
    After calling this, set your parameters for the effect, then call
    obs_source_process_filter_end to draw the filter.
    
    :return: *true* if filtering should continue, *false* if the filter
             is bypassed for whatever reason
    
    </pre>
    <p>filter : obs_source</p>
    <p>format : number</p>
    <p>allow_direct : number</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_source_process_filter_begin(obs_source_t *filter, enum gs_color_format format, enum obs_allow_direct_render allow_direct)</pre></p>
    <hr/><h3>obs_source_process_filter_end(filter, effect, width, height)</h3>
    <pre>
    Draws the filter using the effect's "Draw" technique.
    
    Before calling this function, first call obs_source_process_filter_begin and
    then set the effect parameters, and then call this function to finalize the
    filter.
    
    </pre>
    <p>filter : obs_source</p>
    <p>effect : gs_effect</p>
    <p>width : number</p>
    <p>height : number</p>
    <p><pre>void obs_source_process_filter_end(obs_source_t *filter, gs_effect_t *effect, uint32_t width, uint32_t height)</pre></p>
    <hr/><h3>obs_source_process_filter_tech_end(filter, effect, width, height, tech_name)</h3>
    <pre>
    Draws the filter with a specific technique in the effect.
    
    Before calling this function, first call obs_source_process_filter_begin and
    then set the effect parameters, and then call this function to finalize the
    filter.
    
    </pre>
    <p>filter : obs_source</p>
    <p>effect : gs_effect</p>
    <p>width : number</p>
    <p>height : number</p>
    <p>tech_name : string</p>
    <p><pre>void obs_source_process_filter_tech_end(obs_source_t *filter, gs_effect_t *effect, uint32_t width, uint32_t height, const char *tech_name)</pre></p>
    <hr/><h3>obs_source_properties(source)</h3>
    <pre>
    Use these functions to get the properties of a source or source type.
    Properties are optionally used (if desired) to automatically generate
    user interface widgets to allow users to update settings.
    
    :return: The properties list for a specific existing source.  Free with
             :c:func:`obs_properties_destroy()`
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : obs_properties</p>
    <p><pre>obs_properties_t *obs_source_properties(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_push_to_mute_enabled(source)</h3>
    <pre>
    Sets/gets whether push-to-mute is enabled.
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_source_push_to_mute_enabled(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_push_to_talk_enabled(source)</h3>
    <pre>
    Sets/gets whether push-to-talk is enabled.
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_source_push_to_talk_enabled(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_release(source)</h3>
    <pre>
    Adds/releases a reference to a source.  When the last reference is
    released, the source is destroyed.
    
    </pre>
    <p>source : obs_source</p>
    <p><pre>void obs_source_release(obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_release_frame(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : obs_source_frame</p>
    <hr/><h3>obs_source_remove(source)</h3>
    <pre>
    Notifies all reference holders of the source (via
    :c:func:`obs_source_removed()`) that the source should be released.
    
    </pre>
    <p>source : obs_source</p>
    <p><pre>void obs_source_remove(obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_remove_active_child(parent, child)</h3>
    <pre>
    Removes an active child source.  Must be called by parent sources on child
    sources when the child is removed or inactive.  This ensures that the source
    is properly deactivated if the parent is no longer active.
    
    </pre>
    <p>parent : obs_source</p>
    <p>child : obs_source</p>
    <p><pre>void obs_source_remove_active_child(obs_source_t *parent, obs_source_t *child)</pre></p>
    <hr/><h3>obs_source_remove_audio_capture_callback(source, callback, param)</h3>
    <pre>
    Adds/removes an audio capture callback for a source.  This allows the
    ability to get the raw audio data of a source as it comes in.
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    typedef void (*obs_source_audio_capture_t)(void *param, obs_source_t *source,
                    const struct audio_data *audio_data, bool muted);
    
    </pre>
    <p>source : obs_source</p>
    <p>callback : f_p_void_p_struct_obs_source_p_q_const__struct_audio_data_bool__void</p>
    <p>param : ref_void*</p>
    <p><pre>void obs_source_remove_audio_capture_callback(obs_source_t *source, obs_source_audio_capture_t callback, void *param)</pre></p>
    <hr/><h3>obs_source_removed(source)</h3>
    <pre>
    :return: *true* if the source should be released
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_source_removed(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_save(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_source_send_focus(source, focus)</h3>
    <pre>
    Used for interacting with sources:  sends a got-focus or lost-focus
    event to a source.
    
    </pre>
    <p>source : obs_source</p>
    <p>focus : boolean</p>
    <p><pre>void obs_source_send_focus(obs_source_t *source, bool focus)</pre></p>
    <hr/><h3>obs_source_send_key_click(source, event, key_up)</h3>
    <pre>
    Used for interacting with sources:  sends a key up/down event to a
    source.
    
    </pre>
    <p>source : obs_source</p>
    <p>event : obs_key_event</p>
    <p>key_up : boolean</p>
    <p><pre>void obs_source_send_key_click(obs_source_t *source, const struct obs_key_event *event, bool key_up)</pre></p>
    <hr/><h3>obs_source_send_mouse_click(source, event, type, mouse_up, click_count)</h3>
    <pre>
    Used for interacting with sources: sends a mouse down/up event to a
    source.
    
    </pre>
    <p>source : obs_source</p>
    <p>event : obs_mouse_event</p>
    <p>type : number</p>
    <p>mouse_up : boolean</p>
    <p>click_count : number</p>
    <p><pre>void obs_source_send_mouse_click(obs_source_t *source, const struct obs_mouse_event *event, int32_t type, bool mouse_up, uint32_t click_count)</pre></p>
    <hr/><h3>obs_source_send_mouse_move(source, event, mouse_leave)</h3>
    <pre>
    Used for interacting with sources: sends a mouse move event to a
    source.
    
    </pre>
    <p>source : obs_source</p>
    <p>event : obs_mouse_event</p>
    <p>mouse_leave : boolean</p>
    <p><pre>void obs_source_send_mouse_move(obs_source_t *source, const struct obs_mouse_event *event, bool mouse_leave)</pre></p>
    <hr/><h3>obs_source_send_mouse_wheel(source, event, x_delta, y_delta)</h3>
    <pre>
    Used for interacting with sources:  sends a mouse wheel event to a
    source.
    
    </pre>
    <p>source : obs_source</p>
    <p>event : obs_mouse_event</p>
    <p>x_delta : number</p>
    <p>y_delta : number</p>
    <p><pre>void obs_source_send_mouse_wheel(obs_source_t *source, const struct obs_mouse_event *event, int x_delta, int y_delta)</pre></p>
    <hr/><h3>obs_source_set_async_decoupled(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : boolean</p>
    <hr/><h3>obs_source_set_async_rotation(source, rotation)</h3>
    <pre>
    Allows the ability to set rotation (0, 90, 180, -90, 270) for an
    async video source.  The rotation will be automatically applied to
    the source.
    
    </pre>
    <p>source : obs_source</p>
    <p>rotation : number</p>
    <p><pre>void obs_source_set_async_rotation(obs_source_t *source, long rotation)</pre></p>
    <hr/><h3>obs_source_set_async_unbuffered(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : boolean</p>
    <hr/><h3>obs_source_set_audio_active(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : boolean</p>
    <hr/><h3>obs_source_set_audio_mixers(source, mixers)</h3>
    <pre>
    Sets/gets the audio mixer channels that a source outputs to
    (depending on what bits are set).  Audio mixers allow filtering
    specific using multiple audio encoders to mix different sources
    together depending on what mixer channel they're set to.
    
    For example, to output to mixer 1 and 3, you would perform a bitwise
    OR on bits 0 and 2:  (1<<0) | (1<<2), or 0x5.
    
    </pre>
    <p>source : obs_source</p>
    <p>mixers : number</p>
    <p><pre>void obs_source_set_audio_mixers(obs_source_t *source, uint32_t mixers)</pre></p>
    <hr/><h3>obs_source_set_balance_value(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : number</p>
    <hr/><h3>obs_source_set_default_flags(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : number</p>
    <hr/><h3>obs_source_set_deinterlace_field_order(source, order)</h3>
    <pre>
    Sets/gets the deinterlace field order.
    
    :param order: | OBS_DEINTERLACE_FIELD_ORDER_TOP - Start from top
                  | OBS_DEINTERLACE_FIELD_ORDER_BOTTOM - Start from bottom
    
    </pre>
    <p>source : obs_source</p>
    <p>order : number</p>
    <p><pre>void obs_source_set_deinterlace_field_order(obs_source_t *source, enum obs_deinterlace_field_order order)</pre></p>
    <hr/><h3>obs_source_set_deinterlace_mode(source, mode)</h3>
    <pre>
    Sets/gets the deinterlace mode.
    
    :param mode:   | OBS_DEINTERLACE_MODE_DISABLE    - Disables deinterlacing
                   | OBS_DEINTERLACE_MODE_DISCARD    - Discard
                   | OBS_DEINTERLACE_MODE_RETRO      - Retro
                   | OBS_DEINTERLACE_MODE_BLEND      - Blend
                   | OBS_DEINTERLACE_MODE_BLEND_2X   - Blend 2x
                   | OBS_DEINTERLACE_MODE_LINEAR     - Linear
                   | OBS_DEINTERLACE_MODE_LINEAR_2X  - Linear 2x
                   | OBS_DEINTERLACE_MODE_YADIF      - Yadif
                   | OBS_DEINTERLACE_MODE_YADIF_2X   - Yadif 2x
    
    </pre>
    <p>source : obs_source</p>
    <p>mode : number</p>
    <p><pre>void obs_source_set_deinterlace_mode(obs_source_t *source, enum obs_deinterlace_mode mode)</pre></p>
    <hr/><h3>obs_source_set_enabled(source, enabled)</h3>
    <pre>
    Enables/disables a source, or returns the enabled state.
    
    </pre>
    <p>source : obs_source</p>
    <p>enabled : boolean</p>
    <p><pre>void obs_source_set_enabled(obs_source_t *source, bool enabled)</pre></p>
    <hr/><h3>obs_source_set_flags(source, flags)</h3>
    <pre>
    :param flags: OBS_SOURCE_FLAG_FORCE_MONO Forces audio to mono
    
    </pre>
    <p>source : obs_source</p>
    <p>flags : number</p>
    <p><pre>void obs_source_set_flags(obs_source_t *source, uint32_t flags)</pre></p>
    <hr/><h3>obs_source_set_monitoring_type(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : number</p>
    <hr/><h3>obs_source_set_muted(source, muted)</h3>
    <pre>
    Sets/gets whether the source's audio is muted.
    
    </pre>
    <p>source : obs_source</p>
    <p>muted : boolean</p>
    <p><pre>void obs_source_set_muted(obs_source_t *source, bool muted)</pre></p>
    <hr/><h3>obs_source_set_name(source, name)</h3>
    <pre>
    Sets the name of a source.  If the source is not private and the name
    is not unique, it will automatically be given a unique name.
    
    </pre>
    <p>source : obs_source</p>
    <p>name : string</p>
    <p><pre>void obs_source_set_name(obs_source_t *source, const char *name)</pre></p>
    <hr/><h3>obs_source_set_push_to_mute_delay(source, delay)</h3>
    <pre>
    Sets/gets the push-to-mute delay.
    
    </pre>
    <p>source : obs_source</p>
    <p>delay : number</p>
    <p><pre>void obs_source_set_push_to_mute_delay(obs_source_t *source, uint64_t delay)</pre></p>
    <hr/><h3>obs_source_set_push_to_talk_delay(source, delay)</h3>
    <pre>
    Sets/gets the push-to-talk delay.
    
    </pre>
    <p>source : obs_source</p>
    <p>delay : number</p>
    <p><pre>void obs_source_set_push_to_talk_delay(obs_source_t *source, uint64_t delay)</pre></p>
    <hr/><h3>obs_source_set_sync_offset(source, offset)</h3>
    <pre>
    Sets/gets the audio sync offset (in nanoseconds) for a source.
    
    </pre>
    <p>source : obs_source</p>
    <p>offset : number</p>
    <p><pre>void obs_source_set_sync_offset(obs_source_t *source, int64_t offset)</pre></p>
    <hr/><h3>obs_source_set_video_frame(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : obs_source_frame</p>
    <hr/><h3>obs_source_set_video_frame2(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : obs_source_frame2</p>
    <hr/><h3>obs_source_set_volume(source, volume)</h3>
    <pre>
    Sets/gets the user volume for a source that has audio output.
    
    </pre>
    <p>source : obs_source</p>
    <p>volume : number</p>
    <p><pre>void obs_source_set_volume(obs_source_t *source, float volume)</pre></p>
    <hr/><h3>obs_source_show_preloaded_video(source)</h3>
    <pre>
    Shows any preloaded video frame.
    
    </pre>
    <p>source : obs_source</p>
    <p><pre>void obs_source_show_preloaded_video(obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_showing(source)</h3>
    <pre>
    :return: *true* if showing, *false* if not.  A source is considered
             showing if it's being displayed anywhere at all, whether on
             a display context or on the final output
    
    </pre>
    <p>source : obs_source</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_source_showing(const obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_skip_video_filter(filter)</h3>
    <pre>
    Skips the filter if the filter is invalid and cannot be rendered.
    
    </pre>
    <p>filter : obs_source</p>
    <p><pre>void obs_source_skip_video_filter(obs_source_t *filter)</pre></p>
    <hr/><h3>obs_source_update(source, settings)</h3>
    <pre>
    Updates the settings for a source and calls the
    :c:member:`obs_source_info.update` callback of the source.  If the
    source is a video source, the :c:member:`obs_source_info.update` will
    be not be called immediately; instead, it will be deferred to the
    video thread to prevent threading issues.
    
    </pre>
    <p>source : obs_source</p>
    <p>settings : obs_data</p>
    <p><pre>void obs_source_update(obs_source_t *source, obs_data_t *settings)</pre></p>
    <hr/><h3>obs_source_update_properties(source)</h3>
    <pre>
    Signal an update to any currently used properties.
    
    </pre>
    <p>source : obs_source</p>
    <p><pre>void obs_source_update_properties(obs_source_t *source)</pre></p>
    <hr/><h3>obs_source_video_render(source)</h3>
    <pre>
    Renders a video source.  This will call the
    :c:member:`obs_source_info.video_render` callback of the source.
    
    </pre>
    <p>source : obs_source</p>
    <p><pre>void obs_source_video_render(obs_source_t *source)</pre></p>
    <hr/><h3>obs_startup(locale, module_config_path, store)</h3>
    <pre>
    Initializes the OBS core context.
    
    :param  locale:             The locale to use for modules
                                (E.G. "en-US")
    :param  module_config_path: Path to module config storage directory
                                (or *NULL* if none)
    :param  store:              The profiler name store for OBS to use or NULL
    :return:                    *false* if already initialized or failed
                                to initialize
    
    </pre>
    <p>locale : string</p>
    <p>module_config_path : string</p>
    <p>store : profiler_name_store_t</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_startup(const char *locale, const char *module_config_path, profiler_name_store_t *store)</pre></p>
    <hr/><h3>obs_transition_audio_render(transition, ts_out, audio, mixers, channels, sample_rate, mix_a_callback, mix_b_callback)</h3>
    <pre>
    Helper function used for transitioning audio.  Typically you'd call
    this in the obs_source_info.audio_render callback with its
    parameters, and use the mix_a_callback and mix_b_callback to
    determine the the audio fading of source A and source B.
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    typedef float (*obs_transition_audio_mix_callback_t)(void *data, float t);
    
    </pre>
    <p>transition : obs_source</p>
    <p>ts_out : unsigned_long_long</p>
    <p>audio : obs_source_audio_mix</p>
    <p>mixers : number</p>
    <p>channels : number</p>
    <p>sample_rate : number</p>
    <p>mix_a_callback : f_p_void_float__float</p>
    <p>mix_b_callback : f_p_void_float__float</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_transition_audio_render(obs_source_t *transition, uint64_t *ts_out, struct obs_source_audio_mix *audio, uint32_t mixers, size_t channels, size_t sample_rate, obs_transition_audio_mix_callback_t mix_a_callback, obs_transition_audio_mix_callback_t mix_b_callback)</pre></p>
    <hr/><h3>obs_transition_clear(transition)</h3>
    <pre>
    Clears the transition.
    
    </pre>
    <p>transition : obs_source</p>
    <p><pre>void obs_transition_clear(obs_source_t *transition)</pre></p>
    <hr/><h3>obs_transition_enable_fixed(transition, enable, duration_ms)</h3>
    <pre>
    Sets/gets whether the transition uses a fixed duration.  Useful for
    certain types of transitions such as stingers.  If this is set, the 
    *duration_ms* parameter of :c:func:`obs_transition_start()` has no
    effect.
    
    </pre>
    <p>transition : obs_source</p>
    <p>enable : boolean</p>
    <p>duration_ms : number</p>
    <p><pre>void obs_transition_enable_fixed(obs_source_t *transition, bool enable, uint32_t duration_ms)</pre></p>
    <hr/><h3>obs_transition_fixed(transition)</h3>
    <pre>
    Sets/gets whether the transition uses a fixed duration.  Useful for
    certain types of transitions such as stingers.  If this is set, the 
    *duration_ms* parameter of :c:func:`obs_transition_start()` has no
    effect.
    
    </pre>
    <p>transition : obs_source</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_transition_fixed(obs_source_t *transition)</pre></p>
    <hr/><h3>obs_transition_force_stop(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <hr/><h3>obs_transition_get_active_source(transition)</h3>
    <pre>
    :return: An incremented reference to the currently active source of
             the transition
    
    </pre>
    <p>transition : obs_source</p>
    <p>Return : obs_source</p>
    <p><pre>obs_source_t *obs_transition_get_active_source(obs_source_t *transition)</pre></p>
    <hr/><h3>obs_transition_get_alignment(transition)</h3>
    <pre>
    Sets/gets the alignment used to draw the two sources within
    transition the transition.
    
    :param alignment: | Can be any bitwise OR combination of:
                      | OBS_ALIGN_CENTER
                      | OBS_ALIGN_LEFT
                      | OBS_ALIGN_RIGHT
                      | OBS_ALIGN_TOP
                      | OBS_ALIGN_BOTTOM
    
    </pre>
    <p>transition : obs_source</p>
    <p>Return : number</p>
    <p><pre>uint32_t obs_transition_get_alignment(const obs_source_t *transition)</pre></p>
    <hr/><h3>obs_transition_get_scale_type(transition)</h3>
    <pre>
    Sets/gets the scale type for sources within the transition.
    
    :param type: | OBS_TRANSITION_SCALE_MAX_ONLY - Scale to aspect ratio, but only to the maximum size of each source
                 | OBS_TRANSITION_SCALE_ASPECT   - Always scale the sources, but keep aspect ratio
                 | OBS_TRANSITION_SCALE_STRETCH  - Scale and stretch the sources to the size of the transition
    
    </pre>
    <p>transition : obs_source</p>
    <p>Return : number</p>
    <p><pre>enum obs_transition_scale_type obs_transition_get_scale_type( const obs_source_t *transition)</pre></p>
    <hr/><h3>obs_transition_get_size(transition, cx, cy)</h3>
    <pre>
    Sets/gets the dimensions of the transition.
    
    </pre>
    <p>transition : obs_source</p>
    <p>cx : unsigned_int</p>
    <p>cy : unsigned_int</p>
    <p><pre>void obs_transition_get_size(const obs_source_t *transition, uint32_t *cx, uint32_t *cy)</pre></p>
    <hr/><h3>obs_transition_get_source(transition, target)</h3>
    <pre>
    :param target: | OBS_TRANSITION_SOURCE_A - Source being transitioned from, or the current source if not transitioning
                   | OBS_TRANSITION_SOURCE_B - Source being transitioned to
    :return:       An incremented reference to the source or destination
                   sources of the transition
    
    </pre>
    <p>transition : obs_source</p>
    <p>target : number</p>
    <p>Return : obs_source</p>
    <p><pre>obs_source_t *obs_transition_get_source(obs_source_t *transition, enum obs_transition_target target)</pre></p>
    <hr/><h3>obs_transition_get_time(transition)</h3>
    <pre>
    :return: The current transition time value (0.0f..1.0f)
    
    </pre>
    <p>transition : obs_source</p>
    <p>Return : number</p>
    <p><pre>float obs_transition_get_time(obs_source_t *transition)</pre></p>
    <hr/><h3>obs_transition_set(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : obs_source</p>
    <hr/><h3>obs_transition_set_alignment(transition, alignment)</h3>
    <pre>
    Sets/gets the alignment used to draw the two sources within
    transition the transition.
    
    :param alignment: | Can be any bitwise OR combination of:
                      | OBS_ALIGN_CENTER
                      | OBS_ALIGN_LEFT
                      | OBS_ALIGN_RIGHT
                      | OBS_ALIGN_TOP
                      | OBS_ALIGN_BOTTOM
    
    </pre>
    <p>transition : obs_source</p>
    <p>alignment : number</p>
    <p><pre>void obs_transition_set_alignment(obs_source_t *transition, uint32_t alignment)</pre></p>
    <hr/><h3>obs_transition_set_manual_time(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : number</p>
    <hr/><h3>obs_transition_set_manual_torque(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : number</p>
    <p>param3 : number</p>
    <hr/><h3>obs_transition_set_scale_type(transition, type)</h3>
    <pre>
    Sets/gets the scale type for sources within the transition.
    
    :param type: | OBS_TRANSITION_SCALE_MAX_ONLY - Scale to aspect ratio, but only to the maximum size of each source
                 | OBS_TRANSITION_SCALE_ASPECT   - Always scale the sources, but keep aspect ratio
                 | OBS_TRANSITION_SCALE_STRETCH  - Scale and stretch the sources to the size of the transition
    
    </pre>
    <p>transition : obs_source</p>
    <p>type : number</p>
    <p><pre>void obs_transition_set_scale_type(obs_source_t *transition, enum obs_transition_scale_type type)</pre></p>
    <hr/><h3>obs_transition_set_size(transition, cx, cy)</h3>
    <pre>
    Sets/gets the dimensions of the transition.
    
    </pre>
    <p>transition : obs_source</p>
    <p>cx : number</p>
    <p>cy : number</p>
    <p><pre>void obs_transition_set_size(obs_source_t *transition, uint32_t cx, uint32_t cy)</pre></p>
    <hr/><h3>obs_transition_start(transition, mode, duration_ms, dest)</h3>
    <pre>
    Starts the transition with the desired destination source.
    
    :param mode:        Currently only OBS_TRANSITION_MODE_AUTO
    :param duration_ms: Duration in milliseconds.  If the transition has
                        a fixed duration set by
                        :c:func:`obs_transition_enable_fixed`, this
                        parameter will have no effect
    :param dest:        The destination source to transition to
    
    </pre>
    <p>transition : obs_source</p>
    <p>mode : number</p>
    <p>duration_ms : number</p>
    <p>dest : obs_source</p>
    <p>Return : boolean</p>
    <p><pre>bool obs_transition_start(obs_source_t *transition, enum obs_transition_mode mode, uint32_t duration_ms, obs_source_t *dest)</pre></p>
    <hr/><h3>obs_transition_swap_begin(tr_dest, tr_source)</h3>
    <pre>
    Swaps two transitions.  Call obs_transition_swap_begin, swap the
    source, then call obs_transition_swap_end when complete.  This allows
    the ability to seamlessly swap two different transitions without it
    affecting the output.
    
    For example, if a transition is assigned to output channel 0, you'd
    call obs_transition_swap_begin, then you'd call obs_set_output_source
    with the new transition, then call
    :c:func:`obs_transition_swap_begin()`.
    
    .. ---------------------------------------------------------------------------
    
    .. _libobs/obs-source.h: https://github.com/jp9000/obs-studio/blob/master/libobs/obs-source.h
    </pre>
    <p>tr_dest : obs_source</p>
    <p>tr_source : obs_source</p>
    <p><pre>void obs_transition_swap_begin(obs_source_t *tr_dest, obs_source_t *tr_source)</pre></p>
    <hr/><h3>obs_transition_swap_end(tr_dest, tr_source)</h3>
    <pre>
    Swaps two transitions.  Call obs_transition_swap_begin, swap the
    source, then call obs_transition_swap_end when complete.  This allows
    the ability to seamlessly swap two different transitions without it
    affecting the output.
    
    For example, if a transition is assigned to output channel 0, you'd
    call obs_transition_swap_begin, then you'd call obs_set_output_source
    with the new transition, then call
    :c:func:`obs_transition_swap_begin()`.
    
    .. ---------------------------------------------------------------------------
    
    .. _libobs/obs-source.h: https://github.com/jp9000/obs-studio/blob/master/libobs/obs-source.h
    </pre>
    <p>tr_dest : obs_source</p>
    <p>tr_source : obs_source</p>
    <p><pre>void obs_transition_swap_end(obs_source_t *tr_dest, obs_source_t *tr_source)</pre></p>
    <hr/><h3>obs_transition_video_render(transition, callback)</h3>
    <pre>
    Helper function used for rendering transitions.  This function will
    render two distinct textures for source A and source B of the
    transition, allowing the ability to blend them together with a pixel
    shader in a desired manner.
    
    The *a* and *b* parameters of *callback* are automatically rendered
    textures of source A and source B, *t* is the time value
    (0.0f..1.0f), *cx* and *cy* are the current dimensions of the
    transition, and *data* is the implementation's private data.
    
    Relevant data types used with this function:
    
    .. code:: cpp
    
    typedef void (*obs_transition_video_render_callback_t)(void *data,
                    gs_texture_t *a, gs_texture_t *b, float t,
                    uint32_t cx, uint32_t cy);
    
    </pre>
    <p>transition : obs_source</p>
    <p>callback : f_p_void_p_struct_gs_texture_p_struct_gs_texture_float_unsigned_int_unsigned_int__void</p>
    <p><pre>void obs_transition_video_render(obs_source_t *transition, obs_transition_video_render_callback_t callback)</pre></p>
    <hr/><h3>obs_transition_video_render_direct(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_source</p>
    <p>param2 : number</p>
    <hr/><h3>obs_video_active()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_video_encoder_create(id, name, settings, hotkey_data)</h3>
    <pre>
    Creates a video encoder with the specified settings.
    
    The "encoder" context is used for encoding video/audio data.  Use
    obs_encoder_release to release it.
    
    :param   id:             The encoder type string identifier
    :param   name:           The desired name of the encoder.  If this is
                             not unique, it will be made to be unique
    :param   settings:       The settings for the encoder, or *NULL* if
                             none
    :param   hotkey_data:    Saved hotkey data for the encoder, or *NULL*
                             if none
    :return:                 A reference to the newly created encoder, or
                             *NULL* if failed
    
    </pre>
    <p>id : string</p>
    <p>name : string</p>
    <p>settings : obs_data</p>
    <p>hotkey_data : obs_data</p>
    <p>Return : obs_encoder</p>
    <p><pre>obs_encoder_t *obs_video_encoder_create(const char *id, const char *name, obs_data_t *settings, obs_data_t *hotkey_data)</pre></p>
    <hr/><h3>obs_view_create()</h3>
    <p>Not mentioned in OBS documentation</p>
    <hr/><h3>obs_view_destroy(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_view</p>
    <hr/><h3>obs_view_get_source(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_view</p>
    <p>param2 : number</p>
    <hr/><h3>obs_view_render(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_view</p>
    <hr/><h3>obs_view_set_source(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_view</p>
    <p>param2 : number</p>
    <p>param3 : obs_source</p>
    <hr/><h3>obs_weak_encoder_addref(weak)</h3>
    <pre>
    Adds/releases a weak reference to an encoder.
    
    </pre>
    <p>weak : obs_weak_encoder</p>
    <p><pre>void obs_weak_encoder_addref(obs_weak_encoder_t *weak)</pre></p>
    <hr/><h3>obs_weak_encoder_get_encoder(weak)</h3>
    <pre>
    These functions are used to get a weak reference from a strong encoder
    reference, or a strong encoder reference from a weak reference.  If
    the encoder is destroyed, *obs_weak_encoder_get_encoder* will return
    *NULL*.
    
    </pre>
    <p>weak : obs_weak_encoder</p>
    <p>Return : obs_encoder</p>
    <p><pre>obs_encoder_t *obs_weak_encoder_get_encoder(obs_weak_encoder_t *weak)</pre></p>
    <hr/><h3>obs_weak_encoder_references_encoder(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_weak_encoder</p>
    <p>param2 : obs_encoder</p>
    <hr/><h3>obs_weak_encoder_release(weak)</h3>
    <pre>
    Adds/releases a weak reference to an encoder.
    
    </pre>
    <p>weak : obs_weak_encoder</p>
    <p><pre>void obs_weak_encoder_release(obs_weak_encoder_t *weak)</pre></p>
    <hr/><h3>obs_weak_output_addref(weak)</h3>
    <pre>
    Adds/releases a weak reference to an output.
    
    </pre>
    <p>weak : obs_weak_output</p>
    <p><pre>void obs_weak_output_addref(obs_weak_output_t *weak)</pre></p>
    <hr/><h3>obs_weak_output_get_output(weak)</h3>
    <pre>
    These functions are used to get a weak reference from a strong output
    reference, or a strong output reference from a weak reference.  If
    the output is destroyed, *obs_weak_output_get_output* will return
    *NULL*.
    
    </pre>
    <p>weak : obs_weak_output</p>
    <p>Return : obs_output</p>
    <p><pre>obs_output_t *obs_weak_output_get_output(obs_weak_output_t *weak)</pre></p>
    <hr/><h3>obs_weak_output_references_output(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_weak_output</p>
    <p>param2 : obs_output</p>
    <hr/><h3>obs_weak_output_release(weak)</h3>
    <pre>
    Adds/releases a weak reference to an output.
    
    </pre>
    <p>weak : obs_weak_output</p>
    <p><pre>void obs_weak_output_release(obs_weak_output_t *weak)</pre></p>
    <hr/><h3>obs_weak_service_addref(weak)</h3>
    <pre>
    Adds/releases a weak reference to a service.
    
    </pre>
    <p>weak : obs_weak_service</p>
    <p><pre>void obs_weak_service_addref(obs_weak_service_t *weak)</pre></p>
    <hr/><h3>obs_weak_service_get_service(weak)</h3>
    <pre>
    These functions are used to get a weak reference from a strong service
    reference, or a strong service reference from a weak reference.  If
    the service is destroyed, *obs_weak_service_get_service* will return
    *NULL*.
    
    </pre>
    <p>weak : obs_weak_service</p>
    <p>Return : obs_service</p>
    <p><pre>obs_service_t *obs_weak_service_get_service(obs_weak_service_t *weak)</pre></p>
    <hr/><h3>obs_weak_service_references_service(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_weak_service</p>
    <p>param2 : obs_service</p>
    <hr/><h3>obs_weak_service_release(weak)</h3>
    <pre>
    Adds/releases a weak reference to a service.
    
    </pre>
    <p>weak : obs_weak_service</p>
    <p><pre>void obs_weak_service_release(obs_weak_service_t *weak)</pre></p>
    <hr/><h3>obs_weak_source_addref(weak)</h3>
    <pre>
    Adds/releases a weak reference to a source.
    
    </pre>
    <p>weak : obs_weak_source</p>
    <p><pre>void obs_weak_source_addref(obs_weak_source_t *weak)</pre></p>
    <hr/><h3>obs_weak_source_get_source(weak)</h3>
    <pre>
    These functions are used to get a weak reference from a strong source
    reference, or a strong source reference from a weak reference.  If
    the source is destroyed, *obs_weak_source_get_source* will return
    *NULL*.
    
    </pre>
    <p>weak : obs_weak_source</p>
    <p>Return : obs_source</p>
    <p><pre>obs_source_t *obs_weak_source_get_source(obs_weak_source_t *weak)</pre></p>
    <hr/><h3>obs_weak_source_references_source(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : obs_weak_source</p>
    <p>param2 : obs_source</p>
    <hr/><h3>obs_weak_source_release(weak)</h3>
    <pre>
    Adds/releases a weak reference to a source.
    
    </pre>
    <p>weak : obs_weak_source</p>
    <p><pre>void obs_weak_source_release(obs_weak_source_t *weak)</pre></p>
    <hr/><h3>os_breakpoint()</h3>
    <pre>
    Triggers a debugger breakpoint (or crashes the program if no debugger
    present).
    
    </pre>
    <p><pre>void os_breakpoint(void)</pre></p>
    <hr/><h3>os_chdir(path)</h3>
    <pre>
    Changes the current working directory.
    
    </pre>
    <p>path : string</p>
    <p>Return : number</p>
    <p><pre>int os_chdir(const char *path)</pre></p>
    <hr/><h3>os_closedir(dir)</h3>
    <pre>
    Closes a directory object.
    
    </pre>
    <p>dir : os_dir</p>
    <p><pre>void os_closedir(os_dir_t *dir)</pre></p>
    <hr/><h3>os_copyfile(file_in, file_out)</h3>
    <pre>
    Copies a file.
    
    </pre>
    <p>file_in : string</p>
    <p>file_out : string</p>
    <p>Return : number</p>
    <p><pre>int os_copyfile(const char *file_in, const char *file_out)</pre></p>
    <hr/><h3>os_cpu_usage_info_destroy(info)</h3>
    <pre>
    Destroys a CPU usage information object.
    
    </pre>
    <p>info : os_cpu_usage_info</p>
    <p><pre>void                os_cpu_usage_info_destroy(os_cpu_usage_info_t *info)</pre></p>
    <hr/><h3>os_cpu_usage_info_query(info)</h3>
    <pre>
    Queries the current CPU usage.
    
    </pre>
    <p>info : os_cpu_usage_info</p>
    <p>Return : number</p>
    <p><pre>double              os_cpu_usage_info_query(os_cpu_usage_info_t *info)</pre></p>
    <hr/><h3>os_cpu_usage_info_start()</h3>
    <pre>
    Creates a CPU usage information object.
    
    </pre>
    <p>Return : os_cpu_usage_info</p>
    <p><pre>os_cpu_usage_info_t *os_cpu_usage_info_start(void)</pre></p>
    <hr/><h3>os_dlclose(module)</h3>
    <pre>
    Closes a dynamic library.
    
    </pre>
    <p>module : ref_void*</p>
    <p><pre>void os_dlclose(void *module)</pre></p>
    <hr/><h3>os_dlopen(path)</h3>
    <pre>
    Opens a dynamic library.
    
    </pre>
    <p>path : string</p>
    <p>Return : void</p>
    <p><pre>void *os_dlopen(const char *path)</pre></p>
    <hr/><h3>os_dlsym(module, func)</h3>
    <pre>
    Returns a symbol from a dynamic library.
    
    </pre>
    <p>module : ref_void*</p>
    <p>func : string</p>
    <p>Return : void</p>
    <p><pre>void *os_dlsym(void *module, const char *func)</pre></p>
    <hr/><h3>os_dtostr(value, dst, size)</h3>
    <pre>
    Converts a double to a string.
    
    </pre>
    <p>value : number</p>
    <p>dst : string</p>
    <p>size : number</p>
    <p>Return : number</p>
    <p><pre>int os_dtostr(double value, char *dst, size_t size)</pre></p>
    <hr/><h3>os_end_high_performance(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : ref_os_performance_token_t*</p>
    <hr/><h3>os_fgetsize(file)</h3>
    <pre>
    Returns a file's size.
    
    </pre>
    <p>file : FILE</p>
    <p>Return : number</p>
    <p><pre>int64_t os_fgetsize(FILE *file)</pre></p>
    <hr/><h3>os_file_exists(path)</h3>
    <pre>
    Returns true if a file/directory exists, false otherwise.
    
    </pre>
    <p>path : string</p>
    <p>Return : boolean</p>
    <p><pre>bool os_file_exists(const char *path)</pre></p>
    <hr/><h3>os_fopen(path, mode)</h3>
    <pre>
    Opens a file with a UTF8 string path.
    
    </pre>
    <p>path : string</p>
    <p>mode : string</p>
    <p>Return : FILE</p>
    <p><pre>FILE *os_fopen(const char *path, const char *mode)</pre></p>
    <hr/><h3>os_fread_mbs(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : FILE</p>
    <p>param2 : p_char</p>
    <hr/><h3>os_fread_utf8(file, pstr)</h3>
    <pre>
    Reads a UTF8 encoded file and allocates a pointer to the UTF8 string.
    
    </pre>
    <p>file : FILE</p>
    <p>pstr : p_char</p>
    <p>Return : number</p>
    <p><pre>size_t os_fread_utf8(FILE *file, char **pstr)</pre></p>
    <hr/><h3>os_fseeki64(file, offset, origin)</h3>
    <pre>
    Equivalent to fseek.
    
    </pre>
    <p>file : FILE</p>
    <p>offset : number</p>
    <p>origin : number</p>
    <p>Return : number</p>
    <p><pre>int os_fseeki64(FILE *file, int64_t offset, int origin)</pre></p>
    <hr/><h3>os_ftelli64(file)</h3>
    <pre>
    Gets the current file position.
    
    </pre>
    <p>file : FILE</p>
    <p>Return : number</p>
    <p><pre>int64_t os_ftelli64(FILE *file)</pre></p>
    <hr/><h3>os_generate_formatted_filename(extension, space, format)</h3>
    <pre>
    Returns a new bmalloc-allocated filename generated from specific
    formatting.
    
    </pre>
    <p>extension : string</p>
    <p>space : boolean</p>
    <p>format : string</p>
    <p>Return : string</p>
    <p><pre>char *os_generate_formatted_filename(const char *extension, bool space, const char *format)</pre></p>
    <hr/><h3>os_get_abs_path(path, abspath, size)</h3>
    <pre>
    Converts a relative path to an absolute path.
    
    </pre>
    <p>path : string</p>
    <p>abspath : string</p>
    <p>size : number</p>
    <p>Return : number</p>
    <p><pre>size_t os_get_abs_path(const char *path, char *abspath, size_t size)</pre></p>
    <hr/><h3>os_get_abs_path_ptr(path)</h3>
    <pre>
    Converts a relative path to an absolute path.
    
    </pre>
    <p>path : string</p>
    <p>Return : string</p>
    <p><pre>char *os_get_abs_path_ptr(const char *path)</pre></p>
    <hr/><h3>os_get_config_path(dst, size, name)</h3>
    <pre>
    Gets the user-specific application configuration data path.
    
    </pre>
    <p>dst : string</p>
    <p>size : number</p>
    <p>name : string</p>
    <p>Return : number</p>
    <p><pre>int os_get_config_path(char *dst, size_t size, const char *name)</pre></p>
    <hr/><h3>os_get_config_path_ptr(name)</h3>
    <pre>
    Gets the user-specific application configuration data path.
    
    </pre>
    <p>name : string</p>
    <p>Return : string</p>
    <p><pre>char *os_get_config_path_ptr(const char *name)</pre></p>
    <hr/><h3>os_get_executable_path_ptr(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <hr/><h3>os_get_file_size(path)</h3>
    <pre>
    Gets a file's size.
    
    </pre>
    <p>path : string</p>
    <p>Return : number</p>
    <p><pre>int64_t os_get_file_size(const char *path)</pre></p>
    <hr/><h3>os_get_free_disk_space(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <hr/><h3>os_get_free_space(path)</h3>
    <pre>
    Gets free space of a specific file path.
    
    </pre>
    <p>path : string</p>
    <p>Return : number</p>
    <p><pre>int64_t os_get_free_space(const char *path)</pre></p>
    <hr/><h3>os_get_logical_cores()</h3>
    <pre>
    Returns the number of logical cores available.
    
    </pre>
    <p>Return : number</p>
    <p><pre>int os_get_logical_cores(void)</pre></p>
    <hr/><h3>os_get_path_extension(path)</h3>
    <pre>
    Returns the extension portion of a path string.
    
    </pre>
    <p>path : string</p>
    <p>Return : string</p>
    <p><pre>const char *os_get_path_extension(const char *path)</pre></p>
    <hr/><h3>os_get_physical_cores()</h3>
    <pre>
    Returns the number of physical cores available.
    
    </pre>
    <p>Return : number</p>
    <p><pre>int os_get_physical_cores(void)</pre></p>
    <hr/><h3>os_get_proc_memory_usage(usage)</h3>
    <pre>
    Gets memory usage of the current process.
    
    </pre>
    <p>usage : os_proc_memory_usage</p>
    <p>Return : boolean</p>
    <p><pre>bool os_get_proc_memory_usage(os_proc_memory_usage_t *usage)</pre></p>
    <hr/><h3>os_get_proc_resident_size()</h3>
    <pre>
    Returns the resident memory size of the current process.
    
    </pre>
    <p>Return : number</p>
    <p><pre>uint64_t os_get_proc_resident_size(void)</pre></p>
    <hr/><h3>os_get_proc_virtual_size()</h3>
    <pre>
    Returns the virtual memory size of the current process.
    </pre>
    <p>Return : number</p>
    <p><pre>uint64_t os_get_proc_virtual_size(void)</pre></p>
    <hr/><h3>os_get_program_data_path(dst, size, name)</h3>
    <pre>
    Gets the application configuration data path.
    
    </pre>
    <p>dst : string</p>
    <p>size : number</p>
    <p>name : string</p>
    <p>Return : number</p>
    <p><pre>int os_get_program_data_path(char *dst, size_t size, const char *name)</pre></p>
    <hr/><h3>os_get_program_data_path_ptr(name)</h3>
    <pre>
    Gets the application configuration data path.
    
    </pre>
    <p>name : string</p>
    <p>Return : string</p>
    <p><pre>char *os_get_program_data_path_ptr(const char *name)</pre></p>
    <hr/><h3>os_get_sys_free_size()</h3>
    <pre>
    Returns the amount of memory available.
    
    </pre>
    <p>Return : number</p>
    <p><pre>uint64_t os_get_sys_free_size(void)</pre></p>
    <hr/><h3>os_getcwd(path, size)</h3>
    <pre>
    Returns a new bmalloc-allocated path to the current working
    directory.
    
    </pre>
    <p>path : string</p>
    <p>size : number</p>
    <p>Return : string</p>
    <p><pre>char *os_getcwd(char *path, size_t size)</pre></p>
    <hr/><h3>os_gettime_ns()</h3>
    <pre>
    Gets the current high-precision system time, in nanoseconds.
    
    </pre>
    <p>Return : number</p>
    <p><pre>uint64_t os_gettime_ns(void)</pre></p>
    <hr/><h3>os_glob(pattern, flags, pglob)</h3>
    <pre>
    Enumerates files based upon a glob string.
    
    </pre>
    <p>pattern : string</p>
    <p>flags : number</p>
    <p>pglob : p_os_glob_info</p>
    <p>Return : number</p>
    <p><pre>int os_glob(const char *pattern, int flags, os_glob_t **pglob)</pre></p>
    <hr/><h3>os_globfree(pglob)</h3>
    <pre>
    Frees a glob object.
    
    </pre>
    <p>pglob : os_glob_info</p>
    <p><pre>void os_globfree(os_glob_t *pglob)</pre></p>
    <hr/><h3>os_inhibit_sleep_create(reason)</h3>
    <pre>
    Creates a sleep inhibition object.
    
    </pre>
    <p>reason : string</p>
    <p>Return : os_inhibit_info</p>
    <p><pre>os_inhibit_t *os_inhibit_sleep_create(const char *reason)</pre></p>
    <hr/><h3>os_inhibit_sleep_destroy(info)</h3>
    <pre>
    Destroys a sleep inhibition object.  If the sleep inhibition object
    was active, it will be deactivated.
    
    </pre>
    <p>info : os_inhibit_info</p>
    <p><pre>void os_inhibit_sleep_destroy(os_inhibit_t *info)</pre></p>
    <hr/><h3>os_inhibit_sleep_set_active(info, active)</h3>
    <pre>
    Activates/deactivates a sleep inhibition object.
    
    </pre>
    <p>info : os_inhibit_info</p>
    <p>active : boolean</p>
    <p>Return : boolean</p>
    <p><pre>bool os_inhibit_sleep_set_active(os_inhibit_t *info, bool active)</pre></p>
    <hr/><h3>os_mbs_to_utf8_ptr(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <p>param2 : number</p>
    <p>param3 : p_char</p>
    <hr/><h3>os_mbs_to_wcs(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <p>param2 : number</p>
    <p>param3 : wchar_t</p>
    <p>param4 : number</p>
    <hr/><h3>os_mbs_to_wcs_ptr(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <p>param2 : number</p>
    <p>param3 : p_wchar_t</p>
    <hr/><h3>os_mkdir(path)</h3>
    <pre>
    Creates a directory.
    
    </pre>
    <p>path : string</p>
    <p>Return : number</p>
    <p><pre>int os_mkdir(const char *path)</pre></p>
    <hr/><h3>os_mkdirs(path)</h3>
    <pre>
    Creates a full directory path if it doesn't exist.
    
    </pre>
    <p>path : string</p>
    <p>Return : number</p>
    <p><pre>int os_mkdirs(const char *path)</pre></p>
    <hr/><h3>os_opendir(path)</h3>
    <pre>
    Opens a directory object to enumerate files within the directory.
    
    </pre>
    <p>path : string</p>
    <p>Return : os_dir</p>
    <p><pre>os_dir_t *os_opendir(const char *path)</pre></p>
    <hr/><h3>os_quick_read_mbs_file(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <hr/><h3>os_quick_read_utf8_file(path)</h3>
    <pre>
    Reads a UTF8 encoded file and returns an allocated pointer to the
    string.
    
    </pre>
    <p>path : string</p>
    <p>Return : string</p>
    <p><pre>char *os_quick_read_utf8_file(const char *path)</pre></p>
    <hr/><h3>os_quick_write_mbs_file(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <p>param2 : string</p>
    <p>param3 : number</p>
    <hr/><h3>os_quick_write_utf8_file(path, str, len, marker)</h3>
    <pre>
    Writes a UTF8 encoded file.
    
    </pre>
    <p>path : string</p>
    <p>str : string</p>
    <p>len : number</p>
    <p>marker : boolean</p>
    <p>Return : boolean</p>
    <p><pre>bool os_quick_write_utf8_file(const char *path, const char *str, size_t len, bool marker)</pre></p>
    <hr/><h3>os_quick_write_utf8_file_safe(path, str, len, marker, temp_ext, backup_ext)</h3>
    <pre>
    Writes a UTF8 encoded file with overwrite corruption prevention.
    
    </pre>
    <p>path : string</p>
    <p>str : string</p>
    <p>len : number</p>
    <p>marker : boolean</p>
    <p>temp_ext : string</p>
    <p>backup_ext : string</p>
    <p>Return : boolean</p>
    <p><pre>bool os_quick_write_utf8_file_safe(const char *path, const char *str, size_t len, bool marker, const char *temp_ext, const char *backup_ext)</pre></p>
    <hr/><h3>os_readdir(dir)</h3>
    <pre>
    Returns the linked list of directory entries.
    
    </pre>
    <p>dir : os_dir</p>
    <p>Return : os_dirent</p>
    <p><pre>struct os_dirent *os_readdir(os_dir_t *dir)</pre></p>
    <hr/><h3>os_rename(old_path, new_path)</h3>
    <pre>
    Renames a file.
    
    </pre>
    <p>old_path : string</p>
    <p>new_path : string</p>
    <p>Return : number</p>
    <p><pre>int os_rename(const char *old_path, const char *new_path)</pre></p>
    <hr/><h3>os_request_high_performance(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <hr/><h3>os_rmdir(path)</h3>
    <pre>
    Deletes a directory.
    
    </pre>
    <p>path : string</p>
    <p>Return : number</p>
    <p><pre>int os_rmdir(const char *path)</pre></p>
    <hr/><h3>os_safe_replace(target_path, from_path, backup_path)</h3>
    <pre>
    Safely replaces a file.
    
    </pre>
    <p>target_path : string</p>
    <p>from_path : string</p>
    <p>backup_path : string</p>
    <p>Return : number</p>
    <p><pre>int os_safe_replace(const char *target_path, const char *from_path, const char *backup_path)</pre></p>
    <hr/><h3>os_sleep_ms(duration)</h3>
    <pre>
    Sleeps for a specific number of milliseconds.
    
    </pre>
    <p>duration : number</p>
    <p><pre>void os_sleep_ms(uint32_t duration)</pre></p>
    <hr/><h3>os_sleepto_ns(time_target)</h3>
    <pre>
    Sleeps to a specific time with high precision, in nanoseconds.
    
    </pre>
    <p>time_target : number</p>
    <p>Return : boolean</p>
    <p><pre>bool os_sleepto_ns(uint64_t time_target)</pre></p>
    <hr/><h3>os_strtod(str)</h3>
    <pre>
    Converts a string to a double.
    
    </pre>
    <p>str : string</p>
    <p>Return : number</p>
    <p><pre>double os_strtod(const char *str)</pre></p>
    <hr/><h3>os_unlink(path)</h3>
    <pre>
    Deletes a file.
    
    </pre>
    <p>path : string</p>
    <p>Return : number</p>
    <p><pre>int os_unlink(const char *path)</pre></p>
    <hr/><h3>os_utf8_to_mbs_ptr(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : string</p>
    <p>param2 : number</p>
    <p>param3 : p_char</p>
    <hr/><h3>os_utf8_to_wcs(str, len, dst, dst_size)</h3>
    <pre>
    Converts a UTF8 string to a wide string.
    
    </pre>
    <p>str : string</p>
    <p>len : number</p>
    <p>dst : wchar_t</p>
    <p>dst_size : number</p>
    <p>Return : number</p>
    <p><pre>size_t os_utf8_to_wcs(const char *str, size_t len, wchar_t *dst, size_t dst_size)</pre></p>
    <hr/><h3>os_utf8_to_wcs_ptr(str, len, pstr)</h3>
    <pre>
    Gets an bmalloc-allocated wide string converted from a UTF8 string.
    
    </pre>
    <p>str : string</p>
    <p>len : number</p>
    <p>pstr : p_wchar_t</p>
    <p>Return : number</p>
    <p><pre>size_t os_utf8_to_wcs_ptr(const char *str, size_t len, wchar_t **pstr)</pre></p>
    <hr/><h3>os_wcs_to_mbs(param1, param2, param3, param4)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : wchar_t</p>
    <p>param2 : number</p>
    <p>param3 : string</p>
    <p>param4 : number</p>
    <hr/><h3>os_wcs_to_mbs_ptr(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : wchar_t</p>
    <p>param2 : number</p>
    <p>param3 : p_char</p>
    <hr/><h3>os_wcs_to_utf8(str, len, dst, dst_size)</h3>
    <pre>
    Converts a wide string to a UTF8 string.
    
    </pre>
    <p>str : wchar_t</p>
    <p>len : number</p>
    <p>dst : string</p>
    <p>dst_size : number</p>
    <p>Return : number</p>
    <p><pre>size_t os_wcs_to_utf8(const wchar_t *str, size_t len, char *dst, size_t dst_size)</pre></p>
    <hr/><h3>os_wcs_to_utf8_ptr(str, len, pstr)</h3>
    <pre>
    Gets an bmalloc-allocated UTF8 string converted from a wide string.
    
    </pre>
    <p>str : wchar_t</p>
    <p>len : number</p>
    <p>pstr : p_char</p>
    <p>Return : number</p>
    <p><pre>size_t os_wcs_to_utf8_ptr(const wchar_t *str, size_t len, char **pstr)</pre></p>
    <hr/><h3>os_wfopen(path, mode)</h3>
    <pre>
    Opens a file with a wide string path.
    
    </pre>
    <p>path : wchar_t</p>
    <p>mode : string</p>
    <p>Return : FILE</p>
    <p><pre>FILE *os_wfopen(const wchar_t *path, const char *mode)</pre></p>
    <hr/><h3>proc_handler_add(handler, decl_string, proc, data)</h3>
    <pre>
    Adds a procedure to a procedure handler.
    
    :param handler:     Procedure handler object
    :param decl_string: Procedure declaration string
    :param proc:        Procedure callback
    :param data:        Private data to pass to the callback
    
    </pre>
    <p>handler : proc_handler</p>
    <p>decl_string : string</p>
    <p>proc : f_p_void_p_struct_calldata__void</p>
    <p>data : ref_void*</p>
    <p><pre>void proc_handler_add(proc_handler_t *handler, const char *decl_string, proc_handler_proc_t proc, void *data)</pre></p>
    <hr/><h3>proc_handler_call(handler, name, params)</h3>
    <pre>
    Calls a procedure within the procedure handler.
    
    :param handler: Procedure handler object
    :param name:    Name of procedure to call
    :param params:  Calldata structure to pass to the procedure
    </pre>
    <p>handler : proc_handler</p>
    <p>name : string</p>
    <p>params : calldata</p>
    <p>Return : boolean</p>
    <p><pre>bool proc_handler_call(proc_handler_t *handler, const char *name, calldata_t *params)</pre></p>
    <hr/><h3>proc_handler_create()</h3>
    <pre>
    Creates a new procedure handler.
    
    :return: A new procedure handler object
    
    </pre>
    <p>Return : proc_handler</p>
    <p><pre>proc_handler_t *proc_handler_create(void)</pre></p>
    <hr/><h3>proc_handler_destroy(handler)</h3>
    <pre>
    Destroys a procedure handler object.
    
    :param handler: Procedure handler object
    
    </pre>
    <p>handler : proc_handler</p>
    <p><pre>void proc_handler_destroy(proc_handler_t *handler)</pre></p>
    <hr/><h3>quat_add(dst, v1, v2)</h3>
    <pre>
    Adds two quaternions
    
    :param dst: Destination
    :param v1:  Quaternion 1
    :param v2:  Quaternion 2
    
    </pre>
    <p>dst : quat</p>
    <p>v1 : quat</p>
    <p>v2 : quat</p>
    <p><pre>void quat_add(struct quat *dst, const struct quat *v1, const struct quat *v2)</pre></p>
    <hr/><h3>quat_addf(dst, v, f)</h3>
    <pre>
    Adds a floating point to all components
    
    :param dst: Destination
    :param dst: Quaternion
    :param f:   Floating point
    
    </pre>
    <p>dst : quat</p>
    <p>v : quat</p>
    <p>f : number</p>
    <p><pre>void quat_addf(struct quat *dst, const struct quat *v, float f)</pre></p>
    <hr/><h3>quat_close(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : quat</p>
    <p>param2 : quat</p>
    <p>param3 : number</p>
    <hr/><h3>quat_copy(dst, v)</h3>
    <pre>
    Copies a quaternion
    
    :param dst: Destination
    :param v:   Quaternion to copy
    
    </pre>
    <p>dst : quat</p>
    <p>v : quat</p>
    <p><pre>void quat_copy(struct quat *dst, const struct quat *v)</pre></p>
    <hr/><h3>quat_dist(v1, v2)</h3>
    <pre>
    Gets the distance between two quaternions
    
    :param v1: Quaternion 1
    :param v2: Quaternion 2
    :return:   Distance between the two quaternions
    
    </pre>
    <p>v1 : quat</p>
    <p>v2 : quat</p>
    <p>Return : number</p>
    <p><pre>float quat_dist(const struct quat *v1, const struct quat *v2)</pre></p>
    <hr/><h3>quat_divf(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : quat</p>
    <p>param2 : quat</p>
    <p>param3 : number</p>
    <hr/><h3>quat_dot(v1, v2)</h3>
    <pre>
    Performs a dot product between two quaternions
    
    :param v1: Quaternion 1
    :param v2: Quaternion 2
    :return:   Result of the dot product
    
    </pre>
    <p>v1 : quat</p>
    <p>v2 : quat</p>
    <p>Return : number</p>
    <p><pre>float quat_dot(const struct quat *v1, const struct quat *v2)</pre></p>
    <hr/><h3>quat_exp(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : quat</p>
    <p>param2 : quat</p>
    <hr/><h3>quat_from_axisang(dst, aa)</h3>
    <pre>
    Converts an axis angle to a quaternion
    
    :param dst: Destination quaternion
    :param aa:  Axis angle
    
    </pre>
    <p>dst : quat</p>
    <p>aa : axisang</p>
    <p><pre>void quat_from_axisang(struct quat *dst, const struct axisang *aa)</pre></p>
    <hr/><h3>quat_from_matrix3(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : quat</p>
    <p>param2 : matrix3</p>
    <hr/><h3>quat_from_matrix4(dst, m)</h3>
    <pre>
    Converts the rotational properties of a matrix to a quaternion
    
    :param dst: Destination quaternion
    :param m:   Matrix to convert
    
    </pre>
    <p>dst : quat</p>
    <p>m : matrix4</p>
    <p><pre>void quat_from_matrix4(struct quat *dst, const struct matrix4 *m)</pre></p>
    <hr/><h3>quat_get_dir(dst, q)</h3>
    <pre>
    Converts a quaternion to a directional vector
    
    :param dst: Destination 3-component vector
    :param q:   Quaternion
    
    </pre>
    <p>dst : vec3</p>
    <p>q : quat</p>
    <p><pre>void quat_get_dir(struct vec3 *dst, const struct quat *q)</pre></p>
    <hr/><h3>quat_get_tangent(dst, prev, q, next)</h3>
    <pre>
    Gets a tangent value for the center of three rotational values
    
    :param dst:  Destination quaternion
    :param prev: Previous rotation
    :param q:    Rotation to get tangent for
    :param next: Next rotation
    
    </pre>
    <p>dst : quat</p>
    <p>prev : quat</p>
    <p>q : quat</p>
    <p>next : quat</p>
    <p><pre>void quat_get_tangent(struct quat *dst, const struct quat *prev, const struct quat *q, const struct quat *next)</pre></p>
    <hr/><h3>quat_identity(dst)</h3>
    <pre>
    Sets a quaternion to {0.0f, 0.0f, 0.0f, 1.0f}.
    
    :param dst: Destination
    
    </pre>
    <p>dst : quat</p>
    <p><pre>void quat_identity(struct quat *dst)</pre></p>
    <hr/><h3>quat_interpolate(dst, q1, q2, t)</h3>
    <pre>
    Linearly interpolates two quaternions
    
    :param dst: Destination quaternion
    :param q1:  Quaternion 1
    :param q2:  Quaternion 2
    :param t:   Time value (0.0f..1.0f)
    
    </pre>
    <p>dst : quat</p>
    <p>q1 : quat</p>
    <p>q2 : quat</p>
    <p>t : number</p>
    <p><pre>void quat_interpolate(struct quat *dst, const struct quat *q1, const struct quat *q2, float t)</pre></p>
    <hr/><h3>quat_interpolate_cubic(dst, q1, q2, m1, m2, t)</h3>
    <pre>
    Performs cubic interpolation between two quaternions
    
    :param dst: Destination quaternion
    :param q1:  Quaternion 1
    :param q2:  Quaternion 2
    :param m1:  Tangent 1
    :param m2:  Tangent 2
    :param t:   Time value (0.0f..1.0f)
    </pre>
    <p>dst : quat</p>
    <p>q1 : quat</p>
    <p>q2 : quat</p>
    <p>m1 : quat</p>
    <p>m2 : quat</p>
    <p>t : number</p>
    <p><pre>void quat_interpolate_cubic(struct quat *dst, const struct quat *q1, const struct quat *q2, const struct quat *m1, const struct quat *m2, float t)</pre></p>
    <hr/><h3>quat_inv(dst, v)</h3>
    <pre>
    Inverts a quaternion
    
    :param dst: Destination
    :param v:   Quaternion to invert
    
    </pre>
    <p>dst : quat</p>
    <p>v : quat</p>
    <p><pre>void quat_inv(struct quat *dst, const struct quat *v)</pre></p>
    <hr/><h3>quat_len(v)</h3>
    <pre>
    Gets the length of a quaternion
    
    :param v: Quaternion
    :return:  The quaternion's length
    
    </pre>
    <p>v : quat</p>
    <p>Return : number</p>
    <p><pre>float quat_len(const struct quat *v)</pre></p>
    <hr/><h3>quat_log(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : quat</p>
    <p>param2 : quat</p>
    <hr/><h3>quat_mul(dst, v1, v2)</h3>
    <pre>
    Multiplies two quaternions
    
    :param dst: Destination
    :param v1:  Quaternion 1
    :param v2:  Quaternion 2
    
    </pre>
    <p>dst : quat</p>
    <p>v1 : quat</p>
    <p>v2 : quat</p>
    <p><pre>void quat_mul(struct quat *dst, const struct quat *v1, const struct quat *v2)</pre></p>
    <hr/><h3>quat_mulf(dst, v, f)</h3>
    <pre>
    Multiplies a floating point with all components
    
    :param dst: Destination
    :param dst: Quaternion
    :param f:   Floating point
    
    </pre>
    <p>dst : quat</p>
    <p>v : quat</p>
    <p>f : number</p>
    <p><pre>void quat_mulf(struct quat *dst, const struct quat *v, float f)</pre></p>
    <hr/><h3>quat_neg(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : quat</p>
    <p>param2 : quat</p>
    <hr/><h3>quat_norm(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : quat</p>
    <p>param2 : quat</p>
    <hr/><h3>quat_set(dst, x, y, param4, param5)</h3>
    <pre>
    Sets the individual components of a quaternion.
    
    :param dst: Destination
    :param x:   X component
    :param y:   Y component
    :param y:   Z component
    :param w:   W component
    
    </pre>
    <p>dst : quat</p>
    <p>x : number</p>
    <p>y : number</p>
    <p>param4 : number</p>
    <p>param5 : number</p>
    <p><pre>void quat_set(struct quat *dst, float x, float y)</pre></p>
    <hr/><h3>quat_set_look_dir(dst, dir)</h3>
    <pre>
    Creates a quaternion from a specific "look" direction
    
    :param dst: Destination quaternion
    :param dir: 3-component vector representing the look direction
    
    </pre>
    <p>dst : quat</p>
    <p>dir : vec3</p>
    <p><pre>void quat_set_look_dir(struct quat *dst, const struct vec3 *dir)</pre></p>
    <hr/><h3>quat_sub(dst, v1, v2)</h3>
    <pre>
    Subtracts two quaternions
    
    :param dst: Destination
    :param v1:  Quaternion being subtracted from
    :param v2:  Quaternion being subtracted
    
    </pre>
    <p>dst : quat</p>
    <p>v1 : quat</p>
    <p>v2 : quat</p>
    <p><pre>void quat_sub(struct quat *dst, const struct quat *v1, const struct quat *v2)</pre></p>
    <hr/><h3>quat_subf(dst, v, f)</h3>
    <pre>
    Subtracts a floating point from all components
    
    :param dst: Destination
    :param v:   Quaternion being subtracted from
    :param f:   Floating point being subtracted
    
    </pre>
    <p>dst : quat</p>
    <p>v : quat</p>
    <p>f : number</p>
    <p><pre>void quat_subf(struct quat *dst, const struct quat *v, float f)</pre></p>
    <hr/><h3>remove_current_callback()</h3>
    <pre>
    Removes the current callback being executed.  Does nothing if not
    within a callback.
    
    </pre>
    <p>Return : unknown</p>
    <hr/><h3>sceneitem_list_release(item_list)</h3>
    <pre>
    Releases the references of a scene item list.
    
    :param item_list: Array of scene items to release.
    
    </pre>
    <p>item_list : unknown</p>
    <p>Return : unknown</p>
    <hr/><h3>signal_handler_add(handler, signal_decl)</h3>
    <pre>
    Adds a signal to a signal handler.
    
    :param handler:     Signal handler object
    :param signal_decl: Signal declaration string
    
    </pre>
    <p>handler : signal_handler</p>
    <p>signal_decl : string</p>
    <p>Return : boolean</p>
    <p><pre>bool signal_handler_add(signal_handler_t *handler, const char *signal_decl)</pre></p>
    <hr/><h3>signal_handler_add_array(handler, signal_decls)</h3>
    <pre>
    Adds multiple signals to a signal handler.
    
    :param handler:      Signal handler object
    :param signal_decls: An array of signal declaration strings,
                         terminated by *NULL*
    
    </pre>
    <p>handler : signal_handler</p>
    <p>signal_decls : p_char</p>
    <p>Return : boolean</p>
    <p><pre>bool signal_handler_add_array(signal_handler_t *handler, const char **signal_decls)</pre></p>
    <hr/><h3>signal_handler_connect(handler, signal, callback)</h3>
    <pre>
    Adds a callback to a specific signal on a signal handler.  This
    callback has one parameter:  the calldata_t object.
    
    :param handler:  A signal_handler_t object.
    :param signal:   The signal on the signal handler (string)
    :param callback: The callback to connect to the signal.  Use
                     :py:func:`signal_handler_disconnect()` or
                     :py:func:`remove_current_callback()` to remove the
                     callback.
    
    </pre>
    <p>handler : unknown</p>
    <p>signal : unknown</p>
    <p>callback : unknown</p>
    <p>Return : unknown</p>
    <hr/><h3>signal_handler_connect_global(handler, callback)</h3>
    <pre>
    Adds a global callback to a signal handler.  This callback has two
    parameters:  the first parameter is the signal string, and the second
    parameter is the calldata_t object.
    
    :param handler:  A signal_handler_t object.
    :param callback: The callback to connect.  Use
                     :py:func:`signal_handler_disconnect_global()` or
                     :py:func:`remove_current_callback()` to remove the
                     callback.
    
    </pre>
    <p>handler : unknown</p>
    <p>callback : unknown</p>
    <p>Return : unknown</p>
    <hr/><h3>signal_handler_connect_ref(handler, signal, callback, data)</h3>
    <pre>
    Connect a callback to a signal on a signal handler, and increments
    the handler's internal reference counter, preventing it from being
    destroyed until the signal has been disconnected.
    
    :param handler:  Signal handler object
    :param callback: Signal callback
    :param data:     Private data passed the callback
    
    </pre>
    <p>handler : signal_handler</p>
    <p>signal : string</p>
    <p>callback : f_p_void_p_struct_calldata__void</p>
    <p>data : ref_void*</p>
    <p><pre>void signal_handler_connect_ref(signal_handler_t *handler, const char *signal, signal_callback_t callback, void *data)</pre></p>
    <hr/><h3>signal_handler_create()</h3>
    <pre>
    Creates a new signal handler object.
    
    :return: A new signal handler object
    
    </pre>
    <p>Return : signal_handler</p>
    <p><pre>signal_handler_t *signal_handler_create(void)</pre></p>
    <hr/><h3>signal_handler_destroy(handler)</h3>
    <pre>
    Destroys a signal handler.
    
    :param handler: Signal handler object
    
    </pre>
    <p>handler : signal_handler</p>
    <p><pre>void signal_handler_destroy(signal_handler_t *handler)</pre></p>
    <hr/><h3>signal_handler_disconnect(handler, signal, callback)</h3>
    <pre>
    Removes a callback from a specific signal of a signal handler.
    
    :param handler:  A signal_handler_t object.
    :param signal:   The signal on the signal handler (string)
    :param callback: The callback to disconnect from the signal.
    
    </pre>
    <p>handler : unknown</p>
    <p>signal : unknown</p>
    <p>callback : unknown</p>
    <p>Return : unknown</p>
    <hr/><h3>signal_handler_disconnect_global(handler, callback)</h3>
    <pre>
    Removes a global callback from a signal handler.
    
    :param handler:  A signal_handler_t object.
    :param callback: The callback to disconnect.
    
    </pre>
    <p>handler : unknown</p>
    <p>callback : unknown</p>
    <p>Return : unknown</p>
    <hr/><h3>signal_handler_signal(handler, signal, params)</h3>
    <pre>
    Triggers a signal, calling all connected callbacks.
    
    :param handler: Signal handler object
    :param signal:  Name of signal to trigger
    :param params:  Parameters to pass to the signal
    
    </pre>
    <p>handler : signal_handler</p>
    <p>signal : string</p>
    <p>params : calldata</p>
    <p><pre>void signal_handler_signal(signal_handler_t *handler, const char *signal, calldata_t *params)</pre></p>
    <hr/><h3>source_list_release(source_list)</h3>
    <pre>
    Releases the references of a source list.
    
    :param source_list: Array of sources to release.
    
    </pre>
    <p>source_list : unknown</p>
    <p>Return : unknown</p>
    <hr/><h3>timer_add(callback, milliseconds)</h3>
    <pre>
     Adds an timer callback which triggers every *millseconds*.
    
    </pre>
    <p>callback : unknown</p>
    <p>milliseconds : unknown</p>
    <p>Return : unknown</p>
    <hr/><h3>timer_remove(callback)</h3>
    <pre>
     Removes a timer callback.  (Note: You can also use
     :py:func:`remove_current_callback()` to terminate the timer from the
     timer callback)
    
    Script Sources (Lua Only)
    </pre>
    <p>callback : unknown</p>
    <p>Return : unknown</p>
    <hr/><h3>vec2_abs(dst, v)</h3>
    <pre>
    Gets the absolute values of each component
    
    :param dst: Destination
    :param v:   Vector
    
    </pre>
    <p>dst : vec2</p>
    <p>v : vec2</p>
    <p><pre>void vec2_abs(struct vec2 *dst, const struct vec2 *v)</pre></p>
    <hr/><h3>vec2_add(dst, v1, v2)</h3>
    <pre>
    Adds two vectors
    
    :param dst: Destination
    :param v1:  Vector 1
    :param v2:  Vector 2
    
    </pre>
    <p>dst : vec2</p>
    <p>v1 : vec2</p>
    <p>v2 : vec2</p>
    <p><pre>void vec2_add(struct vec2 *dst, const struct vec2 *v1, const struct vec2 *v2)</pre></p>
    <hr/><h3>vec2_addf(dst, v, f)</h3>
    <pre>
    Adds a floating point to all components
    
    :param dst: Destination
    :param dst: Vector
    :param f:   Floating point
    
    </pre>
    <p>dst : vec2</p>
    <p>v : vec2</p>
    <p>f : number</p>
    <p><pre>void vec2_addf(struct vec2 *dst, const struct vec2 *v, float f)</pre></p>
    <hr/><h3>vec2_ceil(dst, v)</h3>
    <pre>
    Gets the ceiling values of each component
    
    :param dst: Destination
    :param v:   Vector
    
    </pre>
    <p>dst : vec2</p>
    <p>v : vec2</p>
    <p><pre>void vec2_ceil(struct vec2 *dst, const struct vec2 *v)</pre></p>
    <hr/><h3>vec2_close(v1, v2, epsilon)</h3>
    <pre>
    Compares two vectors
    
    :param v1:      Vector 1
    :param v2:      Vector 2
    :param epsilon: Maximum precision for comparison
    
    </pre>
    <p>v1 : vec2</p>
    <p>v2 : vec2</p>
    <p>epsilon : number</p>
    <p>Return : number</p>
    <p><pre>int vec2_close(const struct vec2 *v1, const struct vec2 *v2, float epsilon)</pre></p>
    <hr/><h3>vec2_copy(dst, v)</h3>
    <pre>
    Copies a vector
    
    :param dst: Destination
    :param v:   Vector to copy
    
    </pre>
    <p>dst : vec2</p>
    <p>v : vec2</p>
    <p><pre>void vec2_copy(struct vec2 *dst, const struct vec2 *v)</pre></p>
    <hr/><h3>vec2_dist(v1, v2)</h3>
    <pre>
    Gets the distance between two vectors
    
    :param v1: Vector 1
    :param v2: Vector 2
    :return:   Distance between the two vectors
    
    </pre>
    <p>v1 : vec2</p>
    <p>v2 : vec2</p>
    <p>Return : number</p>
    <p><pre>float vec2_dist(const struct vec2 *v1, const struct vec2 *v2)</pre></p>
    <hr/><h3>vec2_div(dst, v1, v2)</h3>
    <pre>
    Divides two vectors
    
    :param dst: Destination
    :param v1:  Dividend
    :param v2:  Divisor
    
    </pre>
    <p>dst : vec2</p>
    <p>v1 : vec2</p>
    <p>v2 : vec2</p>
    <p><pre>void vec2_div(struct vec2 *dst, const struct vec2 *v1, const struct vec2 *v2)</pre></p>
    <hr/><h3>vec2_divf(dst, v, f)</h3>
    <pre>
    Divides a floating point from all components
    
    :param dst: Destination
    :param v:   Vector (dividend)
    :param f:   Floating point (divisor)
    
    </pre>
    <p>dst : vec2</p>
    <p>v : vec2</p>
    <p>f : number</p>
    <p><pre>void vec2_divf(struct vec2 *dst, const struct vec2 *v, float f)</pre></p>
    <hr/><h3>vec2_dot(v1, v2)</h3>
    <pre>
    Performs a dot product between two vectors
    
    :param v1: Vector 1
    :param v2: Vector 2
    :return:   Result of the dot product
    
    </pre>
    <p>v1 : vec2</p>
    <p>v2 : vec2</p>
    <p>Return : number</p>
    <p><pre>float vec2_dot(const struct vec2 *v1, const struct vec2 *v2)</pre></p>
    <hr/><h3>vec2_floor(dst, v)</h3>
    <pre>
    Gets the floor values of each component
    
    :param dst: Destination
    :param v:   Vector
    
    </pre>
    <p>dst : vec2</p>
    <p>v : vec2</p>
    <p><pre>void vec2_floor(struct vec2 *dst, const struct vec2 *v)</pre></p>
    <hr/><h3>vec2_len(v)</h3>
    <pre>
    Gets the length of a vector
    
    :param v: Vector
    :return:  The vector's length
    
    </pre>
    <p>v : vec2</p>
    <p>Return : number</p>
    <p><pre>float vec2_len(const struct vec2 *v)</pre></p>
    <hr/><h3>vec2_max(dst, v, max_v)</h3>
    <pre>
    Gets the maximum values between two vectors
    
    :param dst:   Destination
    :param v:     Vector 1
    :param max_v: Vector 2
    
    </pre>
    <p>dst : vec2</p>
    <p>v : vec2</p>
    <p>max_v : vec2</p>
    <p><pre>void vec2_max(struct vec2 *dst, const struct vec2 *v, const struct vec2 *max_v)</pre></p>
    <hr/><h3>vec2_maxf(dst, v, val)</h3>
    <pre>
    Gets the maximum values between a vector's components and a floating point
    
    :param dst: Destination
    :param v:   Vector
    :param val: Floating point
    
    </pre>
    <p>dst : vec2</p>
    <p>v : vec2</p>
    <p>val : number</p>
    <p><pre>void vec2_maxf(struct vec2 *dst, const struct vec2 *v, float val)</pre></p>
    <hr/><h3>vec2_min(dst, v, min_v)</h3>
    <pre>
    Gets the minimum values between two vectors
    
    :param dst:   Destination
    :param v:     Vector 1
    :param min_v: Vector 2
    
    </pre>
    <p>dst : vec2</p>
    <p>v : vec2</p>
    <p>min_v : vec2</p>
    <p><pre>void vec2_min(struct vec2 *dst, const struct vec2 *v, const struct vec2 *min_v)</pre></p>
    <hr/><h3>vec2_minf(dst, v, val)</h3>
    <pre>
    Gets the minimum values between a vector's components and a floating point
    
    :param dst: Destination
    :param v:   Vector
    :param val: Floating point
    
    </pre>
    <p>dst : vec2</p>
    <p>v : vec2</p>
    <p>val : number</p>
    <p><pre>void vec2_minf(struct vec2 *dst, const struct vec2 *v, float val)</pre></p>
    <hr/><h3>vec2_mul(dst, v1, v2)</h3>
    <pre>
    Multiplies two vectors
    
    :param dst: Destination
    :param v1:  Vector 1
    :param v2:  Vector 2
    
    </pre>
    <p>dst : vec2</p>
    <p>v1 : vec2</p>
    <p>v2 : vec2</p>
    <p><pre>void vec2_mul(struct vec2 *dst, const struct vec2 *v1, const struct vec2 *v2)</pre></p>
    <hr/><h3>vec2_mulf(dst, v, f)</h3>
    <pre>
    Multiplies a floating point with all components
    
    :param dst: Destination
    :param dst: Vector
    :param f:   Floating point
    
    </pre>
    <p>dst : vec2</p>
    <p>v : vec2</p>
    <p>f : number</p>
    <p><pre>void vec2_mulf(struct vec2 *dst, const struct vec2 *v, float f)</pre></p>
    <hr/><h3>vec2_neg(dst, v)</h3>
    <pre>
    Negates a vector
    
    :param dst: Destination
    :param v:   Vector to negate
    
    </pre>
    <p>dst : vec2</p>
    <p>v : vec2</p>
    <p><pre>void vec2_neg(struct vec2 *dst, const struct vec2 *v)</pre></p>
    <hr/><h3>vec2_norm(dst, v)</h3>
    <pre>
    Normalizes a vector
    
    :param dst: Destination
    :param v:   Vector to normalize
    </pre>
    <p>dst : vec2</p>
    <p>v : vec2</p>
    <p><pre>void vec2_norm(struct vec2 *dst, const struct vec2 *v)</pre></p>
    <hr/><h3>vec2_set(dst, x, y)</h3>
    <pre>
    Sets the individual components of a 2-component vector.
    
    :param dst: Destination
    :param x:   X component
    :param y:   Y component
    
    </pre>
    <p>dst : vec2</p>
    <p>x : number</p>
    <p>y : number</p>
    <p><pre>void vec2_set(struct vec2 *dst, float x, float y)</pre></p>
    <hr/><h3>vec2_sub(dst, v1, v2)</h3>
    <pre>
    Subtracts two vectors
    
    :param dst: Destination
    :param v1:  Vector being subtracted from
    :param v2:  Vector being subtracted
    
    </pre>
    <p>dst : vec2</p>
    <p>v1 : vec2</p>
    <p>v2 : vec2</p>
    <p><pre>void vec2_sub(struct vec2 *dst, const struct vec2 *v1, const struct vec2 *v2)</pre></p>
    <hr/><h3>vec2_subf(dst, v, f)</h3>
    <pre>
    Subtracts a floating point from all components
    
    :param dst: Destination
    :param v:   Vector being subtracted from
    :param f:   Floating point being subtracted
    
    </pre>
    <p>dst : vec2</p>
    <p>v : vec2</p>
    <p>f : number</p>
    <p><pre>void vec2_subf(struct vec2 *dst, const struct vec2 *v, float f)</pre></p>
    <hr/><h3>vec2_zero(dst)</h3>
    <pre>
    Zeroes a vector
    
    :param dst: Destination
    
    </pre>
    <p>dst : vec2</p>
    <p><pre>void vec2_zero(struct vec2 *dst)</pre></p>
    <hr/><h3>vec3_abs(dst, v)</h3>
    <pre>
    Gets the absolute values of each component
    
    :param dst: Destination
    :param v:   Vector
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p><pre>void vec3_abs(struct vec3 *dst, const struct vec3 *v)</pre></p>
    <hr/><h3>vec3_add(dst, v1, v2)</h3>
    <pre>
    Adds two vectors
    
    :param dst: Destination
    :param v1:  Vector 1
    :param v2:  Vector 2
    
    </pre>
    <p>dst : vec3</p>
    <p>v1 : vec3</p>
    <p>v2 : vec3</p>
    <p><pre>void vec3_add(struct vec3 *dst, const struct vec3 *v1, const struct vec3 *v2)</pre></p>
    <hr/><h3>vec3_addf(dst, v, f)</h3>
    <pre>
    Adds a floating point to all components
    
    :param dst: Destination
    :param dst: Vector
    :param f:   Floating point
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p>f : number</p>
    <p><pre>void vec3_addf(struct vec3 *dst, const struct vec3 *v, float f)</pre></p>
    <hr/><h3>vec3_ceil(dst, v)</h3>
    <pre>
    Gets the ceiling values of each component
    
    :param dst: Destination
    :param v:   Vector
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p><pre>void vec3_ceil(struct vec3 *dst, const struct vec3 *v)</pre></p>
    <hr/><h3>vec3_close(v1, v2, epsilon)</h3>
    <pre>
    Compares two vectors
    
    :param v1:      Vector 1
    :param v2:      Vector 2
    :param epsilon: Maximum precision for comparison
    
    </pre>
    <p>v1 : vec3</p>
    <p>v2 : vec3</p>
    <p>epsilon : number</p>
    <p>Return : boolean</p>
    <p><pre>int vec3_close(const struct vec3 *v1, const struct vec3 *v2, float epsilon)</pre></p>
    <hr/><h3>vec3_copy(dst, v)</h3>
    <pre>
    Copies a vector
    
    :param dst: Destination
    :param v:   Vector to copy
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p><pre>void vec3_copy(struct vec3 *dst, const struct vec3 *v)</pre></p>
    <hr/><h3>vec3_cross(dst, v1, v2)</h3>
    <pre>
    Performs a cross product between two vectors
    
    :param dst: Destination
    :param v1:  Vector 1
    :param v2:  Vector 2
    
    </pre>
    <p>dst : vec3</p>
    <p>v1 : vec3</p>
    <p>v2 : vec3</p>
    <p><pre>void vec3_cross(struct vec3 *dst, const struct vec3 *v1, const struct vec3 *v2)</pre></p>
    <hr/><h3>vec3_dist(v1, v2)</h3>
    <pre>
    Gets the distance between two vectors
    
    :param v1: Vector 1
    :param v2: Vector 2
    :return:   Distance between the two vectors
    
    </pre>
    <p>v1 : vec3</p>
    <p>v2 : vec3</p>
    <p>Return : number</p>
    <p><pre>float vec3_dist(const struct vec3 *v1, const struct vec3 *v2)</pre></p>
    <hr/><h3>vec3_div(dst, v1, v2)</h3>
    <pre>
    Divides two vectors
    
    :param dst: Destination
    :param v1:  Dividend
    :param v2:  Divisor
    
    </pre>
    <p>dst : vec3</p>
    <p>v1 : vec3</p>
    <p>v2 : vec3</p>
    <p><pre>void vec3_div(struct vec3 *dst, const struct vec3 *v1, const struct vec3 *v2)</pre></p>
    <hr/><h3>vec3_divf(dst, v, f)</h3>
    <pre>
    Divides a floating point from all components
    
    :param dst: Destination
    :param v:   Vector (dividend)
    :param f:   Floating point (divisor)
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p>f : number</p>
    <p><pre>void vec3_divf(struct vec3 *dst, const struct vec3 *v, float f)</pre></p>
    <hr/><h3>vec3_dot(v1, v2)</h3>
    <pre>
    Performs a dot product between two vectors
    
    :param v1: Vector 1
    :param v2: Vector 2
    :return:   Result of the dot product
    
    </pre>
    <p>v1 : vec3</p>
    <p>v2 : vec3</p>
    <p>Return : number</p>
    <p><pre>float vec3_dot(const struct vec3 *v1, const struct vec3 *v2)</pre></p>
    <hr/><h3>vec3_floor(dst, v)</h3>
    <pre>
    Gets the floor values of each component
    
    :param dst: Destination
    :param v:   Vector
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p><pre>void vec3_floor(struct vec3 *dst, const struct vec3 *v)</pre></p>
    <hr/><h3>vec3_from_vec4(dst, v)</h3>
    <pre>
    Creates a 3-component vector from a 4-component vector
    
    :param dst: 3-component vector destination
    :param v:   4-component vector
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec4</p>
    <p><pre>void vec3_from_vec4(struct vec3 *dst, const struct vec4 *v)</pre></p>
    <hr/><h3>vec3_len(v)</h3>
    <pre>
    Gets the length of a vector
    
    :param v: Vector
    :return:  The vector's length
    
    </pre>
    <p>v : vec3</p>
    <p>Return : number</p>
    <p><pre>float vec3_len(const struct vec3 *v)</pre></p>
    <hr/><h3>vec3_max(dst, v, max_v)</h3>
    <pre>
    Gets the maximum values between two vectors
    
    :param dst:   Destination
    :param v:     Vector 1
    :param max_v: Vector 2
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p>max_v : vec3</p>
    <p><pre>void vec3_max(struct vec3 *dst, const struct vec3 *v, const struct vec3 *max_v)</pre></p>
    <hr/><h3>vec3_maxf(dst, v, val)</h3>
    <pre>
    Gets the maximum values between a vector's components and a floating point
    
    :param dst: Destination
    :param v:   Vector
    :param val: Floating point
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p>val : number</p>
    <p><pre>void vec3_maxf(struct vec3 *dst, const struct vec3 *v, float val)</pre></p>
    <hr/><h3>vec3_min(dst, v, min_v)</h3>
    <pre>
    Gets the minimum values between two vectors
    
    :param dst:   Destination
    :param v:     Vector 1
    :param min_v: Vector 2
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p>min_v : vec3</p>
    <p><pre>void vec3_min(struct vec3 *dst, const struct vec3 *v, const struct vec3 *min_v)</pre></p>
    <hr/><h3>vec3_minf(dst, v, val)</h3>
    <pre>
    Gets the minimum values between a vector's components and a floating point
    
    :param dst: Destination
    :param v:   Vector
    :param val: Floating point
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p>val : number</p>
    <p><pre>void vec3_minf(struct vec3 *dst, const struct vec3 *v, float val)</pre></p>
    <hr/><h3>vec3_mirror(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : vec3</p>
    <p>param2 : vec3</p>
    <p>param3 : plane</p>
    <hr/><h3>vec3_mirrorv(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : vec3</p>
    <p>param2 : vec3</p>
    <p>param3 : vec3</p>
    <hr/><h3>vec3_mul(dst, v1, v2)</h3>
    <pre>
    Multiplies two vectors
    
    :param dst: Destination
    :param v1:  Vector 1
    :param v2:  Vector 2
    
    </pre>
    <p>dst : vec3</p>
    <p>v1 : vec3</p>
    <p>v2 : vec3</p>
    <p><pre>void vec3_mul(struct vec3 *dst, const struct vec3 *v1, const struct vec3 *v2)</pre></p>
    <hr/><h3>vec3_mulf(dst, v, f)</h3>
    <pre>
    Multiplies a floating point with all components
    
    :param dst: Destination
    :param dst: Vector
    :param f:   Floating point
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p>f : number</p>
    <p><pre>void vec3_mulf(struct vec3 *dst, const struct vec3 *v, float f)</pre></p>
    <hr/><h3>vec3_neg(dst, v)</h3>
    <pre>
    Negates a vector
    
    :param dst: Destination
    :param v:   Vector to negate
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p><pre>void vec3_neg(struct vec3 *dst, const struct vec3 *v)</pre></p>
    <hr/><h3>vec3_norm(dst, v)</h3>
    <pre>
    Normalizes a vector
    
    :param dst: Destination
    :param v:   Vector to normalize
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p><pre>void vec3_norm(struct vec3 *dst, const struct vec3 *v)</pre></p>
    <hr/><h3>vec3_plane_dist(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : vec3</p>
    <p>param2 : plane</p>
    <hr/><h3>vec3_rand(dst, positive_only)</h3>
    <pre>
    Generates a random vector
    
    :param dst:           Destination
    :param positive_only: *true* if positive only, *false* otherwise
    </pre>
    <p>dst : vec3</p>
    <p>positive_only : number</p>
    <p><pre>void vec3_rand(struct vec3 *dst, int positive_only)</pre></p>
    <hr/><h3>vec3_rotate(dst, v, m)</h3>
    <pre>
    Rotates a vector
    
    :param dst: Destination
    :param v:   Vector
    :param m:   Matrix
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p>m : matrix3</p>
    <p><pre>void vec3_rotate(struct vec3 *dst, const struct vec3 *v, const struct matrix3 *m)</pre></p>
    <hr/><h3>vec3_set(dst, x, y, param4)</h3>
    <pre>
    Sets the individual components of a 3-component vector.
    
    :param dst: Destination
    :param x:   X component
    :param y:   Y component
    :param y:   Z component
    
    </pre>
    <p>dst : vec3</p>
    <p>x : number</p>
    <p>y : number</p>
    <p>param4 : number</p>
    <p><pre>void vec3_set(struct vec3 *dst, float x, float y)</pre></p>
    <hr/><h3>vec3_sub(dst, v1, v2)</h3>
    <pre>
    Subtracts two vectors
    
    :param dst: Destination
    :param v1:  Vector being subtracted from
    :param v2:  Vector being subtracted
    
    </pre>
    <p>dst : vec3</p>
    <p>v1 : vec3</p>
    <p>v2 : vec3</p>
    <p><pre>void vec3_sub(struct vec3 *dst, const struct vec3 *v1, const struct vec3 *v2)</pre></p>
    <hr/><h3>vec3_subf(dst, v, f)</h3>
    <pre>
    Subtracts a floating point from all components
    
    :param dst: Destination
    :param v:   Vector being subtracted from
    :param f:   Floating point being subtracted
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p>f : number</p>
    <p><pre>void vec3_subf(struct vec3 *dst, const struct vec3 *v, float f)</pre></p>
    <hr/><h3>vec3_transform(dst, v, m)</h3>
    <pre>
    Transforms a vector
    
    :param dst: Destination
    :param v:   Vector
    :param m:   Matrix
    
    </pre>
    <p>dst : vec3</p>
    <p>v : vec3</p>
    <p>m : matrix4</p>
    <p><pre>void vec3_transform(struct vec3 *dst, const struct vec3 *v, const struct matrix4 *m)</pre></p>
    <hr/><h3>vec3_transform3x4(param1, param2, param3)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : vec3</p>
    <p>param2 : vec3</p>
    <p>param3 : matrix3</p>
    <hr/><h3>vec3_zero(dst)</h3>
    <pre>
    Zeroes a vector
    
    :param dst: Destination
    
    </pre>
    <p>dst : vec3</p>
    <p><pre>void vec3_zero(struct vec3 *dst)</pre></p>
    <hr/><h3>vec4_abs(dst, v)</h3>
    <pre>
    Gets the absolute values of each component
    
    :param dst: Destination
    :param v:   Vector
    
    </pre>
    <p>dst : vec4</p>
    <p>v : vec4</p>
    <p><pre>void vec4_abs(struct vec4 *dst, const struct vec4 *v)</pre></p>
    <hr/><h3>vec4_add(dst, v1, v2)</h3>
    <pre>
    Adds two vectors
    
    :param dst: Destination
    :param v1:  Vector 1
    :param v2:  Vector 2
    
    </pre>
    <p>dst : vec4</p>
    <p>v1 : vec4</p>
    <p>v2 : vec4</p>
    <p><pre>void vec4_add(struct vec4 *dst, const struct vec4 *v1, const struct vec4 *v2)</pre></p>
    <hr/><h3>vec4_addf(dst, v, f)</h3>
    <pre>
    Adds a floating point to all components
    
    :param dst: Destination
    :param dst: Vector
    :param f:   Floating point
    
    </pre>
    <p>dst : vec4</p>
    <p>v : vec4</p>
    <p>f : number</p>
    <p><pre>void vec4_addf(struct vec4 *dst, const struct vec4 *v, float f)</pre></p>
    <hr/><h3>vec4_ceil(dst, v)</h3>
    <pre>
    Gets the ceiling values of each component
    
    :param dst: Destination
    :param v:   Vector
    
    </pre>
    <p>dst : vec4</p>
    <p>v : vec4</p>
    <p><pre>void vec4_ceil(struct vec4 *dst, const struct vec4 *v)</pre></p>
    <hr/><h3>vec4_close(v1, v2, epsilon)</h3>
    <pre>
    Compares two vectors
    
    :param v1:      Vector 1
    :param v2:      Vector 2
    :param epsilon: Maximum precision for comparison
    
    </pre>
    <p>v1 : vec4</p>
    <p>v2 : vec4</p>
    <p>epsilon : number</p>
    <p>Return : number</p>
    <p><pre>int vec4_close(const struct vec4 *v1, const struct vec4 *v2, float epsilon)</pre></p>
    <hr/><h3>vec4_copy(dst, v)</h3>
    <pre>
    Copies a vector
    
    :param dst: Destination
    :param v:   Vector to copy
    
    </pre>
    <p>dst : vec4</p>
    <p>v : vec4</p>
    <p><pre>void vec4_copy(struct vec4 *dst, const struct vec4 *v)</pre></p>
    <hr/><h3>vec4_dist(v1, v2)</h3>
    <pre>
    Gets the distance between two vectors
    
    :param v1: Vector 1
    :param v2: Vector 2
    :return:   Distance between the two vectors
    
    </pre>
    <p>v1 : vec4</p>
    <p>v2 : vec4</p>
    <p>Return : number</p>
    <p><pre>float vec4_dist(const struct vec4 *v1, const struct vec4 *v2)</pre></p>
    <hr/><h3>vec4_div(dst, v1, v2)</h3>
    <pre>
    Divides two vectors
    
    :param dst: Destination
    :param v1:  Dividend
    :param v2:  Divisor
    
    </pre>
    <p>dst : vec4</p>
    <p>v1 : vec4</p>
    <p>v2 : vec4</p>
    <p><pre>void vec4_div(struct vec4 *dst, const struct vec4 *v1, const struct vec4 *v2)</pre></p>
    <hr/><h3>vec4_divf(dst, v, f)</h3>
    <pre>
    Divides a floating point from all components
    
    :param dst: Destination
    :param v:   Vector (dividend)
    :param f:   Floating point (divisor)
    
    </pre>
    <p>dst : vec4</p>
    <p>v : vec4</p>
    <p>f : number</p>
    <p><pre>void vec4_divf(struct vec4 *dst, const struct vec4 *v, float f)</pre></p>
    <hr/><h3>vec4_dot(v1, v2)</h3>
    <pre>
    Performs a dot product between two vectors
    
    :param v1: Vector 1
    :param v2: Vector 2
    :return:   Result of the dot product
    
    </pre>
    <p>v1 : vec4</p>
    <p>v2 : vec4</p>
    <p>Return : number</p>
    <p><pre>float vec4_dot(const struct vec4 *v1, const struct vec4 *v2)</pre></p>
    <hr/><h3>vec4_floor(dst, v)</h3>
    <pre>
    Gets the floor values of each component
    
    :param dst: Destination
    :param v:   Vector
    
    </pre>
    <p>dst : vec4</p>
    <p>v : vec4</p>
    <p><pre>void vec4_floor(struct vec4 *dst, const struct vec4 *v)</pre></p>
    <hr/><h3>vec4_from_bgra(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : vec4</p>
    <p>param2 : number</p>
    <hr/><h3>vec4_from_rgba(param1, param2)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : vec4</p>
    <p>param2 : number</p>
    <hr/><h3>vec4_from_vec3(dst, v)</h3>
    <pre>
    Creates a 4-component vector from a 3-component vector
    
    :param dst: 4-component vector destination
    :param v:   3-component vector
    
    </pre>
    <p>dst : vec4</p>
    <p>v : vec3</p>
    <p><pre>void vec4_from_vec3(struct vec4 *dst, const struct vec3 *v)</pre></p>
    <hr/><h3>vec4_len(v)</h3>
    <pre>
    Gets the length of a vector
    
    :param v: Vector
    :return:  The vector's length
    
    </pre>
    <p>v : vec4</p>
    <p>Return : number</p>
    <p><pre>float vec4_len(const struct vec4 *v)</pre></p>
    <hr/><h3>vec4_max(dst, v, max_v)</h3>
    <pre>
    Gets the maximum values between two vectors
    
    :param dst:   Destination
    :param v:     Vector 1
    :param max_v: Vector 2
    
    </pre>
    <p>dst : vec4</p>
    <p>v : vec4</p>
    <p>max_v : vec4</p>
    <p><pre>void vec4_max(struct vec4 *dst, const struct vec4 *v, const struct vec4 *max_v)</pre></p>
    <hr/><h3>vec4_maxf(dst, v, val)</h3>
    <pre>
    Gets the maximum values between a vector's components and a floating point
    
    :param dst: Destination
    :param v:   Vector
    :param val: Floating point
    
    </pre>
    <p>dst : vec4</p>
    <p>v : vec4</p>
    <p>val : number</p>
    <p><pre>void vec4_maxf(struct vec4 *dst, const struct vec4 *v, float val)</pre></p>
    <hr/><h3>vec4_min(dst, v, min_v)</h3>
    <pre>
    Gets the minimum values between two vectors
    
    :param dst:   Destination
    :param v:     Vector 1
    :param min_v: Vector 2
    
    </pre>
    <p>dst : vec4</p>
    <p>v : vec4</p>
    <p>min_v : vec4</p>
    <p><pre>void vec4_min(struct vec4 *dst, const struct vec4 *v, const struct vec4 *min_v)</pre></p>
    <hr/><h3>vec4_minf(dst, v, val)</h3>
    <pre>
    Gets the minimum values between a vector's components and a floating point
    
    :param dst: Destination
    :param v:   Vector
    :param val: Floating point
    
    </pre>
    <p>dst : vec4</p>
    <p>v : vec4</p>
    <p>val : number</p>
    <p><pre>void vec4_minf(struct vec4 *dst, const struct vec4 *v, float val)</pre></p>
    <hr/><h3>vec4_mul(dst, v1, v2)</h3>
    <pre>
    Multiplies two vectors
    
    :param dst: Destination
    :param v1:  Vector 1
    :param v2:  Vector 2
    
    </pre>
    <p>dst : vec4</p>
    <p>v1 : vec4</p>
    <p>v2 : vec4</p>
    <p><pre>void vec4_mul(struct vec4 *dst, const struct vec4 *v1, const struct vec4 *v2)</pre></p>
    <hr/><h3>vec4_mulf(dst, v, f)</h3>
    <pre>
    Multiplies a floating point with all components
    
    :param dst: Destination
    :param dst: Vector
    :param f:   Floating point
    
    </pre>
    <p>dst : vec4</p>
    <p>v : vec4</p>
    <p>f : number</p>
    <p><pre>void vec4_mulf(struct vec4 *dst, const struct vec4 *v, float f)</pre></p>
    <hr/><h3>vec4_neg(dst, v)</h3>
    <pre>
    Negates a vector
    
    :param dst: Destination
    :param v:   Vector to negate
    
    </pre>
    <p>dst : vec4</p>
    <p>v : vec4</p>
    <p><pre>void vec4_neg(struct vec4 *dst, const struct vec4 *v)</pre></p>
    <hr/><h3>vec4_norm(dst, v)</h3>
    <pre>
    Normalizes a vector
    
    :param dst: Destination
    :param v:   Vector to normalize
    
    </pre>
    <p>dst : vec4</p>
    <p>v : vec4</p>
    <p><pre>void vec4_norm(struct vec4 *dst, const struct vec4 *v)</pre></p>
    <hr/><h3>vec4_set(dst, x, y, z, w)</h3>
    <pre>
    Sets the individual components of a 4-component vector.
    
    :param dst: Destination
    :param x:   X component
    :param y:   Y component
    :param z:   Z component
    :param w:   W component
    
    </pre>
    <p>dst : vec4</p>
    <p>x : number</p>
    <p>y : number</p>
    <p>z : number</p>
    <p>w : number</p>
    <p><pre>void vec4_set(struct vec4 *dst, float x, float y, float z, float w)</pre></p>
    <hr/><h3>vec4_sub(dst, v1, v2)</h3>
    <pre>
    Subtracts two vectors
    
    :param dst: Destination
    :param v1:  Vector being subtracted from
    :param v2:  Vector being subtracted
    
    </pre>
    <p>dst : vec4</p>
    <p>v1 : vec4</p>
    <p>v2 : vec4</p>
    <p><pre>void vec4_sub(struct vec4 *dst, const struct vec4 *v1, const struct vec4 *v2)</pre></p>
    <hr/><h3>vec4_subf(dst, v, f)</h3>
    <pre>
    Subtracts a floating point from all components
    
    :param dst: Destination
    :param v:   Vector being subtracted from
    :param f:   Floating point being subtracted
    
    </pre>
    <p>dst : vec4</p>
    <p>v : vec4</p>
    <p>f : number</p>
    <p><pre>void vec4_subf(struct vec4 *dst, const struct vec4 *v, float f)</pre></p>
    <hr/><h3>vec4_to_bgra(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : vec4</p>
    <hr/><h3>vec4_to_rgba(param1)</h3>
    <p>Not mentioned in OBS documentation</p>
    <p>param1 : vec4</p>
    <hr/><h3>vec4_transform(dst, v, m)</h3>
    <pre>
    Transforms a vector
    
    :param dst: Destination
    :param v:   Vector
    :param m:   Matrix
    </pre>
    <p>dst : vec4</p>
    <p>v : vec4</p>
    <p>m : matrix4</p>
    <p><pre>void vec4_transform(struct vec4 *dst, const struct vec4 *v, const struct matrix4 *m)</pre></p>
    <hr/><h3>vec4_zero(dst)</h3>
    <pre>
    Zeroes a vector
    
    :param dst: Destination
    
    </pre>
    <p>dst : vec4</p>
    <p><pre>void vec4_zero(struct vec4 *dst)</pre></p>
  </body>
</html>
